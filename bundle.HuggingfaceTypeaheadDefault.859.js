/*! For license information please see bundle.HuggingfaceTypeaheadDefault.859.js.LICENSE.txt */
(self.webpackChunkfrontend_ts_encoding=self.webpackChunkfrontend_ts_encoding||[]).push([[859],{6348:(e,t,n)=>{"use strict";n.d(t,{A:()=>f});var r=n(2379),s=n.n(r),a=n(1364),i=n.n(a),o=n(3615),l=n.n(o),u=new URL(n(4182),n.b),c=new URL(n(6436),n.b),d=i()(s()),h=l()(u),p=l()(c);d.push([e.id,`html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#fff;color:#111}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:0;padding:0}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*{box-sizing:inherit}html,body{font-family:Arial,Helvetica,sans-serif;box-sizing:border-box;height:100%}body{color:#111;font-size:1.1em;line-height:1.5;background:#fff}main{display:block}h1,h2,h3,h4,h5,h6{margin:0;padding:.6em 0}li{margin:0 0 .3em}a{color:#0074d9;text-decoration:none;box-shadow:none;transition:all .3s}code{padding:.3em .6em;font-size:.8em;background:#f5f5f5}pre{text-align:left;padding:.3em;background:#f5f5f5;border-radius:.2em}pre code{padding:0}blockquote{padding:0 0 0 1em;margin:0 0 0 .1em;box-shadow:inset 5px 0 rgba(17,17,17,.3)}label{cursor:pointer}[class^=icon-]:before,[class*=" icon-"]:before{margin:0 .6em 0 0}i[class^=icon-]:before,i[class*=" icon-"]:before{margin:0}.dropimage,button,.button,[type=submit],.label,[data-tooltip]:after{display:inline-block;text-align:center;letter-spacing:inherit;margin:0;padding:.3em .9em;vertical-align:middle;background:#0074d9;color:#fff;border:0;border-radius:.2em;width:auto;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.success.dropimage,button.success,.success.button,.success[type=submit],.success.label,.success[data-tooltip]:after{background:#2ecc40}.warning.dropimage,button.warning,.warning.button,.warning[type=submit],.warning.label,.warning[data-tooltip]:after{background:#ff851b}.error.dropimage,button.error,.error.button,.error[type=submit],.error.label,.error[data-tooltip]:after{background:#ff4136}.pseudo.dropimage,button.pseudo,.pseudo.button,.pseudo[type=submit],.pseudo.label,.pseudo[data-tooltip]:after{background-color:transparent;color:inherit}.label,[data-tooltip]:after{font-size:.6em;padding:.4em .6em;margin-left:1em;line-height:1}.dropimage,button,.button,[type=submit]{margin:.3em 0;cursor:pointer;transition:all .3s;border-radius:.2em;height:auto;vertical-align:baseline;box-shadow:0 0 rgba(17,17,17,0) inset}.dropimage:hover,button:hover,.button:hover,[type=submit]:hover,.dropimage:focus,button:focus,.button:focus,[type=submit]:focus{box-shadow:inset 0 0 0 99em rgba(255,255,255,.2);border:0}.pseudo.dropimage:hover,button.pseudo:hover,.pseudo.button:hover,.pseudo[type=submit]:hover,.pseudo.dropimage:focus,button.pseudo:focus,.pseudo.button:focus,.pseudo[type=submit]:focus{box-shadow:inset 0 0 0 99em rgba(17,17,17,.1)}.active.dropimage,button.active,.active.button,.active[type=submit],.dropimage:active,button:active,.button:active,[type=submit]:active{box-shadow:inset 0 0 0 99em rgba(17,17,17,.2)}[disabled].dropimage,button[disabled],[disabled].button,[disabled][type=submit]{cursor:default;box-shadow:none;background:#aaa}:checked+.toggle,:checked+.toggle:hover{box-shadow:inset 0 0 0 99em rgba(17,17,17,.2)}[type]+.toggle{padding:.3em .9em;margin-right:0}[type]+.toggle:after,[type]+.toggle:before{display:none}input,textarea,.select select{line-height:1.5;margin:0;height:2.1em;padding:.3em .6em;border:1px solid #aaa;background-color:#fff;border-radius:.2em;transition:all .3s;width:100%}input:focus,textarea:focus,.select select:focus{border:1px solid #0074d9;outline:0}textarea{height:auto}[type=file],[type=color]{cursor:pointer}[type=file]{height:auto}select{background:#fff url(${h}) no-repeat scroll 95% center/10px 15px;background-position:calc(100% - 15px) center;border:1px solid #aaa;border-radius:.2em;cursor:pointer;width:100%;height:2.2em;box-sizing:border-box;padding:.3em .45em;transition:all .3s;-moz-appearance:none;-webkit-appearance:none;appearance:none}select::-ms-expand{display:none}select:focus,select:active{border:1px solid #0074d9;transition:outline 0s}select:-moz-focusring{color:transparent;text-shadow:0 0 0 #111}select option{font-size:inherit;padding:.45em}select[multiple]{height:auto;background:none;padding:0}[type=checkbox],[type=radio]{opacity:0;width:0;position:absolute;display:inline-block}[type=checkbox]+.checkable:hover:before,[type=radio]+.checkable:hover:before,[type=checkbox]:focus+.checkable:before,[type=radio]:focus+.checkable:before{border:1px solid #0074d9}[type=checkbox]+.checkable,[type=radio]+.checkable{position:relative;cursor:pointer;padding-left:1.5em;margin-right:.6em}[type=checkbox]+.checkable:before,[type=radio]+.checkable:before,[type=checkbox]+.checkable:after,[type=radio]+.checkable:after{content:"";position:absolute;display:inline-block;left:0;top:50%;transform:translateY(-50%);font-size:1em;line-height:1em;color:transparent;font-family:sans;text-align:center;box-sizing:border-box;width:1em;height:1em;border-radius:50%;transition:all .3s}[type=checkbox]+.checkable:before,[type=radio]+.checkable:before{border:1px solid #aaa}[type=checkbox]:checked+.checkable:after,[type=radio]:checked+.checkable:after{background:#111;transform:scale(0.5) translateY(-100%)}[type=checkbox]+.checkable:before{border-radius:.2em}[type=checkbox]+.checkable:after{content:"✔";background:none;transform:scale(2) translateY(-25%);visibility:hidden;opacity:0}[type=checkbox]:checked+.checkable:after{color:#111;background:none;transform:translateY(-50%);transition:all .3s;visibility:visible;opacity:1}table{text-align:left}td,th{padding:.3em 2.4em .3em .6em}th{text-align:left;font-weight:900;color:#fff;background-color:#0074d9}.success th{background-color:#2ecc40}.warning th{background-color:#ff851b}.error th{background-color:#ff4136}.dull th{background-color:#aaa}tr:nth-child(even){background:rgba(17,17,17,.05)}.flex{display:-ms-flexbox;display:flex;margin-left:-0.6em;width:calc(100% + 0.6em);flex-wrap:wrap;transition:all .3s ease}.flex>*{box-sizing:border-box;flex:1 1 auto;padding-left:.6em;padding-bottom:.6em}.flex[class*=one]>*,.flex[class*=two]>*,.flex[class*=three]>*,.flex[class*=four]>*,.flex[class*=five]>*,.flex[class*=six]>*,.flex[class*=seven]>*,.flex[class*=eight]>*,.flex[class*=nine]>*,.flex[class*=ten]>*,.flex[class*=eleven]>*,.flex[class*=twelve]>*{flex-grow:0}.flex.grow>*{flex-grow:1}.center{justify-content:center}.one>*{width:100%}.two>*{width:50%}.three>*{width:33.33333%}.four>*{width:25%}.five>*{width:20%}.six>*{width:16.66666%}.seven>*{width:14.28571%}.eight>*{width:12.5%}.nine>*{width:11.11111%}.ten>*{width:10%}.eleven>*{width:9.09091%}.twelve>*{width:8.33333%}@media all and (min-width: 500px){.one-500>*{width:100%}.two-500>*{width:50%}.three-500>*{width:33.33333%}.four-500>*{width:25%}.five-500>*{width:20%}.six-500>*{width:16.66666%}.seven-500>*{width:14.28571%}.eight-500>*{width:12.5%}.nine-500>*{width:11.11111%}.ten-500>*{width:10%}.eleven-500>*{width:9.09091%}.twelve-500>*{width:8.33333%}}@media all and (min-width: 600px){.one-600>*{width:100%}.two-600>*{width:50%}.three-600>*{width:33.33333%}.four-600>*{width:25%}.five-600>*{width:20%}.six-600>*{width:16.66666%}.seven-600>*{width:14.28571%}.eight-600>*{width:12.5%}.nine-600>*{width:11.11111%}.ten-600>*{width:10%}.eleven-600>*{width:9.09091%}.twelve-600>*{width:8.33333%}}@media all and (min-width: 700px){.one-700>*{width:100%}.two-700>*{width:50%}.three-700>*{width:33.33333%}.four-700>*{width:25%}.five-700>*{width:20%}.six-700>*{width:16.66666%}.seven-700>*{width:14.28571%}.eight-700>*{width:12.5%}.nine-700>*{width:11.11111%}.ten-700>*{width:10%}.eleven-700>*{width:9.09091%}.twelve-700>*{width:8.33333%}}@media all and (min-width: 800px){.one-800>*{width:100%}.two-800>*{width:50%}.three-800>*{width:33.33333%}.four-800>*{width:25%}.five-800>*{width:20%}.six-800>*{width:16.66666%}.seven-800>*{width:14.28571%}.eight-800>*{width:12.5%}.nine-800>*{width:11.11111%}.ten-800>*{width:10%}.eleven-800>*{width:9.09091%}.twelve-800>*{width:8.33333%}}@media all and (min-width: 900px){.one-900>*{width:100%}.two-900>*{width:50%}.three-900>*{width:33.33333%}.four-900>*{width:25%}.five-900>*{width:20%}.six-900>*{width:16.66666%}.seven-900>*{width:14.28571%}.eight-900>*{width:12.5%}.nine-900>*{width:11.11111%}.ten-900>*{width:10%}.eleven-900>*{width:9.09091%}.twelve-900>*{width:8.33333%}}@media all and (min-width: 1000px){.one-1000>*{width:100%}.two-1000>*{width:50%}.three-1000>*{width:33.33333%}.four-1000>*{width:25%}.five-1000>*{width:20%}.six-1000>*{width:16.66666%}.seven-1000>*{width:14.28571%}.eight-1000>*{width:12.5%}.nine-1000>*{width:11.11111%}.ten-1000>*{width:10%}.eleven-1000>*{width:9.09091%}.twelve-1000>*{width:8.33333%}}@media all and (min-width: 1100px){.one-1100>*{width:100%}.two-1100>*{width:50%}.three-1100>*{width:33.33333%}.four-1100>*{width:25%}.five-1100>*{width:20%}.six-1100>*{width:16.66666%}.seven-1100>*{width:14.28571%}.eight-1100>*{width:12.5%}.nine-1100>*{width:11.11111%}.ten-1100>*{width:10%}.eleven-1100>*{width:9.09091%}.twelve-1100>*{width:8.33333%}}@media all and (min-width: 1200px){.one-1200>*{width:100%}.two-1200>*{width:50%}.three-1200>*{width:33.33333%}.four-1200>*{width:25%}.five-1200>*{width:20%}.six-1200>*{width:16.66666%}.seven-1200>*{width:14.28571%}.eight-1200>*{width:12.5%}.nine-1200>*{width:11.11111%}.ten-1200>*{width:10%}.eleven-1200>*{width:9.09091%}.twelve-1200>*{width:8.33333%}}@media all and (min-width: 1300px){.one-1300>*{width:100%}.two-1300>*{width:50%}.three-1300>*{width:33.33333%}.four-1300>*{width:25%}.five-1300>*{width:20%}.six-1300>*{width:16.66666%}.seven-1300>*{width:14.28571%}.eight-1300>*{width:12.5%}.nine-1300>*{width:11.11111%}.ten-1300>*{width:10%}.eleven-1300>*{width:9.09091%}.twelve-1300>*{width:8.33333%}}@media all and (min-width: 1400px){.one-1400>*{width:100%}.two-1400>*{width:50%}.three-1400>*{width:33.33333%}.four-1400>*{width:25%}.five-1400>*{width:20%}.six-1400>*{width:16.66666%}.seven-1400>*{width:14.28571%}.eight-1400>*{width:12.5%}.nine-1400>*{width:11.11111%}.ten-1400>*{width:10%}.eleven-1400>*{width:9.09091%}.twelve-1400>*{width:8.33333%}}@media all and (min-width: 1500px){.one-1500>*{width:100%}.two-1500>*{width:50%}.three-1500>*{width:33.33333%}.four-1500>*{width:25%}.five-1500>*{width:20%}.six-1500>*{width:16.66666%}.seven-1500>*{width:14.28571%}.eight-1500>*{width:12.5%}.nine-1500>*{width:11.11111%}.ten-1500>*{width:10%}.eleven-1500>*{width:9.09091%}.twelve-1500>*{width:8.33333%}}@media all and (min-width: 1600px){.one-1600>*{width:100%}.two-1600>*{width:50%}.three-1600>*{width:33.33333%}.four-1600>*{width:25%}.five-1600>*{width:20%}.six-1600>*{width:16.66666%}.seven-1600>*{width:14.28571%}.eight-1600>*{width:12.5%}.nine-1600>*{width:11.11111%}.ten-1600>*{width:10%}.eleven-1600>*{width:9.09091%}.twelve-1600>*{width:8.33333%}}@media all and (min-width: 1700px){.one-1700>*{width:100%}.two-1700>*{width:50%}.three-1700>*{width:33.33333%}.four-1700>*{width:25%}.five-1700>*{width:20%}.six-1700>*{width:16.66666%}.seven-1700>*{width:14.28571%}.eight-1700>*{width:12.5%}.nine-1700>*{width:11.11111%}.ten-1700>*{width:10%}.eleven-1700>*{width:9.09091%}.twelve-1700>*{width:8.33333%}}@media all and (min-width: 1800px){.one-1800>*{width:100%}.two-1800>*{width:50%}.three-1800>*{width:33.33333%}.four-1800>*{width:25%}.five-1800>*{width:20%}.six-1800>*{width:16.66666%}.seven-1800>*{width:14.28571%}.eight-1800>*{width:12.5%}.nine-1800>*{width:11.11111%}.ten-1800>*{width:10%}.eleven-1800>*{width:9.09091%}.twelve-1800>*{width:8.33333%}}@media all and (min-width: 1900px){.one-1900>*{width:100%}.two-1900>*{width:50%}.three-1900>*{width:33.33333%}.four-1900>*{width:25%}.five-1900>*{width:20%}.six-1900>*{width:16.66666%}.seven-1900>*{width:14.28571%}.eight-1900>*{width:12.5%}.nine-1900>*{width:11.11111%}.ten-1900>*{width:10%}.eleven-1900>*{width:9.09091%}.twelve-1900>*{width:8.33333%}}@media all and (min-width: 2000px){.one-2000>*{width:100%}.two-2000>*{width:50%}.three-2000>*{width:33.33333%}.four-2000>*{width:25%}.five-2000>*{width:20%}.six-2000>*{width:16.66666%}.seven-2000>*{width:14.28571%}.eight-2000>*{width:12.5%}.nine-2000>*{width:11.11111%}.ten-2000>*{width:10%}.eleven-2000>*{width:9.09091%}.twelve-2000>*{width:8.33333%}}.full{width:100%}.half{width:50%}.third{width:33.33333%}.two-third{width:66.66666%}.fourth{width:25%}.three-fourth{width:75%}.fifth{width:20%}.two-fifth{width:40%}.three-fifth{width:60%}.four-fifth{width:80%}.sixth{width:16.66666%}.none{display:none}@media all and (min-width: 500px){.full-500{width:100%;display:block}.half-500{width:50%;display:block}.third-500{width:33.33333%;display:block}.two-third-500{width:66.66666%;display:block}.fourth-500{width:25%;display:block}.three-fourth-500{width:75%;display:block}.fifth-500{width:20%;display:block}.two-fifth-500{width:40%;display:block}.three-fifth-500{width:60%;display:block}.four-fifth-500{width:80%;display:block}.sixth-500{width:16.66666%;display:block}}@media all and (min-width: 600px){.full-600{width:100%;display:block}.half-600{width:50%;display:block}.third-600{width:33.33333%;display:block}.two-third-600{width:66.66666%;display:block}.fourth-600{width:25%;display:block}.three-fourth-600{width:75%;display:block}.fifth-600{width:20%;display:block}.two-fifth-600{width:40%;display:block}.three-fifth-600{width:60%;display:block}.four-fifth-600{width:80%;display:block}.sixth-600{width:16.66666%;display:block}}@media all and (min-width: 700px){.full-700{width:100%;display:block}.half-700{width:50%;display:block}.third-700{width:33.33333%;display:block}.two-third-700{width:66.66666%;display:block}.fourth-700{width:25%;display:block}.three-fourth-700{width:75%;display:block}.fifth-700{width:20%;display:block}.two-fifth-700{width:40%;display:block}.three-fifth-700{width:60%;display:block}.four-fifth-700{width:80%;display:block}.sixth-700{width:16.66666%;display:block}}@media all and (min-width: 800px){.full-800{width:100%;display:block}.half-800{width:50%;display:block}.third-800{width:33.33333%;display:block}.two-third-800{width:66.66666%;display:block}.fourth-800{width:25%;display:block}.three-fourth-800{width:75%;display:block}.fifth-800{width:20%;display:block}.two-fifth-800{width:40%;display:block}.three-fifth-800{width:60%;display:block}.four-fifth-800{width:80%;display:block}.sixth-800{width:16.66666%;display:block}}@media all and (min-width: 900px){.full-900{width:100%;display:block}.half-900{width:50%;display:block}.third-900{width:33.33333%;display:block}.two-third-900{width:66.66666%;display:block}.fourth-900{width:25%;display:block}.three-fourth-900{width:75%;display:block}.fifth-900{width:20%;display:block}.two-fifth-900{width:40%;display:block}.three-fifth-900{width:60%;display:block}.four-fifth-900{width:80%;display:block}.sixth-900{width:16.66666%;display:block}}@media all and (min-width: 1000px){.full-1000{width:100%;display:block}.half-1000{width:50%;display:block}.third-1000{width:33.33333%;display:block}.two-third-1000{width:66.66666%;display:block}.fourth-1000{width:25%;display:block}.three-fourth-1000{width:75%;display:block}.fifth-1000{width:20%;display:block}.two-fifth-1000{width:40%;display:block}.three-fifth-1000{width:60%;display:block}.four-fifth-1000{width:80%;display:block}.sixth-1000{width:16.66666%;display:block}}@media all and (min-width: 1100px){.full-1100{width:100%;display:block}.half-1100{width:50%;display:block}.third-1100{width:33.33333%;display:block}.two-third-1100{width:66.66666%;display:block}.fourth-1100{width:25%;display:block}.three-fourth-1100{width:75%;display:block}.fifth-1100{width:20%;display:block}.two-fifth-1100{width:40%;display:block}.three-fifth-1100{width:60%;display:block}.four-fifth-1100{width:80%;display:block}.sixth-1100{width:16.66666%;display:block}}@media all and (min-width: 1200px){.full-1200{width:100%;display:block}.half-1200{width:50%;display:block}.third-1200{width:33.33333%;display:block}.two-third-1200{width:66.66666%;display:block}.fourth-1200{width:25%;display:block}.three-fourth-1200{width:75%;display:block}.fifth-1200{width:20%;display:block}.two-fifth-1200{width:40%;display:block}.three-fifth-1200{width:60%;display:block}.four-fifth-1200{width:80%;display:block}.sixth-1200{width:16.66666%;display:block}}@media all and (min-width: 1300px){.full-1300{width:100%;display:block}.half-1300{width:50%;display:block}.third-1300{width:33.33333%;display:block}.two-third-1300{width:66.66666%;display:block}.fourth-1300{width:25%;display:block}.three-fourth-1300{width:75%;display:block}.fifth-1300{width:20%;display:block}.two-fifth-1300{width:40%;display:block}.three-fifth-1300{width:60%;display:block}.four-fifth-1300{width:80%;display:block}.sixth-1300{width:16.66666%;display:block}}@media all and (min-width: 1400px){.full-1400{width:100%;display:block}.half-1400{width:50%;display:block}.third-1400{width:33.33333%;display:block}.two-third-1400{width:66.66666%;display:block}.fourth-1400{width:25%;display:block}.three-fourth-1400{width:75%;display:block}.fifth-1400{width:20%;display:block}.two-fifth-1400{width:40%;display:block}.three-fifth-1400{width:60%;display:block}.four-fifth-1400{width:80%;display:block}.sixth-1400{width:16.66666%;display:block}}@media all and (min-width: 1500px){.full-1500{width:100%;display:block}.half-1500{width:50%;display:block}.third-1500{width:33.33333%;display:block}.two-third-1500{width:66.66666%;display:block}.fourth-1500{width:25%;display:block}.three-fourth-1500{width:75%;display:block}.fifth-1500{width:20%;display:block}.two-fifth-1500{width:40%;display:block}.three-fifth-1500{width:60%;display:block}.four-fifth-1500{width:80%;display:block}.sixth-1500{width:16.66666%;display:block}}@media all and (min-width: 1600px){.full-1600{width:100%;display:block}.half-1600{width:50%;display:block}.third-1600{width:33.33333%;display:block}.two-third-1600{width:66.66666%;display:block}.fourth-1600{width:25%;display:block}.three-fourth-1600{width:75%;display:block}.fifth-1600{width:20%;display:block}.two-fifth-1600{width:40%;display:block}.three-fifth-1600{width:60%;display:block}.four-fifth-1600{width:80%;display:block}.sixth-1600{width:16.66666%;display:block}}@media all and (min-width: 1700px){.full-1700{width:100%;display:block}.half-1700{width:50%;display:block}.third-1700{width:33.33333%;display:block}.two-third-1700{width:66.66666%;display:block}.fourth-1700{width:25%;display:block}.three-fourth-1700{width:75%;display:block}.fifth-1700{width:20%;display:block}.two-fifth-1700{width:40%;display:block}.three-fifth-1700{width:60%;display:block}.four-fifth-1700{width:80%;display:block}.sixth-1700{width:16.66666%;display:block}}@media all and (min-width: 1800px){.full-1800{width:100%;display:block}.half-1800{width:50%;display:block}.third-1800{width:33.33333%;display:block}.two-third-1800{width:66.66666%;display:block}.fourth-1800{width:25%;display:block}.three-fourth-1800{width:75%;display:block}.fifth-1800{width:20%;display:block}.two-fifth-1800{width:40%;display:block}.three-fifth-1800{width:60%;display:block}.four-fifth-1800{width:80%;display:block}.sixth-1800{width:16.66666%;display:block}}@media all and (min-width: 1900px){.full-1900{width:100%;display:block}.half-1900{width:50%;display:block}.third-1900{width:33.33333%;display:block}.two-third-1900{width:66.66666%;display:block}.fourth-1900{width:25%;display:block}.three-fourth-1900{width:75%;display:block}.fifth-1900{width:20%;display:block}.two-fifth-1900{width:40%;display:block}.three-fifth-1900{width:60%;display:block}.four-fifth-1900{width:80%;display:block}.sixth-1900{width:16.66666%;display:block}}@media all and (min-width: 2000px){.full-2000{width:100%;display:block}.half-2000{width:50%;display:block}.third-2000{width:33.33333%;display:block}.two-third-2000{width:66.66666%;display:block}.fourth-2000{width:25%;display:block}.three-fourth-2000{width:75%;display:block}.fifth-2000{width:20%;display:block}.two-fifth-2000{width:40%;display:block}.three-fifth-2000{width:60%;display:block}.four-fifth-2000{width:80%;display:block}.sixth-2000{width:16.66666%;display:block}}@media all and (min-width: 500px){.none-500{display:none}}@media all and (min-width: 600px){.none-600{display:none}}@media all and (min-width: 700px){.none-700{display:none}}@media all and (min-width: 800px){.none-800{display:none}}@media all and (min-width: 900px){.none-900{display:none}}@media all and (min-width: 1000px){.none-1000{display:none}}@media all and (min-width: 1100px){.none-1100{display:none}}@media all and (min-width: 1200px){.none-1200{display:none}}@media all and (min-width: 1300px){.none-1300{display:none}}@media all and (min-width: 1400px){.none-1400{display:none}}@media all and (min-width: 1500px){.none-1500{display:none}}@media all and (min-width: 1600px){.none-1600{display:none}}@media all and (min-width: 1700px){.none-1700{display:none}}@media all and (min-width: 1800px){.none-1800{display:none}}@media all and (min-width: 1900px){.none-1900{display:none}}@media all and (min-width: 2000px){.none-2000{display:none}}.off-none{margin-left:0}.off-half{margin-left:50%}.off-third{margin-left:33.33333%}.off-two-third{margin-left:66.66666%}.off-fourth{margin-left:25%}.off-three-fourth{margin-left:75%}.off-fifth{margin-left:20%}.off-two-fifth{margin-left:40%}.off-three-fifth{margin-left:60%}.off-four-fifth{margin-left:80%}.off-sixth{margin-left:16.66666%}@media all and (min-width: 500px){.off-none-500{margin-left:0}.off-half-500{margin-left:50%}.off-third-500{margin-left:33.33333%}.off-two-third-500{margin-left:66.66666%}.off-fourth-500{margin-left:25%}.off-three-fourth-500{margin-left:75%}.off-fifth-500{margin-left:20%}.off-two-fifth-500{margin-left:40%}.off-three-fifth-500{margin-left:60%}.off-four-fifth-500{margin-left:80%}.off-sixth-500{margin-left:16.66666%}}@media all and (min-width: 600px){.off-none-600{margin-left:0}.off-half-600{margin-left:50%}.off-third-600{margin-left:33.33333%}.off-two-third-600{margin-left:66.66666%}.off-fourth-600{margin-left:25%}.off-three-fourth-600{margin-left:75%}.off-fifth-600{margin-left:20%}.off-two-fifth-600{margin-left:40%}.off-three-fifth-600{margin-left:60%}.off-four-fifth-600{margin-left:80%}.off-sixth-600{margin-left:16.66666%}}@media all and (min-width: 700px){.off-none-700{margin-left:0}.off-half-700{margin-left:50%}.off-third-700{margin-left:33.33333%}.off-two-third-700{margin-left:66.66666%}.off-fourth-700{margin-left:25%}.off-three-fourth-700{margin-left:75%}.off-fifth-700{margin-left:20%}.off-two-fifth-700{margin-left:40%}.off-three-fifth-700{margin-left:60%}.off-four-fifth-700{margin-left:80%}.off-sixth-700{margin-left:16.66666%}}@media all and (min-width: 800px){.off-none-800{margin-left:0}.off-half-800{margin-left:50%}.off-third-800{margin-left:33.33333%}.off-two-third-800{margin-left:66.66666%}.off-fourth-800{margin-left:25%}.off-three-fourth-800{margin-left:75%}.off-fifth-800{margin-left:20%}.off-two-fifth-800{margin-left:40%}.off-three-fifth-800{margin-left:60%}.off-four-fifth-800{margin-left:80%}.off-sixth-800{margin-left:16.66666%}}@media all and (min-width: 900px){.off-none-900{margin-left:0}.off-half-900{margin-left:50%}.off-third-900{margin-left:33.33333%}.off-two-third-900{margin-left:66.66666%}.off-fourth-900{margin-left:25%}.off-three-fourth-900{margin-left:75%}.off-fifth-900{margin-left:20%}.off-two-fifth-900{margin-left:40%}.off-three-fifth-900{margin-left:60%}.off-four-fifth-900{margin-left:80%}.off-sixth-900{margin-left:16.66666%}}@media all and (min-width: 1000px){.off-none-1000{margin-left:0}.off-half-1000{margin-left:50%}.off-third-1000{margin-left:33.33333%}.off-two-third-1000{margin-left:66.66666%}.off-fourth-1000{margin-left:25%}.off-three-fourth-1000{margin-left:75%}.off-fifth-1000{margin-left:20%}.off-two-fifth-1000{margin-left:40%}.off-three-fifth-1000{margin-left:60%}.off-four-fifth-1000{margin-left:80%}.off-sixth-1000{margin-left:16.66666%}}@media all and (min-width: 1100px){.off-none-1100{margin-left:0}.off-half-1100{margin-left:50%}.off-third-1100{margin-left:33.33333%}.off-two-third-1100{margin-left:66.66666%}.off-fourth-1100{margin-left:25%}.off-three-fourth-1100{margin-left:75%}.off-fifth-1100{margin-left:20%}.off-two-fifth-1100{margin-left:40%}.off-three-fifth-1100{margin-left:60%}.off-four-fifth-1100{margin-left:80%}.off-sixth-1100{margin-left:16.66666%}}@media all and (min-width: 1200px){.off-none-1200{margin-left:0}.off-half-1200{margin-left:50%}.off-third-1200{margin-left:33.33333%}.off-two-third-1200{margin-left:66.66666%}.off-fourth-1200{margin-left:25%}.off-three-fourth-1200{margin-left:75%}.off-fifth-1200{margin-left:20%}.off-two-fifth-1200{margin-left:40%}.off-three-fifth-1200{margin-left:60%}.off-four-fifth-1200{margin-left:80%}.off-sixth-1200{margin-left:16.66666%}}@media all and (min-width: 1300px){.off-none-1300{margin-left:0}.off-half-1300{margin-left:50%}.off-third-1300{margin-left:33.33333%}.off-two-third-1300{margin-left:66.66666%}.off-fourth-1300{margin-left:25%}.off-three-fourth-1300{margin-left:75%}.off-fifth-1300{margin-left:20%}.off-two-fifth-1300{margin-left:40%}.off-three-fifth-1300{margin-left:60%}.off-four-fifth-1300{margin-left:80%}.off-sixth-1300{margin-left:16.66666%}}@media all and (min-width: 1400px){.off-none-1400{margin-left:0}.off-half-1400{margin-left:50%}.off-third-1400{margin-left:33.33333%}.off-two-third-1400{margin-left:66.66666%}.off-fourth-1400{margin-left:25%}.off-three-fourth-1400{margin-left:75%}.off-fifth-1400{margin-left:20%}.off-two-fifth-1400{margin-left:40%}.off-three-fifth-1400{margin-left:60%}.off-four-fifth-1400{margin-left:80%}.off-sixth-1400{margin-left:16.66666%}}@media all and (min-width: 1500px){.off-none-1500{margin-left:0}.off-half-1500{margin-left:50%}.off-third-1500{margin-left:33.33333%}.off-two-third-1500{margin-left:66.66666%}.off-fourth-1500{margin-left:25%}.off-three-fourth-1500{margin-left:75%}.off-fifth-1500{margin-left:20%}.off-two-fifth-1500{margin-left:40%}.off-three-fifth-1500{margin-left:60%}.off-four-fifth-1500{margin-left:80%}.off-sixth-1500{margin-left:16.66666%}}@media all and (min-width: 1600px){.off-none-1600{margin-left:0}.off-half-1600{margin-left:50%}.off-third-1600{margin-left:33.33333%}.off-two-third-1600{margin-left:66.66666%}.off-fourth-1600{margin-left:25%}.off-three-fourth-1600{margin-left:75%}.off-fifth-1600{margin-left:20%}.off-two-fifth-1600{margin-left:40%}.off-three-fifth-1600{margin-left:60%}.off-four-fifth-1600{margin-left:80%}.off-sixth-1600{margin-left:16.66666%}}@media all and (min-width: 1700px){.off-none-1700{margin-left:0}.off-half-1700{margin-left:50%}.off-third-1700{margin-left:33.33333%}.off-two-third-1700{margin-left:66.66666%}.off-fourth-1700{margin-left:25%}.off-three-fourth-1700{margin-left:75%}.off-fifth-1700{margin-left:20%}.off-two-fifth-1700{margin-left:40%}.off-three-fifth-1700{margin-left:60%}.off-four-fifth-1700{margin-left:80%}.off-sixth-1700{margin-left:16.66666%}}@media all and (min-width: 1800px){.off-none-1800{margin-left:0}.off-half-1800{margin-left:50%}.off-third-1800{margin-left:33.33333%}.off-two-third-1800{margin-left:66.66666%}.off-fourth-1800{margin-left:25%}.off-three-fourth-1800{margin-left:75%}.off-fifth-1800{margin-left:20%}.off-two-fifth-1800{margin-left:40%}.off-three-fifth-1800{margin-left:60%}.off-four-fifth-1800{margin-left:80%}.off-sixth-1800{margin-left:16.66666%}}@media all and (min-width: 1900px){.off-none-1900{margin-left:0}.off-half-1900{margin-left:50%}.off-third-1900{margin-left:33.33333%}.off-two-third-1900{margin-left:66.66666%}.off-fourth-1900{margin-left:25%}.off-three-fourth-1900{margin-left:75%}.off-fifth-1900{margin-left:20%}.off-two-fifth-1900{margin-left:40%}.off-three-fifth-1900{margin-left:60%}.off-four-fifth-1900{margin-left:80%}.off-sixth-1900{margin-left:16.66666%}}@media all and (min-width: 2000px){.off-none-2000{margin-left:0}.off-half-2000{margin-left:50%}.off-third-2000{margin-left:33.33333%}.off-two-third-2000{margin-left:66.66666%}.off-fourth-2000{margin-left:25%}.off-three-fourth-2000{margin-left:75%}.off-fifth-2000{margin-left:20%}.off-two-fifth-2000{margin-left:40%}.off-three-fifth-2000{margin-left:60%}.off-four-fifth-2000{margin-left:80%}.off-sixth-2000{margin-left:16.66666%}}nav{position:fixed;top:0;left:0;right:0;height:3em;padding:0 .6em;background:#fff;box-shadow:0 0 .2em rgba(170,170,170,.2);z-index:10000;transition:all .3s;transform-style:preserve-3d}nav .brand,nav .menu,nav .burger{float:right;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}nav .brand{font-weight:700;float:left;padding:0 .6em;max-width:50%;white-space:nowrap;color:inherit}nav .brand *{vertical-align:middle}nav .logo{height:2em;margin-right:.3em}nav .select::after{height:calc(100% - 1px);padding:0;line-height:2.4em}nav .menu>*{margin-right:.6em}nav .burger{display:none}@media all and (max-width: 60em){nav .burger{display:inline-block;cursor:pointer;bottom:-1000em;margin:0;-webkit-tap-highlight-color:transparent}nav .burger~.menu,nav .show:checked~.burger{position:fixed;min-height:100%;top:0;right:0;bottom:-1000em;margin:0;background:#fff;transition:all .5s ease;transform:none}nav .burger~.menu{z-index:11}nav .show:checked~.burger{color:transparent;width:100%;border-radius:0;background:rgba(17,17,17,.2);transition:all .5s ease}nav .show~.menu{width:70%;max-width:300px;transform-origin:center right;transition:all .25s ease;transform:scaleX(0)}nav .show~.menu>*{transform:translateX(100%);transition:all 0s ease .5s}nav .show:checked~.menu>*:nth-child(1){transition:all .5s cubic-bezier(0.645, 0.045, 0.355, 1) 0s}nav .show:checked~.menu>*:nth-child(2){transition:all .5s cubic-bezier(0.645, 0.045, 0.355, 1) .1s}nav .show:checked~.menu>*:nth-child(3){transition:all .5s cubic-bezier(0.645, 0.045, 0.355, 1) .2s}nav .show:checked~.menu>*:nth-child(4){transition:all .5s cubic-bezier(0.645, 0.045, 0.355, 1) .3s}nav .show:checked~.menu>*:nth-child(5){transition:all .5s cubic-bezier(0.645, 0.045, 0.355, 1) .4s}nav .show:checked~.menu>*:nth-child(6){transition:all .5s cubic-bezier(0.645, 0.045, 0.355, 1) .5s}nav .show:checked~.menu{transform:scaleX(1)}nav .show:checked~.menu>*{transform:translateX(0);transition:all .5s ease-in-out .6s}nav .burger~.menu>*{display:block;margin:.3em;text-align:left;max-width:calc(100% - 0.6em)}nav .burger~.menu>a{padding:.3em .9em}}.stack,.stack .toggle{margin-top:0;margin-bottom:0;display:block;width:100%;text-align:left;border-radius:0}.stack:first-child,.stack:first-child .toggle{border-top-left-radius:.2em;border-top-right-radius:.2em}.stack:last-child,.stack:last-child .toggle{border-bottom-left-radius:.2em;border-bottom-right-radius:.2em}input.stack,textarea.stack,select.stack{transition:border-bottom 0 ease 0;border-bottom-width:0}input.stack:last-child,textarea.stack:last-child,select.stack:last-child{border-bottom-width:1px}input.stack:focus+input,input.stack:focus+textarea,input.stack:focus+select,textarea.stack:focus+input,textarea.stack:focus+textarea,textarea.stack:focus+select,select.stack:focus+input,select.stack:focus+textarea,select.stack:focus+select{border-top-color:#0074d9}.modal .overlay~*,.card{position:relative;box-shadow:none;border-radius:.2em;border:1px solid #aaa;overflow:hidden;text-align:left;background:#fff;margin-bottom:.6em;padding:0;transition:all .3s ease}.modal .overlay~.hidden,.hidden.card,.modal .overlay~:checked+*,.modal .overlay:checked+*,:checked+.card{font-size:0;padding:0;margin:0;border:0}.modal .overlay~*>*,.card>*{max-width:100%;display:block}.modal .overlay~*>*:last-child,.card>*:last-child{margin-bottom:0}.modal .overlay~* header,.card header,.modal .overlay~* section,.card section,.modal .overlay~*>p,.card>p{padding:.6em .8em}.modal .overlay~* section,.card section{padding:.6em .8em 0}.modal .overlay~* hr,.card hr{border:none;height:1px;background-color:#aaa}.modal .overlay~* header,.card header{font-weight:bold;position:relative;border-bottom:1px solid #aaa}.modal .overlay~* header h1,.card header h1,.modal .overlay~* header h2,.card header h2,.modal .overlay~* header h3,.card header h3,.modal .overlay~* header h4,.card header h4,.modal .overlay~* header h5,.card header h5,.modal .overlay~* header h6,.card header h6{padding:0;margin:0 2em 0 0;line-height:1;display:inline-block;vertical-align:text-bottom}.modal .overlay~* header:last-child,.card header:last-child{border-bottom:0}.modal .overlay~* footer,.card footer{padding:.8em}.modal .overlay~* p,.card p{margin:.3em 0}.modal .overlay~* p:first-child,.card p:first-child{margin-top:0}.modal .overlay~* p:last-child,.card p:last-child{margin-bottom:0}.modal .overlay~*>p,.card>p{margin:0;padding-right:2.5em}.modal .overlay~* .close,.card .close{position:absolute;top:.4em;right:.3em;font-size:1.2em;padding:0 .5em;cursor:pointer;width:auto}.modal .overlay~* .close:hover,.card .close:hover{color:#ff4136}.modal .overlay~* h1+.close,.card h1+.close{margin:.2em}.modal .overlay~* h2+.close,.card h2+.close{margin:.1em}.modal .overlay~* .dangerous,.card .dangerous{background:#ff4136;float:right}.modal{text-align:center}.modal>input{display:none}.modal>input~*{opacity:0;max-height:0;overflow:hidden}.modal .overlay{top:0;left:0;bottom:0;right:0;position:fixed;margin:0;border-radius:0;background:rgba(17,17,17,.2);transition:all .3s;z-index:100000}.modal .overlay:before,.modal .overlay:after{display:none}.modal .overlay~*{border:0;position:fixed;top:50%;left:50%;transform:translateX(-50%) translateY(-50%) scale(0.2, 0.2);z-index:1000000;transition:all .3s}.modal>input:checked~*{display:block;opacity:1;max-height:10000px;transition:all .3s}.modal>input:checked~.overlay~*{max-height:90%;overflow:auto;-webkit-transform:translateX(-50%) translateY(-50%) scale(1, 1);transform:translateX(-50%) translateY(-50%) scale(1, 1)}@media(max-width: 60em){.modal .overlay~*{min-width:90%}}.dropimage{position:relative;display:block;padding:0;padding-bottom:56.25%;overflow:hidden;cursor:pointer;border:0;margin:.3em 0;border-radius:.2em;background-color:#ddd;background-size:cover;background-position:center center;background-image:url(${p})}.dropimage input{left:0;width:100%;height:100%;border:0;margin:0;padding:0;opacity:0;cursor:pointer;position:absolute}.tabs{position:relative;overflow:hidden}.tabs>label img{float:left;margin-left:.6em}.tabs>.row{width:calc(100% + 1.2em);display:table;table-layout:fixed;position:relative;padding-left:0;transition:all .3s;border-spacing:0;margin:0}.tabs>.row:before,.tabs>.row:after{display:none}.tabs>.row>*,.tabs>.row img{display:table-cell;vertical-align:top;margin:0;width:100%}.tabs>input{display:none}.tabs>input+*{width:100%}.tabs>input+label{width:auto}.two.tabs>.row{width:200%;left:-100%}.two.tabs>input:nth-of-type(1):checked~.row{margin-left:100%}.two.tabs>label img{width:48%;margin:4% 0 4% 4%}.three.tabs>.row{width:300%;left:-200%}.three.tabs>input:nth-of-type(1):checked~.row{margin-left:200%}.three.tabs>input:nth-of-type(2):checked~.row{margin-left:100%}.three.tabs>label img{width:30%;margin:5% 0 5% 5%}.four.tabs>.row{width:400%;left:-300%}.four.tabs>input:nth-of-type(1):checked~.row{margin-left:300%}.four.tabs>input:nth-of-type(2):checked~.row{margin-left:200%}.four.tabs>input:nth-of-type(3):checked~.row{margin-left:100%}.four.tabs>label img{width:22%;margin:4% 0 4% 4%}.five.tabs>.row{width:500%;left:-400%}.five.tabs>input:nth-of-type(1):checked~.row{margin-left:400%}.five.tabs>input:nth-of-type(2):checked~.row{margin-left:300%}.five.tabs>input:nth-of-type(3):checked~.row{margin-left:200%}.five.tabs>input:nth-of-type(4):checked~.row{margin-left:100%}.five.tabs>label img{width:18%;margin:2% 0 2% 2%}.six.tabs>.row{width:600%;left:-500%}.six.tabs>input:nth-of-type(1):checked~.row{margin-left:500%}.six.tabs>input:nth-of-type(2):checked~.row{margin-left:400%}.six.tabs>input:nth-of-type(3):checked~.row{margin-left:300%}.six.tabs>input:nth-of-type(4):checked~.row{margin-left:200%}.six.tabs>input:nth-of-type(5):checked~.row{margin-left:100%}.six.tabs>label img{width:12%;margin:1% 0 1% 1%}.tabs>label:first-of-type img{margin-left:0}[data-tooltip]{position:relative}[data-tooltip]:after,[data-tooltip]:before{position:absolute;z-index:10;opacity:0;border-width:0;height:0;padding:0;overflow:hidden;transition:opacity .6s ease,height 0s ease .6s;top:calc(100% - 6px);left:0;margin-top:12px}[data-tooltip]:after{margin-left:0;font-size:.8em;background:#111;content:attr(data-tooltip);white-space:nowrap}[data-tooltip]:before{content:"";width:0;height:0;border-width:0;border-style:solid;border-color:transparent transparent #111;margin-top:0;left:10px}[data-tooltip]:hover:after,[data-tooltip]:focus:after,[data-tooltip]:hover:before,[data-tooltip]:focus:before{opacity:1;border-width:6px;height:auto}[data-tooltip]:hover:after,[data-tooltip]:focus:after{padding:.45em .9em}.tooltip-top:after,.tooltip-top:before{top:auto;bottom:calc(100% - 6px);left:0;margin-bottom:12px}.tooltip-top:before{border-color:#111 transparent transparent;margin-bottom:0;left:10px}.tooltip-right:after,.tooltip-right:before{left:100%;margin-left:6px;margin-top:0;top:0}.tooltip-right:before{border-color:transparent #111 transparent transparent;margin-left:-6px;left:100%;top:7px}.tooltip-left:after,.tooltip-left:before{right:100%;margin-right:6px;left:auto;margin-top:0;top:0}.tooltip-left:before{border-color:transparent transparent transparent #111;margin-right:-6px;right:100%;top:7px}\n`,""]);const f=d},2282:(e,t,n)=>{"use strict";n.r(t),n.d(t,{Tokenizer:()=>c,UniversalSentenceEncoder:()=>v,load:()=>w,loadQnA:()=>b,loadTokenizer:()=>d,version:()=>p});var r=n(1592),s=n(7164);function a(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function i(e,t){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&a[0]?r.return:a[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,a[1])).done)return s;switch(r=0,s&&(a=[2&a[0],s.value]),a[0]){case 0:case 1:s=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(s=(s=i.trys).length>0&&s[s.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!s||a[1]>s[0]&&a[1]<s[3])){i.label=a[1];break}if(6===a[0]&&i.label<s[1]){i.label=s[1],s=a;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(a);break}s[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i)}catch(e){a=[6,e],r=0}finally{n=s=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}var o=function(e){for(var t=[],n=0,r=e;n<r.length;n++){var s=r[n];t.push(s)}return t},l=function(){this.parent=null,this.children={},this.end=!1,this.word=[[],0,0]},u=function(){function e(){this.root=new l}return e.prototype.insert=function(e,t,n){for(var r=this.root,s=o(e),a=0;a<s.length;a++)r.children[s[a]]||(r.children[s[a]]=new l,r.children[s[a]].parent=r,r.children[s[a]].word[0]=r.word[0].concat(s[a])),r=r.children[s[a]],a===s.length-1&&(r.end=!0,r.word[1]=t,r.word[2]=n)},e.prototype.commonPrefixSearch=function(e){for(var t=[],n=this.root.children[e[0]],r=0;r<e.length&&n;r++)n.end&&t.push(n.word),n=n.children[e[r+1]];return t.length||t.push([[e[0]],0,0]),t},e}(),c=function(){function e(e,t){void 0===t&&(t=6),this.vocabulary=e,this.reservedSymbolsCount=t,this.trie=new u;for(var n=this.reservedSymbolsCount;n<this.vocabulary.length;n++)this.trie.insert(this.vocabulary[n][0],this.vocabulary[n][1],n)}return e.prototype.encode=function(e){var t=[],n=[],r=[];e=function(e){var t=e.normalize("NFKC");return t.length>0?"▁"+t.replace(/ /g,"▁"):t}(e);for(var s=o(e),a=0;a<=s.length;a++)t.push({}),n.push(0),r.push(0);for(a=0;a<s.length;a++)for(var i=this.trie.commonPrefixSearch(s.slice(a)),l=0;l<i.length;l++){var u=i[l],c={key:u[0],score:u[1],index:u[2]};null==t[a+(d=u[0].length)][a]&&(t[a+d][a]=[]),t[a+d][a].push(c)}for(var d=0;d<=s.length;d++)for(var h in t[d]){var p=t[d][h];for(l=0;l<p.length;l++){var f=p[l],m=f.score+r[d-f.key.length];(0===r[d]||m>=r[d])&&(r[d]=m,n[d]=p[l].index)}}for(var g=[],b=n.length-1;b>0;)g.push(n[b]),b-=this.vocabulary[n[b]][0].length;var y=[],w=!1;for(a=0;a<g.length;a++){var v=g[a];w&&0===v||y.push(v),w=0===v}return y.reverse()},e}();function d(e){return a(this,void 0,void 0,(function(){var t;return i(this,(function(n){switch(n.label){case 0:return[4,h(e)];case 1:return t=n.sent(),[2,new c(t)]}}))}))}function h(e){return a(this,void 0,void 0,(function(){return i(this,(function(t){switch(t.label){case 0:return[4,r.ZSL.fetch(e)];case 1:return[2,t.sent().json()]}}))}))}var p="1.3.3",f="https://tfhub.dev/google/tfjs-model/universal-sentence-encoder-qa-ondevice/1",m=[0,1,2],g=192;function b(){return a(this,void 0,void 0,(function(){var e;return i(this,(function(t){switch(t.label){case 0:return[4,(e=new y).load()];case 1:return t.sent(),[2,e]}}))}))}var y=function(){function e(){}return e.prototype.loadModel=function(){return a(this,void 0,void 0,(function(){return i(this,(function(e){return[2,(0,s.ox)(f,{fromTFHub:!0})]}))}))},e.prototype.load=function(){return a(this,void 0,void 0,(function(){var e,t,n;return i(this,(function(r){switch(r.label){case 0:return[4,Promise.all([this.loadModel(),h(f+"/vocab.json?tfjs-format=file")])];case 1:return e=r.sent(),t=e[0],n=e[1],this.model=t,this.tokenizer=new c(n,3),[2]}}))}))},e.prototype.embed=function(e){var t=this,n=(0,r.DZQ)((function(){var n=t.tokenizeStrings(e.queries,g),r=t.tokenizeStrings(e.responses,g);if(null!=e.contexts&&e.contexts.length!==e.responses.length)throw new Error("The length of response strings and context strings need to match.");var s=e.contexts||[];null==e.contexts&&(s.length=e.responses.length,s.fill(""));var a=t.tokenizeStrings(s,g),i={};return i.input_inp_text=n,i.input_res_text=r,i.input_res_context=a,t.model.execute(i,["Final/EncodeQuery/mul","Final/EncodeResult/mul"])}));return{queryEmbedding:n[0],responseEmbedding:n[1]}},e.prototype.tokenizeStrings=function(e,t){var n=this,s=e.map((function(e){return n.shiftTokens(n.tokenizer.encode(e),g)}));return(0,r.KtR)(s,[e.length,g],"int32")},e.prototype.shiftTokens=function(e,t){e.unshift(1);for(var n=0;n<t;n++)n>=e.length?e[n]=2:m.includes(e[n])||(e[n]+=3);return e.slice(0,t)},e}();function w(e){return a(this,void 0,void 0,(function(){var t;return i(this,(function(n){switch(n.label){case 0:return[4,(t=new v).load(e)];case 1:return n.sent(),[2,t]}}))}))}var v=function(){function e(){}return e.prototype.loadModel=function(e){return a(this,void 0,void 0,(function(){return i(this,(function(t){return[2,e?(0,s.ox)(e):(0,s.ox)("https://tfhub.dev/tensorflow/tfjs-model/universal-sentence-encoder-lite/1/default/1",{fromTFHub:!0})]}))}))},e.prototype.load=function(e){return void 0===e&&(e={}),a(this,void 0,void 0,(function(){var t,n,r;return i(this,(function(s){switch(s.label){case 0:return[4,Promise.all([this.loadModel(e.modelUrl),h(e.vocabUrl||"https://storage.googleapis.com/tfjs-models/savedmodel/universal_sentence_encoder/vocab.json")])];case 1:return t=s.sent(),n=t[0],r=t[1],this.model=n,this.tokenizer=new c(r),[2]}}))}))},e.prototype.embed=function(e){return a(this,void 0,void 0,(function(){var t,n,s,a,o,l,u,c,d=this;return i(this,(function(i){switch(i.label){case 0:for("string"==typeof e&&(e=[e]),t=e.map((function(e){return d.tokenizer.encode(e)})),n=t.map((function(e,t){return e.map((function(e,n){return[t,n]}))})),s=[],a=0;a<n.length;a++)s=s.concat(n[a]);return o=(0,r.KtR)(s,[s.length,2],"int32"),l=(0,r.tGX)(r.ZSL.flatten(t),"int32"),u={indices:o,values:l},[4,this.model.executeAsync(u)];case 1:return c=i.sent(),o.dispose(),l.dispose(),[2,c]}}))}))},e}()},3132:(e,t,n)=>{"use strict";n.d(t,{C:()=>s});var r=n(1592);function s(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&r.ZSL.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}},3010:(e,t,n)=>{"use strict";n.r(t),n.d(t,{MathBackendCPU:()=>i,shared:()=>o,version_cpu:()=>l});var r=n(1592),s=n(3132);const a=r.kpo.whereImpl;class i extends r.uI_{nextDataId(){return i.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new r.GJx(this,(0,r.Hi9)())}write(e,t,n){this.firstUse&&(this.firstUse=!1,(0,r._K2)().get("IS_NODE")&&r.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&r.ZSL.isString(n[0])){const a=n.map((e=>r.ZSL.encodeString(e)));s=this.write(a,e,t)}else s=this.write(n,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return r.backend_util.mergeRealAndImagArrays(e,t)}return r.ZSL.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>r.ZSL.decodeString(e)));return(0,r.ra8)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,r.ra8)(e.shape,e.dtype,t)}makeOutput(e,t,n){return(0,r.Hi9)().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=r.ZSL.now();return e(),{kernelMs:r.ZSL.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){(0,s.C)([e],"where");const t=this.readSync(e.dataId);return a(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}i.nextDataId=0;var o=n(7530);const l="4.18.0";(0,r.gJX)("cpu",(()=>new i),1);var u=n(3064);const c=(0,u.v)(r.Pah,(e=>e>=0?e:Math.exp(e)-1)),d={kernelName:r.Pah,backendName:"cpu",kernelFunc:c};var h=n(3422);function p(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{alpha:o}=a;(0,s.C)([i],"leakyRelu");const l=r.ZSL.sizeFromShape(i.shape),u=n.data.get(i.dataId).values,c=r.ZSL.getTypedArrayFromDType("float32",l);for(let e=0;e<u.length;e++)c[e]=u[e]<0?o*u[e]:u[e];return n.makeTensorInfo(i.shape,"float32",c)}const f={kernelName:r.X0$,backendName:"cpu",kernelFunc:p};var m=n(3957);const g=(0,m.Z)(((e,t)=>e<0?t*e:e));function b(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;(0,s.C)([r,a],"prelu");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[l,u]=g(r.shape,a.shape,i,o,"float32");return n.makeTensorInfo(u,"float32",l)}const y={kernelName:r.Ncv,backendName:"cpu",kernelFunc:b},w=(0,u.v)(r.fUj,(e=>Math.max(0,e))),v={kernelName:r.fUj,backendName:"cpu",kernelFunc:w},x=(0,u.v)(r.P_L,(e=>Math.min(Math.max(0,e),6))),_={kernelName:r.P_L,backendName:"cpu",kernelFunc:x};var k=n(5834);function S(e,t,n,r,s){if("linear"===n)return(0,h.D)({inputs:{x:t},backend:e});if("relu"===n)return w({inputs:{x:t},backend:e});if("elu"===n)return c({inputs:{x:t},backend:e});if("relu6"===n)return x({inputs:{x:t},backend:e});if("prelu"===n)return b({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return p({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return(0,k.ry)({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}var T=n(161);function I(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{shape:i}=s,o=r.ZSL.sizeFromShape(a.shape),l=r.ZSL.inferFromImplicitShape(i,o),u=r.ZSL.sizeFromShape(l);r.ZSL.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);const c=n.data.get(a.dataId);if(null!=c.complexTensorInfos){const e=c.complexTensorInfos.real,t=c.complexTensorInfos.imag;e.shape=l,t.shape=l}return{dataId:a.dataId,shape:l,dtype:a.dtype}}const E={kernelName:r.R23,backendName:"cpu",kernelFunc:I};function A(e){const{inputs:t,backend:n,attrs:a}=e,{a:i,b:o}=t,{transposeA:l,transposeB:u}=a;(0,s.C)([i,o],"matMul");const c=i.shape.length,d=o.shape.length,h=l?i.shape[c-2]:i.shape[c-1],p=u?o.shape[d-1]:o.shape[d-2],f=l?i.shape[c-1]:i.shape[c-2],m=u?o.shape[d-2]:o.shape[d-1],g=i.shape.slice(0,-2),b=o.shape.slice(0,-2),y=r.ZSL.sizeFromShape(g),w=r.ZSL.sizeFromShape(b),v=r.ZEY.assertAndGetBroadcastShape(i.shape.slice(0,-2),o.shape.slice(0,-2)).concat([f,m]);r.ZSL.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${i.shape} and ${o.shape} and transposeA=${l} and transposeB=${u} must match.`));const x=u?[w,m,p]:[w,p,m],_=I({inputs:{x:i},backend:n,attrs:{shape:l?[y,h,f]:[y,f,h]}}),k=I({inputs:{x:o},backend:n,attrs:{shape:x}}),S=l?_.shape[1]:_.shape[2],T=l?_.shape[2]:_.shape[1],E=u?k.shape[1]:k.shape[2],A=Math.max(y,w),C=n.data.get(_.dataId).values,N=n.data.get(k.dataId).values,$=r.ZSL.computeStrides(_.shape),O=r.ZSL.computeStrides(k.shape),[D,F,R]=l?[$[0],1,$[1]]:[$[0],$[1],1],[M,L,P]=u?[1,O[1],O[0]]:[O[1],1,O[0]],z=T*E,B=(0,r.ra8)([A,T,E],_.dtype),V=B.values,U=n.blockSize;for(let e=0;e<A;e++){const t=e%y,n=e%w;for(let r=0;r<T;r+=U){const s=Math.min(r+U,T);for(let a=0;a<E;a+=U){const i=Math.min(a+U,E);for(let o=0;o<S;o+=U){const l=Math.min(o+U,S);for(let u=r;u<s;u++)for(let r=a;r<i;r++){let s=0;for(let e=o;e<l;e++)s+=C[t*D+u*F+e*R]*N[e*M+r*L+n*P];V[e*z+(u*E+r)]+=s}}}}}return n.disposeIntermediateTensorInfo(_),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(v,B.dtype,B.values)}const C={kernelName:r.jAQ,backendName:"cpu",kernelFunc:A},N={kernelName:r.Dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=A({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=(0,T.WQ)({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=S(n,h,c,o,d),m.push(h),h=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return h}};var $=n(574);const O=(0,u.v)(r.Vvy,(e=>Math.acos(e))),D={kernelName:r.Vvy,backendName:"cpu",kernelFunc:O},F=(0,u.v)(r.PH8,(e=>Math.acosh(e))),R={kernelName:r.PH8,backendName:"cpu",kernelFunc:F},M={kernelName:r.EkD,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;(0,s.C)(t,"addN");const i=a.map((e=>n.data.get(e.dataId).values)),o=(0,r.ra8)(a[0].shape,a[0].dtype),l=o.values;for(let e=0;e<a.length;e++){const t=i[e];for(let e=0;e<l.length;e++)l[e]+=t[e]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};var L=n(4425);const P={kernelName:r.u8Z,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o,keepDims:l}=a;(0,s.C)(i,"all");const u=r.ZSL.parseAxisParam(o,i.shape);let c=u;const d=r.backend_util.getAxesPermutation(c,i.shape.length);let h=i;null!=d&&(h=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:d}}),c=r.backend_util.getInnerMostAxes(c.length,i.shape.length)),r.backend_util.assertAxesAreInnerMostDims("all",c,h.shape.length);const[p,f]=r.backend_util.computeOutAndReduceShapes(h.shape,c),m=r.ZSL.sizeFromShape(f),g=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(p),h.dtype),b=n.data.get(h.dataId).values;for(let e=0;e<g.length;++e){const t=e*m;let n=b[t];for(let e=0;e<m;++e){const r=b[t+e];n=n&&r}g[e]=n}null!=d&&n.disposeIntermediateTensorInfo(h);const y=n.makeTensorInfo(p,h.dtype,g);if(l){const e=I({inputs:{x:y},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(p,u)}});return n.disposeIntermediateTensorInfo(y),e}return y}},z={kernelName:r.FSt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o,keepDims:l}=a;(0,s.C)(i,"any");const u=r.ZSL.parseAxisParam(o,i.shape);let c=u;const d=r.backend_util.getAxesPermutation(c,i.shape.length);let h=i;null!=d&&(h=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:d}}),c=r.backend_util.getInnerMostAxes(c.length,i.shape.length)),r.backend_util.assertAxesAreInnerMostDims("any",c,h.shape.length);const[p,f]=r.backend_util.computeOutAndReduceShapes(h.shape,c),m=r.ZSL.sizeFromShape(f),g=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(p),h.dtype),b=n.data.get(h.dataId).values;for(let e=0;e<g.length;++e){const t=e*m;let n=b[t];for(let e=0;e<m;++e){const r=b[t+e];n=n||r}g[e]=n}null!=d&&n.disposeIntermediateTensorInfo(h);const y=n.makeTensorInfo(p,h.dtype,g);if(l){const e=I({inputs:{x:y},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(p,u)}});return n.disposeIntermediateTensorInfo(y),e}return y}},B={kernelName:r.Jp_,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o}=a;(0,s.C)(i,"argMax");let l=r.ZSL.parseAxisParam(o,i.shape);const u=r.backend_util.getAxesPermutation(l,i.shape.length);let c=i;const d=[];null!=u&&(c=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:u}}),d.push(c),l=r.backend_util.getInnerMostAxes(l.length,c.shape.length)),l=[l[0]],r.backend_util.assertAxesAreInnerMostDims("argMax",l,c.shape.length);const[h,p]=r.backend_util.computeOutAndReduceShapes(c.shape,l),f=r.ZSL.sizeFromShape(h),m=r.ZSL.makeZerosTypedArray(f,"int32"),g=r.ZSL.sizeFromShape(p),b=n.data.get(c.dataId).values;for(let e=0;e<m.length;++e){const t=e*g;let n=b[t],r=0;for(let e=0;e<g;++e){const s=b[t+e];s>n&&(n=s,r=e)}m[e]=r}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(h,"int32",m)}},V={kernelName:r.p_m,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o}=a;(0,s.C)(i,"argMin");let l=r.ZSL.parseAxisParam(o,i.shape);const u=r.backend_util.getAxesPermutation(l,i.shape.length);let c=i;const d=[];null!=u&&(c=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:u}}),d.push(c),l=r.backend_util.getInnerMostAxes(l.length,c.shape.length)),l=[l[0]],r.backend_util.assertAxesAreInnerMostDims("argMin",l,c.shape.length);const[h,p]=r.backend_util.computeOutAndReduceShapes(c.shape,l),f=r.ZSL.sizeFromShape(h),m=r.ZSL.makeZerosTypedArray(f,"int32"),g=r.ZSL.sizeFromShape(p),b=n.data.get(c.dataId).values;for(let e=0;e<m.length;++e){const t=e*g;let n=b[t],r=0;for(let e=0;e<g;++e){const s=b[t+e];s<n&&(n=s,r=e)}m[e]=r}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(h,"int32",m)}},U=(0,u.v)(r.QKF,(e=>Math.asin(e))),j={kernelName:r.QKF,backendName:"cpu",kernelFunc:U},W=(0,u.v)(r.epO,(e=>Math.asinh(e))),G={kernelName:r.epO,backendName:"cpu",kernelFunc:W},H=(0,u.v)(r.TyE,(e=>Math.atan(e))),q={kernelName:r.TyE,backendName:"cpu",kernelFunc:H};var Z=n(8410);const K=(0,m.Z)(((e,t)=>Math.atan2(e,t))),Y=(0,Z.j)(r.lxb,K),X={kernelName:r.lxb,backendName:"cpu",kernelFunc:Y},Q=(0,u.v)(r.zP9,(e=>Math.atanh(e))),J={kernelName:r.zP9,backendName:"cpu",kernelFunc:Q};function ee(e,t,n,s,a,i){const o=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,c=a.dilationWidth,d=a.effectiveFilterHeight,h=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=(0,r.ra8)(a.outShape,n),b=g.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],w=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let t=0;t<a.batchSize;++t){const n=t*y,r=t*s[0];for(let t=0;t<a.inChannels;++t)for(let g=0;g<a.outHeight;++g){const y=g*o-p,x=Math.max(0,y),_=Math.min(a.inHeight,d+y),k=n+g*w;for(let n=0;n<a.outWidth;++n){const o=n*l-f,d=Math.max(0,o),p=Math.min(a.inWidth,h+o);let g=m,y=0,w=0;for(let n=x;n<_;n+=u){const a=r+n*s[1];for(let n=d;n<p;n+=c){const r=e[a+n*s[2]+t];"max"===i&&r>g?g=r:"avg"===i&&(y+=r,w++)}if(isNaN(g))break}b[k+n*v+t]="avg"===i?y/w:g}}}return g}function te(e,t,n,s,a=!1,i=!1){const o=(0,r.ra8)(s.outShape,"int32"),l=s.strideHeight,u=s.strideWidth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterHeight,p=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,g=(0,r.ra8)(t,n,e);for(let e=0;e<s.batchSize;++e)for(let t=0;t<s.inChannels;++t)for(let n=0;n<s.outHeight;++n){const r=n*l-f;let b=r;for(;b<0;)b+=c;const y=Math.min(s.inHeight,h+r);for(let l=0;l<s.outWidth;++l){const h=l*u-m;let f=h;for(;f<0;)f+=d;const w=Math.min(s.inWidth,p+h);let v=Number.NEGATIVE_INFINITY,x=-1;for(let n=b;n<y;n+=c){const o=n-r;for(let r=f;r<w;r+=d){const l=r-h,u=g.get(e,n,r,t);u>v&&(v=u,x=a?i?((e*s.inHeight+n)*s.inWidth+r)*s.inChannels+t:(n*s.inWidth+r)*s.inChannels+t:o*p+l)}}o.set(x,e,n,l,t)}}return o}function ne(e,t,n,s,a,i){const o=a.strideDepth,l=a.strideHeight,u=a.strideWidth,c=a.dilationDepth,d=a.dilationHeight,h=a.dilationWidth,p=a.effectiveFilterDepth,f=a.effectiveFilterHeight,m=a.effectiveFilterWidth,g=a.padInfo.front,b=a.padInfo.top,y=a.padInfo.left,w="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=(0,r.ra8)(a.outShape,n),x=v.values,_=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],T=a.outShape[4];for(let t=0;t<a.batchSize;++t){const n=t*_,r=t*s[0];for(let t=0;t<a.inChannels;++t)for(let v=0;v<a.outDepth;++v){const _=v*o-g;let I=_;for(;I<0;)I+=c;const E=Math.min(a.inDepth,p+_),A=n+v*k;for(let n=0;n<a.outHeight;++n){const o=n*l-b;let p=o;for(;p<0;)p+=d;const g=Math.min(a.inHeight,f+o),v=A+n*S;for(let n=0;n<a.outWidth;++n){const o=n*u-y;let l=o;for(;l<0;)l+=h;const f=Math.min(a.inWidth,m+o),b=v+n*T;let _=w,k=0,S=0;for(let n=I;n<E;n+=c){const a=r+n*s[1];for(let n=p;n<g;n+=d){const r=a+n*s[2];for(let n=l;n<f;n+=h){const a=e[r+n*s[3]+t];if("max"===i&&a>_?_=a:"avg"===i&&(k+=a,S++),isNaN(_))break}if(isNaN(_))break}if(isNaN(_))break}x[b+t]="avg"===i?k/Math.max(S,1):_}}}}return v}const re={kernelName:r.ho8,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t;(0,s.C)(i,"avgPool");const{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=a;r.ZSL.assert(r.backend_util.eitherStridesOrDilationsAreOne(l,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`));const d=r.backend_util.computePool2DInfo(i.shape,o,l,1,u,c);let p;if(1===d.filterWidth&&1===d.filterHeight&&r.ZSL.arraysEqual(d.inShape,d.outShape))p=(0,h.D)({inputs:{x:i},backend:n});else{const e=n.data.get(i.dataId).values,t=r.ZSL.computeStrides(i.shape),s=ee(e,i.shape,i.dtype,t,d,"avg");p=n.makeTensorInfo(d.outShape,i.dtype,s.values)}return p}},se={kernelName:r.cS,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{filterSize:o,strides:l,pad:u,dimRoundingMode:c,dataFormat:d}=a;(0,s.C)(i,"avgPool3d");const h=r.backend_util.computePool3DInfo(i.shape,o,l,1,u,c,d),p=ne(n.data.get(i.dataId).values,i.shape,i.dtype,r.ZSL.computeStrides(i.shape),h,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}},ae={kernelName:r.wwC,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,input:o}=t,{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=a;(0,s.C)([i,o],"avgPool3DGrad");const h=r.backend_util.computePool3DInfo(o.shape,l,u,1,c,d),p=h.strideDepth,f=h.strideHeight,m=h.strideWidth,g=h.filterDepth,b=h.filterHeight,y=h.filterWidth,w=h.dilationDepth,v=h.dilationHeight,x=h.dilationWidth,_=h.effectiveFilterDepth,k=h.effectiveFilterHeight,S=h.effectiveFilterWidth,T=_-1-h.padInfo.front,I=S-1-h.padInfo.left,E=k-1-h.padInfo.top,A=(0,r.ra8)(o.shape,"float32"),C=1/(g*b*y),N=n.bufferSync(i);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inDepth;++n)for(let r=0;r<h.inHeight;++r)for(let s=0;s<h.inWidth;++s){const a=n-T,i=r-E,o=s-I;let l=0;for(let n=0;n<_;n+=w){const r=(a+n)/p;if(!(r<0||r>=h.outDepth||Math.floor(r)!==r))for(let n=0;n<k;n+=v){const s=(i+n)/f;if(!(s<0||s>=h.outHeight||Math.floor(s)!==s))for(let n=0;n<S;n+=x){const a=(o+n)/m;a<0||a>=h.outWidth||Math.floor(a)!==a||(l+=N.get(e,r,s,a,t))}}}A.set(l*C,e,n,r,s,t)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}},ie={kernelName:r.VCH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,input:o}=t,l=o;(0,s.C)([i,o],"avgPoolGrad");const{filterSize:u,strides:c,pad:d}=a,h=r.backend_util.computePool2DInfo(l.shape,u,c,1,d),p=h.strideHeight,f=h.strideWidth,m=h.filterHeight,g=h.filterWidth,b=h.dilationHeight,y=h.dilationWidth,w=h.effectiveFilterHeight,v=h.effectiveFilterWidth,x=v-1-h.padInfo.left,_=w-1-h.padInfo.top,k=(0,r.ra8)(l.shape,"float32"),S=1/(m*g),T=n.data.get(i.dataId).values,I=(0,r.ra8)(i.shape,"float32",T);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inHeight;++n)for(let r=0;r<h.inWidth;++r){const s=n-_,a=r-x;let i=0;for(let n=0;n<w;n+=b){const r=(s+n)/p;if(!(r<0||r>=h.outHeight||Math.floor(r)!==r))for(let n=0;n<v;n+=y){const s=(a+n)/f;s<0||s>=h.outWidth||Math.floor(s)!==s||(i+=I.get(e,r,s,t))}}k.set(i*S,e,n,r,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},oe={kernelName:r.i5R,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,scale:o,offset:l,mean:u,variance:c}=t;r.ZSL.assert(u.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),r.ZSL.assert(null==l||u.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),r.ZSL.assert(null==o||u.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),(0,s.C)([i,u,c,o,l],"batchNorm");let{varianceEpsilon:d}=a;null==d&&(d=.001);const h=n.data.get(i.dataId).values,p=n.data.get(u.dataId).values,f=n.data.get(c.dataId).values,m=o?n.data.get(o.dataId).values:new Float32Array([1]),g=l?n.data.get(l.dataId).values:new Float32Array([0]),b=new Float32Array(h.length),y=g.length,w=m.length,v=f.length,x=p.length;let _=0,k=0,S=0,T=0;for(let e=0;e<h.length;++e)b[e]=g[_++]+(h[e]-p[k++])*m[S++]/Math.sqrt(f[T++]+d),_>=y&&(_=0),k>=x&&(k=0),S>=w&&(S=0),T>=v&&(T=0);return n.makeTensorInfo(i.shape,i.dtype,b)}};var le=n(8592);const ue={kernelName:r.Ik2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{blockShape:o,crops:l}=a;(0,s.C)([i],"batchToSpaceND");const u=o.reduce(((e,t)=>e*t)),c=r.backend_util.getReshaped(i.shape,o,u),d=r.backend_util.getPermuted(c.length,o.length),h=r.backend_util.getReshapedPermuted(i.shape,o,u),p=r.backend_util.getSliceBeginCoords(l,o.length),f=r.backend_util.getSliceSize(h,l,o.length),m=I({inputs:{x:i},backend:n,attrs:{shape:c}}),g=(0,L.m)({inputs:{x:m},backend:n,attrs:{perm:d}}),b=I({inputs:{x:g},backend:n,attrs:{shape:h}}),y=(0,le.di)({inputs:{x:b},backend:n,attrs:{begin:p,size:f}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};var ce=n(441);const de={kernelName:r.N4F,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=(0,ce.X)(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}};var he=n(7540);const pe={kernelName:r.vj7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:s,s1:a}=t,i=n.data.get(s.dataId).values,o=n.data.get(a.dataId).values,l=r.backend_util.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeTensorInfo([l.length],"int32",Int32Array.from(l))}};var fe=n(6051),me=n(6725);const ge=(0,u.v)(r.vaV,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),be={kernelName:r.vaV,backendName:"cpu",kernelFunc:ge};var ye=n(6154);const we={kernelName:r.$zE,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(r.ZSL.sizeFromShape(t.shape)),a=n.data.get(t.dataId),i=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,l=n.data.get(i.dataId).values,u=n.data.get(o.dataId).values;for(let e=0;e<l.length;e++){const t=l[e],n=u[e];s[e]=Math.hypot(t,n)}return n.makeOutput(s,t.shape,"float32")}};var ve=n(3053);function xe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const _e={kernelName:r.dv8,backendName:"cpu",kernelFunc:xe};var ke=n(9828);function Se(e){const{inputs:t,backend:n,attrs:s}=e,{axis:a}=s,i=r.ZSL.parseAxisParam(a,t[0].shape)[0],o=t.map((e=>e.shape));r.backend_util.assertParamsConsistent(o,i);let l=r.backend_util.computeOutShape(t.map((e=>e.shape)),i);if(0===r.ZSL.sizeFromShape(l))return n.makeTensorInfo(l,t[0].dtype,[]);const u=t.filter((e=>r.ZSL.sizeFromShape(e.shape)>0));if(1===u.length)return(0,h.D)({inputs:{x:u[0]},backend:n});if("complex64"===u[0].dtype){const e=u.map((e=>(0,ke.x)({inputs:{input:e},backend:n}))),t=u.map((e=>xe({inputs:{input:e},backend:n}))),r=Se({inputs:e,backend:n,attrs:{axis:i}}),s=Se({inputs:t,backend:n,attrs:{axis:i}}),a=(0,ye.f)({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),a}const c=u.map((e=>{const t=r.ZSL.sizeFromShape(e.shape.slice(i));return I({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),d=c.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));l=r.backend_util.computeOutShape(c.map((e=>e.shape)),1);const p=1===c[0].shape[0],f=(0,ve.h)(d,l,t[0].dtype,p),m=r.backend_util.computeOutShape(u.map((e=>e.shape)),i),g=n.makeTensorInfo(m,t[0].dtype,f);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}const Te={kernelName:r.$dB,backendName:"cpu",kernelFunc:Se};function Ie(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,filter:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}=a;(0,s.C)([i,o],"conv2d");const p=r.backend_util.convertConv2DDataFormat(c),f=r.backend_util.computeConv2DInfo(i.shape,o.shape,l,d,u,h,!1,p),m=f.filterHeight,g=f.filterWidth,b=f.dilationHeight,y=f.dilationWidth,w=f.padInfo.left,v=f.padInfo.top,x="channelsLast"===f.dataFormat,_=new r.ylz(f.outShape,i.dtype),k=r.ZSL.computeStrides(i.shape),S=r.ZSL.computeStrides(o.shape),T=k[0],I=x?k[1]:k[2],E=x?k[2]:1,A=x?1:k[1],C=_.strides[0],N=x?_.strides[1]:_.strides[2],$=x?_.strides[2]:1,O=x?1:_.strides[1],D=n.data.get(i.dataId).values,F=n.data.get(o.dataId).values,R=_.values;for(let e=0;e<f.batchSize;++e){const t=e*T,n=e*C;for(let e=0;e<f.outHeight;++e){const r=n+e*N,s=e*f.strideHeight-v;for(let e=0;e<m;++e){const n=s+e*b;if(n<0||n>=f.inHeight)continue;const a=e*S[0],i=t+n*I;for(let e=0;e<f.outWidth;++e){const t=r+e*$,n=e*f.strideWidth-w;for(let e=0;e<g;++e){const r=n+e*y;if(r<0||r>=f.inWidth)continue;const s=i+r*E;let o=a+e*S[1];for(let e=0;e<f.inChannels;++e){const n=D[s+e*A];for(let e=0;e<f.outChannels;++e)R[t+e*O]+=n*F[o+e];o+=f.outChannels}}}}}}return n.makeTensorInfo(_.shape,_.dtype,R)}const Ee={kernelName:r.p2J,backendName:"cpu",kernelFunc:Ie},Ae={kernelName:r.rFm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,dy:o}=t,{strides:l,pad:u,dataFormat:c,dimRoundingMode:d,filterShape:h}=a;(0,s.C)([i,o],"conv2dBackpropFilter");const p=r.backend_util.convertConv2DDataFormat(c),f=r.backend_util.computeConv2DInfo(i.shape,h,l,1,u,d,!1,p),{strideHeight:m,strideWidth:g,filterHeight:b,filterWidth:y}=f,w="channelsLast"===f.dataFormat,v=new r.ylz(f.filterShape,"float32"),x=f.padInfo.left,_=f.padInfo.top,k=n.data.get(i.dataId).values,S=n.data.get(o.dataId).values,T=new r.ylz(i.shape,i.dtype,k),I=new r.ylz(o.shape,o.dtype,S);for(let e=0;e<b;++e){const t=Math.max(0,Math.ceil((_-e)/m)),n=Math.min(f.outHeight,(f.inHeight+_-e)/m);for(let r=0;r<y;++r){const s=Math.max(0,Math.ceil((x-r)/g)),a=Math.min(f.outWidth,(f.inWidth+x-r)/g);for(let i=0;i<f.inChannels;++i)for(let o=0;o<f.outChannels;++o){let l=0;for(let u=0;u<f.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*m-_;for(let e=s;e<a;++e){const n=r+e*g-x;l+=w?T.get(u,t,n,i)*I.get(u,c,e,o):T.get(u,i,t,n)*I.get(u,o,c,e)}}v.set(l,e,r,i,o)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},Ce={kernelName:r.jfg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,filter:o}=t,{inputShape:l,strides:u,pad:c,dataFormat:d,dimRoundingMode:h}=a;(0,s.C)([i,o],"conv2dBackpropInput");const p=r.ZSL.computeStrides(o.shape),f=r.ZSL.computeStrides(i.shape);let m=r.backend_util.convertConv2DDataFormat(d);const g=r.backend_util.computeConv2DInfo(l,o.shape,u,1,c,h,!1,m),b=new r.ylz(g.inShape,"float32"),y=b.values,w=n.data.get(i.dataId).values,v=n.data.get(o.dataId).values,[x,_,k]=p,{batchSize:S,filterHeight:T,filterWidth:I,inChannels:E,inHeight:A,inWidth:C,outChannels:N,outHeight:$,outWidth:O,strideHeight:D,strideWidth:F}=g;m=g.dataFormat;const R=T-1-g.padInfo.top,M=I-1-g.padInfo.left,L="channelsLast"===m,P=b.strides[0],z=L?b.strides[1]:b.strides[2],B=L?b.strides[2]:1,V=L?1:b.strides[1],U=f[0],j=L?f[1]:f[2],W=L?f[2]:1,G=L?1:f[1];for(let e=0;e<S;++e)for(let t=0;t<E;++t)for(let n=0;n<A;++n){const r=n-R,s=Math.max(0,Math.ceil(r/D)),a=Math.min($,(T+r)/D);for(let i=0;i<C;++i){const o=i-M,l=Math.max(0,Math.ceil(o/F)),u=Math.min(O,(I+o)/F);let c=0;for(let n=s;n<a;++n){const s=n*D-r;for(let r=l;r<u;++r){const a=U*e+j*n+W*r,i=x*(T-1-s)+_*(I-1-(r*F-o))+k*t;for(let e=0;e<N;++e)c+=w[a+G*e]*v[i+e]}}y[P*e+z*n+B*i+V*t]=c}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},Ne={kernelName:r.A1h,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,filter:o}=t,{strides:l,pad:u,dilations:c}=a;(0,s.C)([i,o],"conv3d");const d=r.backend_util.computeConv3DInfo(i.shape,o.shape,l,c,u),{filterDepth:h,filterHeight:p,filterWidth:f,dilationDepth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=d,w=y.front,v=y.left,x=y.top,_=new r.ylz(d.outShape,i.dtype),k=n.data.get(i.dataId).values,S=n.data.get(o.dataId).values,T=_.values,I=r.ZSL.computeStrides(i.shape),E=r.ZSL.computeStrides(o.shape);for(let e=0;e<d.batchSize;++e){const t=e*I[0],n=e*_.strides[0];for(let e=0;e<d.outDepth;++e){const r=n+e*_.strides[1],s=e*d.strideDepth-w;for(let e=0;e<h;++e){const n=s+e*m;if(n<0||n>=d.inDepth)continue;const a=e*E[0],i=t+n*I[1];for(let e=0;e<d.outHeight;++e){const t=r+e*_.strides[2],n=e*d.strideHeight-x;for(let e=0;e<p;++e){const r=n+e*g;if(r<0||r>=d.inHeight)continue;const s=a+e*E[1],o=i+r*I[2];for(let e=0;e<d.outWidth;++e){const n=t+e*d.outChannels,r=e*d.strideWidth-v;for(let e=0;e<f;++e){const t=r+e*b;if(t<0||t>=d.inWidth)continue;const a=s+e*E[2],i=o+t*d.inChannels;let l=a;for(let e=0;e<d.inChannels;++e){const t=k[i+e];for(let e=0;e<d.outChannels;++e)T[n+e]+=t*S[l+e];l+=d.outChannels}}}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},$e={kernelName:r.iGz,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,dy:o}=t,{strides:l,pad:u,filterShape:c}=a;(0,s.C)([i,o],"conv3dBackpropFilterV2");const d=r.ZSL.computeStrides(i.shape),h=r.ZSL.computeStrides(o.shape),p=r.backend_util.computeConv3DInfo(i.shape,c,l,1,u),f=p.strideDepth,m=p.strideHeight,g=p.strideWidth,b=p.filterDepth,y=p.filterHeight,w=p.filterWidth,v=new r.ylz(p.filterShape,"float32"),x=v.values,[_,k,S,T]=v.strides,I=n.data.get(o.dataId).values,[E,A,C,N]=h,$=n.data.get(i.dataId).values,[O,D,F,R]=d,M=p.padInfo.front,L=p.padInfo.left,P=p.padInfo.top;for(let e=0;e<b;++e){const t=Math.max(0,Math.ceil((M-e)/f)),n=Math.min(p.outDepth,(p.inDepth+M-e)/f),r=e*_;for(let s=0;s<y;++s){const a=Math.max(0,Math.ceil((P-s)/m)),i=Math.min(p.outHeight,(p.inHeight+P-s)/m),o=s*k+r;for(let r=0;r<w;++r){const l=Math.max(0,Math.ceil((L-r)/g)),u=Math.min(p.outWidth,(p.inWidth+L-r)/g),c=r*S+o;for(let o=0;o<p.inChannels;++o){const d=o*T+c;for(let c=0;c<p.outChannels;++c){let h=0;for(let d=0;d<p.batchSize;++d){const p=d*O,b=d*E;for(let d=t;d<n;++d){const t=(e+d*f-M)*D+p,n=d*A+b;for(let e=a;e<i;++e){const a=(s+e*m-P)*F+t,i=e*C+n;for(let e=l;e<u;++e){const t=e*N+i;h+=$[(r+e*g-L)*R+a+o]*I[t+c]}}}}x[d+c]=h}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},Oe={kernelName:r.gC7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,filter:o}=t,{pad:l,strides:u,inputShape:c}=a;(0,s.C)([i],"conv3dBackpropInputV2");const d=r.ZSL.computeStrides(i.shape),h=r.ZSL.computeStrides(o.shape),p=r.backend_util.computeConv3DInfo(c,o.shape,u,1,l),f=new r.ylz(p.inShape,"float32"),m=f.values,[g,b,y,w]=f.strides,v=n.data.get(i.dataId).values,[x,_,k,S]=d,T=n.data.get(o.dataId).values,[I,E,A,C]=h,{batchSize:N,filterDepth:$,filterHeight:O,filterWidth:D,inChannels:F,inDepth:R,inHeight:M,inWidth:L,outChannels:P,outDepth:z,outHeight:B,outWidth:V,strideDepth:U,strideHeight:j,strideWidth:W}=p,G=$-1-p.padInfo.front,H=O-1-p.padInfo.top,q=D-1-p.padInfo.left;for(let e=0;e<N;++e)for(let t=0;t<F;++t)for(let n=0;n<R;++n){const r=n-G,s=Math.max(0,Math.ceil(r/U)),a=Math.min(z,($+r)/U);for(let i=0;i<M;++i){const o=i-H,l=Math.max(0,Math.ceil(o/j)),u=Math.min(B,(O+o)/j);for(let c=0;c<L;++c){const d=c-q,h=Math.max(0,Math.ceil(d/W)),p=Math.min(V,(D+d)/W);let f=0;for(let n=s;n<a;++n){const s=n*U-r;for(let r=l;r<u;++r){const a=r*j-o;for(let i=h;i<p;++i){const o=x*e+_*n+k*r+S*i,l=I*($-1-s)+E*(O-1-a)+A*(D-1-(i*W-d))+C*t;for(let e=0;e<P;++e)f+=v[o+e]*T[l+e]}}}m[g*e+b*n+y*i+w*c+t]=f}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},De=(0,u.v)(r.Mn0,(e=>Math.cos(e))),Fe={kernelName:r.Mn0,backendName:"cpu",kernelFunc:De},Re=(0,u.v)(r.MnK,(e=>Math.cosh(e))),Me={kernelName:r.MnK,backendName:"cpu",kernelFunc:Re},Le={kernelName:r.MRQ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:a,boxes:i,boxInd:o}=t,{cropSize:l,method:u,extrapolationValue:c}=s,[d,h,p,f]=a.shape,m=i.shape[0],[g,b]=l,y=(0,r.ra8)([m,g,b,f],"float32"),w=n.data.get(i.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(a.dataId).values,_=r.ZSL.computeStrides(a.shape),k=r.ZSL.computeStrides(y.shape);for(let e=0;e<m;e++){const t=4*e,n=w[t],r=w[t+1],s=w[t+2],a=w[t+3],i=v[e];if(i>=d)continue;const o=g>1?(s-n)*(h-1)/(g-1):0,l=b>1?(a-r)*(p-1)/(b-1):0;for(let t=0;t<g;t++){const d=g>1?n*(h-1)+t*o:.5*(n+s)*(h-1);if(d<0||d>h-1)for(let n=0;n<b;n++)for(let r=0;r<f;r++){const s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=c}else if("bilinear"===u){const n=Math.floor(d),s=Math.ceil(d),o=d-n;for(let u=0;u<b;u++){const d=b>1?r*(p-1)+u*l:.5*(r+a)*(p-1);if(d<0||d>p-1){for(let n=0;n<f;n++){const r=n+u*k[2]+t*k[1]+e*k[0];y.values[r]=c}continue}const h=Math.floor(d),m=Math.ceil(d),g=d-h;for(let r=0;r<f;r++){let a=r+h*_[2]+n*_[1]+i*_[0];const l=x[a];a=r+m*_[2]+n*_[1]+i*_[0];const c=x[a];a=r+h*_[2]+s*_[1]+i*_[0];const d=x[a];a=r+m*_[2]+s*_[1]+i*_[0];const p=l+(c-l)*g,f=d+(x[a]-d)*g;a=r+u*k[2]+t*k[1]+e*k[0],y.values[a]=p+(f-p)*o}}}else for(let n=0;n<b;++n){const s=b>1?r*(p-1)+n*l:.5*(r+a)*(p-1);if(s<0||s>p-1){for(let r=0;r<f;r++){const s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=c}continue}const o=Math.round(s),u=Math.round(d);for(let r=0;r<f;r++){const s=r+o*_[2]+u*_[1]+i*_[0],a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=x[s]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},Pe={kernelName:r.jj_,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o,exclusive:l,reverse:u}=a;(0,s.C)(i,"cumprod");const c=r.backend_util.getAxesPermutation([o],i.shape.length);let d=i;null!=c&&(d=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:c}}));const h=r.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(h!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${h}`);const p=(0,r.TuY)(d.dtype,"int32"),f=r.ZSL.makeOnesTypedArray(r.ZSL.sizeFromShape(d.shape),p),m=n.data.get(d.dataId).values,g=d.shape[d.shape.length-1],b=u?(e,t)=>e+g-t-1:(e,t)=>e+t;for(let e=0;e<m.length;e+=g)for(let t=0;t<g;t++){const n=b(e,t);if(0===t)f[n]=l?1:m[n];else{const r=b(e,t-1);f[n]=l?m[r]*f[r]:m[n]*f[r]}}const y=n.makeTensorInfo(d.shape,p,f);if(null!=c){const e=r.backend_util.getUndoAxesPermutation(c),t=(0,L.m)({inputs:{x:y},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(d),t}return y}},ze={kernelName:r.nY8,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o,exclusive:l,reverse:u}=a;(0,s.C)(i,"cumsum");const c=r.backend_util.getAxesPermutation([o],i.shape.length);let d=i;null!=c&&(d=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:c}}));const h=r.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(h!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${h}`);const p=(0,r.TuY)(d.dtype,"int32"),f=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(d.shape),p),m=n.data.get(d.dataId).values,g=d.shape[d.shape.length-1],b=u?(e,t)=>e+g-t-1:(e,t)=>e+t;for(let e=0;e<m.length;e+=g)for(let t=0;t<g;t++){const n=b(e,t);if(0===t)f[n]=l?0:m[n];else{const r=b(e,t-1);f[n]=l?m[r]+f[r]:m[n]+f[r]}}const y=n.makeTensorInfo(d.shape,p,f);if(null!=c){const e=r.backend_util.getUndoAxesPermutation(c),t=(0,L.m)({inputs:{x:y},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(d),t}return y}},Be={kernelName:r.wNW,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.data.get(s.dataId).values,t=n.data.get(a.dataId).values,r=(0,ce.X)(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=(0,ce.N)(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Ve={kernelName:r.TMz,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{blockSize:i,dataFormat:o}=s;r.ZSL.assert("NHWC"===o,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`));const l=a.shape[0],u=a.shape[1],c=a.shape[2],d=a.shape[3],h=u*i,p=c*i,f=d/(i*i),m=n.data.get(a.dataId).values,g=new Float32Array(l*h*p*f);let b=0;for(let e=0;e<l;++e)for(let t=0;t<h;++t){const n=Math.floor(t/i),r=t%i;for(let t=0;t<p;++t){const s=Math.floor(t/i),a=(r*i+t%i)*f;for(let t=0;t<f;++t){const r=t+a+d*(s+c*(n+u*e));g[b++]=m[r]}}}return n.makeTensorInfo([l,h,p,f],a.dtype,g)}};function Ue(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,filter:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d}=a;(0,s.C)([i,o],"depthwiseConv2DNative");const h=r.ZSL.computeStrides(i.shape),p=r.ZSL.computeStrides(o.shape);let f=c;null==f&&(f=[1,1]),r.ZSL.assert(r.backend_util.eitherStridesOrDilationsAreOne(l,f),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`));const m=r.backend_util.computeConv2DInfo(i.shape,o.shape,l,f,u,d,!0),{filterHeight:g,filterWidth:b,dilationHeight:y,dilationWidth:w,padInfo:v}=m,x=v.left,_=v.top,k=m.outChannels/m.inChannels,S=new r.ylz(m.outShape,i.dtype),T=n.data.get(i.dataId).values,I=n.data.get(o.dataId).values,E=S.values;for(let e=0;e<m.batchSize;++e){const t=e*h[0],n=e*S.strides[0];for(let e=0;e<m.outHeight;++e){const r=n+e*S.strides[1],s=e*m.strideHeight-_;for(let e=0;e<g;++e){const n=s+e*y;if(n<0||n>=m.inHeight)continue;const a=e*p[0],i=t+n*h[1];for(let e=0;e<m.outWidth;++e){const t=r+e*S.strides[2],n=e*m.strideWidth-x;for(let e=0;e<b;++e){const r=n+e*w;if(r<0||r>=m.inWidth)continue;const s=a+e*p[1],o=i+r*m.inChannels;let l=t,u=s;for(let e=0;e<m.inChannels;++e){const t=T[o+e];for(let e=0;e<k;++e)E[l+e]+=t*I[u+e];l+=k,u+=k}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const je={kernelName:r.tGH,backendName:"cpu",kernelFunc:Ue},We={kernelName:r.X$8,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,dy:o}=t,{strides:l,dilations:u,pad:c,dimRoundingMode:d,filterShape:h}=a;(0,s.C)([i,o],"depthwiseConv2dNativeBackpropFilter");const p=r.backend_util.computeConv2DInfo(i.shape,h,l,u,c,d,!0),{strideHeight:f,strideWidth:m,filterHeight:g,filterWidth:b}=p,y=new r.ylz(p.filterShape,"float32"),w=p.padInfo.left,v=p.padInfo.top,x=p.outChannels/p.inChannels,_=n.data.get(i.dataId).values,k=new r.ylz(i.shape,i.dtype,_),S=n.data.get(o.dataId).values,T=new r.ylz(o.shape,o.dtype,S);for(let e=0;e<g;++e){const t=Math.max(0,Math.ceil((v-e)/f)),n=Math.min(p.outHeight,(p.inHeight+v-e)/f);for(let r=0;r<b;++r){const s=Math.max(0,Math.ceil((w-r)/m)),a=Math.min(p.outWidth,(p.inWidth+w-r)/m);for(let i=0;i<p.outChannels;++i){const o=Math.trunc(i/x),l=i%x;let u=0;for(let l=0;l<p.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*f-v;for(let e=s;e<a;++e){const n=r+e*m-w;u+=k.get(l,t,n,o)*T.get(l,c,e,i)}}y.set(u,e,r,o,l)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},Ge={kernelName:r.nVu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,filter:o}=t,{strides:l,dilations:u,pad:c,dimRoundingMode:d,inputShape:h}=a;(0,s.C)([i,o],"depthwiseConv2DNativeBackpropInput");const p=r.ZSL.computeStrides(i.shape),f=r.ZSL.computeStrides(o.shape),m=r.backend_util.computeConv2DInfo(h,o.shape,l,u,c,d,!0),g=new r.ylz(m.inShape,"float32"),b=g.values,[y,w,v]=g.strides,x=n.data.get(i.dataId).values,[_,k,S]=p,T=n.data.get(o.dataId).values,[I,E,A]=f,{batchSize:C,filterHeight:N,filterWidth:$,inChannels:O,inHeight:D,inWidth:F,outChannels:R,outHeight:M,outWidth:L,strideHeight:P,strideWidth:z}=m,B=N-1-m.padInfo.top,V=$-1-m.padInfo.left,U=R/O;for(let e=0;e<C;++e)for(let t=0;t<O;++t)for(let n=0;n<D;++n){const r=n-B,s=Math.max(0,Math.ceil(r/P)),a=Math.min(M,(N+r)/P);for(let i=0;i<F;++i){const o=i-V,l=Math.max(0,Math.ceil(o/z)),u=Math.min(L,($+o)/z);let c=0;for(let n=s;n<a;++n){const s=n*P-r;for(let r=l;r<u;++r){const a=_*e+k*n+S*r,i=I*(N-1-s)+E*($-1-(r*z-o))+A*t;for(let e=0;e<U;++e)c+=x[a+(t*U+e)]*T[i+e]}}b[y*e+w*n+v*i+t]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},He={kernelName:r.ORI,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,a=r.ZSL.sizeFromShape(s.shape),i=n.data.get(s.dataId).values,o=(0,r.ra8)([a,a],s.dtype),l=o.values;for(let e=0;e<i.length;e++)l[e*a+e]=i[e];const u=[...s.shape,...s.shape];return n.makeTensorInfo(u,o.dtype,o.values)}},qe={kernelName:r.jxD,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=u.data.get(s.dataId).values,d=s.shape.length,h=u.data.get(a.dataId).values,p=a.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:b,outHeight:y,outWidth:w,padInfo:v,strideHeight:x,strideWidth:_,filterHeight:k,filterWidth:S,dilationHeight:T,dilationWidth:I,outShape:E}=r.backend_util.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),A=r.ZSL.sizeFromShape(E),C=E.length,N=r.ZSL.getArrayFromDType(s.dtype,A);for(let e=0;e<f;++e)for(let t=0;t<y;++t){const n=t*x-v.top;for(let i=0;i<w;++i){const o=i*_-v.left;for(let l=0;l<b;++l){let u=Number.MIN_SAFE_INTEGER;for(let t=0;t<k;++t){const i=n+t*T;if(i>=0&&i<m)for(let n=0;n<S;++n){const f=o+n*I;if(f>=0&&f<g){const o=r.ZSL.locToIndex([e,i,f,l],d,r.ZSL.computeStrides(s.shape)),m=r.ZSL.locToIndex([t,n,l],p,r.ZSL.computeStrides(a.shape)),g=c[o]+h[m];g>u&&(u=g)}}}N[r.ZSL.locToIndex([e,t,i,l],C,r.ZSL.computeStrides(E))]=u}}}return{dataId:u.write(r.ZSL.toTypedArray(N,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}},Ze={kernelName:r.pk0,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:a,dy:i}=e,{strides:o,pad:l,dilations:u}=n,c=t,d=r.ZSL.toNestedArray(s.shape,c.data.get(s.dataId).values),h=r.ZSL.toNestedArray(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:w,strideHeight:v,strideWidth:x,filterHeight:_,filterWidth:k,dilationHeight:S,dilationWidth:T,outShape:I}=r.backend_util.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u);r.ZSL.assert(i.rank===I.length,(()=>`Error in ${r.pk0}, dy must have the same rank as output ${I.length}, but got ${i.rank}`));const E=r.ZSL.toNestedArray(I,c.data.get(i.dataId).values),A=r.ZSL.makeZerosNestedTypedArray(a.shape,a.dtype);for(let e=0;e<p;++e)for(let t=0;t<b;++t){const n=t*v-w.top;for(let r=0;r<y;++r){const s=r*x-w.left;for(let a=0;a<g;++a){let i=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<_;++t){const r=n+t*S;if(r>=0&&r<f)for(let n=0;n<k;++n){const u=s+n*T;if(u>=0&&u<m){const s=d[e][r][u][a]+h[t][n][a];s>i&&(i=s,o=t,l=n)}}}A[o][l][a]+=E[e][t][r][a]}}}return{dataId:c.write(r.ZSL.toTypedArray(A,s.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Ke={kernelName:r.bP9,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:a,dy:i}=e,{strides:o,pad:l,dilations:u}=n,c=t,d=r.ZSL.toNestedArray(s.shape,c.data.get(s.dataId).values),h=r.ZSL.toNestedArray(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:w,strideHeight:v,strideWidth:x,filterHeight:_,filterWidth:k,dilationHeight:S,dilationWidth:T,outShape:I}=r.backend_util.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u);r.ZSL.assert(i.rank===I.length,(()=>`Error in ${r.bP9}, dy must have the same rank as output ${I.length}, but got ${i.rank}`));const E=r.ZSL.toNestedArray(I,c.data.get(i.dataId).values),A=r.ZSL.makeZerosNestedTypedArray(s.shape,s.dtype);for(let e=0;e<p;++e)for(let t=0;t<b;++t){const n=t*v-w.top;for(let r=0;r<y;++r){const s=r*x-w.left;for(let a=0;a<g;++a){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=s<0?0:s;for(let t=0;t<_;++t){const r=n+t*S;if(r>=0&&r<f)for(let n=0;n<k;++n){const u=s+n*T;if(u>=0&&u<m){const s=d[e][r][u][a]+h[t][n][a];s>i&&(i=s,o=r,l=u)}}}A[e][o][l][a]+=E[e][t][r][a]}}}return{dataId:c.write(r.ZSL.toTypedArray(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Ye={kernelName:r.XmO,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,b=new Uint8ClampedArray(p*h*4);for(let e=0;e<h*p;++e){const t=[0,0,0,255*u];for(let n=0;n<f;n++){const r=m[e*f+n];if("float32"===s.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===s.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}const n=4*e;b[n+0]=Math.round(t[0]),b[n+1]=Math.round(t[1]),b[n+2]=Math.round(t[2]),b[n+3]=Math.round(t[3])}a.width=p,a.height=h;const y=new ImageData(b,p,h);return d.putImageData(y,0,0),s}};var Xe=n(4160),Qe=n(2959);function Je(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o,keepDims:l}=a;let u;(0,s.C)(i,"sum"),u="bool"===i.dtype?(0,fe.wg)({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):(0,h.D)({inputs:{x:i},backend:n});const c=u.shape.length,d=r.ZSL.parseAxisParam(o,u.shape),p=r.backend_util.getAxesPermutation(d,c);let f=d,m=u;null!=p&&(m=(0,L.m)({inputs:{x:u},backend:n,attrs:{perm:p}}),f=r.backend_util.getInnerMostAxes(f.length,c)),r.backend_util.assertAxesAreInnerMostDims("sum",f,m.shape.length);const[g,b]=r.backend_util.computeOutAndReduceShapes(m.shape,f),y=r.backend_util.upcastType(m.dtype,"int32");let w=(0,Qe.U)(n,g,y);const v=r.ZSL.sizeFromShape(b),x=n.data.get(w.dataId).values,_=n.data.get(m.dataId).values;for(let e=0;e<x.length;++e){const t=e*v;let n=0;for(let e=0;e<v;++e)n+=_[t+e];x[e]=n}if(l){const e=w;w=I({inputs:{x:w},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(w.shape,d)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(u),null!=p&&n.disposeIntermediateTensorInfo(m),w}const et={kernelName:r.WuN,backendName:"cpu",kernelFunc:Je},tt={kernelName:r.Qgm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:a}=s,i=t,{allDims:o,summedDims:l,idDims:u}=r.backend_util.decodeEinsumEquation(a,i.length);r.backend_util.checkEinsumDimSizes(o.length,u,i);const{path:c,steps:d}=r.backend_util.getEinsumComputePath(l,u),h=d.length;let p=null,f=o.length;const m=[];for(let e=0;e<h;++e){for(const t of d[e]){const{permutationIndices:e,expandDims:s}=r.backend_util.getEinsumPermutation(f,u[t]);let a;r.backend_util.isIdentityPermutation(e)?a=i[t]:(a=(0,L.m)({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),m.push(a));const o=a.shape.slice();for(let e=0;e<s.length;++e)o.splice(s[e],0,1);r.ZSL.arraysEqual(a.shape,o)||(a=I({inputs:{x:a},backend:n,attrs:{shape:o}}),m.push(a)),null===p?p=a:(p=(0,Xe.lw)({inputs:{a,b:p},backend:n}),m.push(p))}e<h-1&&(c[e]>=0&&(p=Je({inputs:{x:p},backend:n,attrs:{axis:c[e]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeIntermediateTensorInfo(e);return p}},nt={kernelName:r.rsH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:i}=t;(0,s.C)([a,i],"eluGrad");const o=new Float32Array(r.ZSL.sizeFromShape(i.shape)),l=n.data.get(i.dataId).values,u=n.data.get(a.dataId).values;for(let e=0;e<l.length;++e){const t=l[e];o[e]=t>=0?u[e]:u[e]*(t+1)}return n.makeTensorInfo(i.shape,"float32",o)}};var rt=n(5309);const st=r.backend_util.ERF_P,at=r.backend_util.ERF_A1,it=r.backend_util.ERF_A2,ot=r.backend_util.ERF_A3,lt=r.backend_util.ERF_A4,ut=r.backend_util.ERF_A5,ct=(0,u.v)(r._s9,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+st*n);return t*(1-((((ut*r+lt)*r+ot)*r+it)*r+at)*r*Math.exp(-n*n))})),dt={kernelName:r._s9,backendName:"cpu",kernelFunc:ct};var ht=n(9077);function pt(e){const{inputs:t,backend:n,attrs:s}=e,{input:a}=t,{dim:i}=s,o=a.shape.length,l=a.shape.slice();let u=i;return i<0&&(r.ZSL.assert(-(o+1)<=i,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+i+1),l.splice(u,0,1),I({inputs:{x:a},backend:n,attrs:{shape:l}})}const ft={kernelName:r.ybN,backendName:"cpu",kernelFunc:pt};var mt=n(4115);const gt=(0,m.Z)(((e,t)=>e/t)),bt=(0,Z.j)(r.sDr,gt),yt={kernelName:r.sDr,backendName:"cpu",kernelFunc:bt};var wt=n(1900);function vt(e,t,n){const s=e.shape,a=s[0],i=s[1],o=n.data.get(e.dataId),l=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[a,i],d=r.ZSL.sizeFromShape(c),h=r.ZSL.getTypedArrayFromDType("float32",d),p=r.ZSL.getTypedArrayFromDType("float32",d);for(let e=0;e<a;e++){const s=(0,le.di)({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,i]}}),a=(0,le.di)({inputs:{x:u},backend:n,attrs:{begin:[e,0],size:[1,i]}}),o=(0,ye.f)({inputs:{real:s,imag:a},backend:n}),{real:c,imag:d}=xt(o,t,n),f=r.backend_util.mergeRealAndImagArrays(c,d);for(let t=0;t<i;t++){const n=r.backend_util.getComplexWithIndex(f,t);h[e*i+t]=n.real,p[e*i+t]=n.imag}n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o)}const f=n.makeTensorInfo(c,"float32",h),m=n.makeTensorInfo(c,"float32",p),g=(0,ye.f)({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}function xt(e,t,n){const s=r.ZSL.sizeFromShape(e.shape),a=n.data.get(e.dataId),i=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if((l=s)&l-1){const e=function(e,t,n){const s=new Float32Array(2*t);for(let a=0;a<t;a++){let i=0,o=0;for(let s=0;s<t;s++){const l=r.backend_util.exponent(a*s,t,n),u=r.backend_util.getComplexWithIndex(e,s);i+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}n&&(i/=t,o/=t),r.backend_util.assignToTypedArray(s,i,o,a)}return s}(r.backend_util.mergeRealAndImagArrays(i,o),s,t);return r.backend_util.splitRealAndImagArrays(e)}{const a=_t(i,o,s,t,n),l=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(l,"float32",a.real),t=n.makeTensorInfo(l,"float32",a.imag),i=n.makeTensorInfo([],"float32",r.ZSL.createScalarValue(s,"float32")),o=(0,h.D)({inputs:{x:i},backend:n}),u=yt.kernelFunc({inputs:{a:e,b:i},backend:n}),c=yt.kernelFunc({inputs:{a:t,b:o},backend:n}),d=n.data.get(u.dataId).values,p=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),{real:d,imag:p}}return a}var l}function _t(e,t,n,s,a){if(1===n)return{real:e,imag:t};const i=r.backend_util.mergeRealAndImagArrays(e,t),o=n/2,l=r.backend_util.complexWithEvenIndex(i),u=l.real,c=l.imag,d=[u.length],h=a.makeTensorInfo(d,"float32",u),p=a.makeTensorInfo(d,"float32",c),f=(0,ye.f)({inputs:{real:h,imag:p},backend:a}),m=r.backend_util.complexWithOddIndex(i),g=m.real,b=m.imag,y=[g.length],w=a.makeTensorInfo(y,"float32",g),v=a.makeTensorInfo(y,"float32",b),x=(0,ye.f)({inputs:{real:w,imag:v},backend:a}),_=_t(u,c,o,s,a),k=_.real,S=_.imag,I=[k.length],E=a.makeTensorInfo(I,"float32",k),A=a.makeTensorInfo(I,"float32",S),C=(0,ye.f)({inputs:{real:E,imag:A},backend:a}),N=_t(g,b,o,s,a),$=N.real,O=N.imag,D=[$.length],F=a.makeTensorInfo(D,"float32",$),R=a.makeTensorInfo(D,"float32",O),M=(0,ye.f)({inputs:{real:F,imag:R},backend:a}),L=r.backend_util.exponents(n,s),P=[L.real.length],z=a.makeTensorInfo(P,"float32",L.real),B=a.makeTensorInfo(P,"float32",L.imag),V=(0,ye.f)({inputs:{real:z,imag:B},backend:a}),U=(0,Xe.lw)({inputs:{a:V,b:M},backend:a}),j=(0,T.WQ)({inputs:{a:C,b:U},backend:a}),W=(0,wt.jb)({inputs:{a:C,b:U},backend:a}),G=(0,ke.x)({inputs:{input:j},backend:a}),H=(0,ke.x)({inputs:{input:W},backend:a}),q=xe({inputs:{input:j},backend:a}),Z=xe({inputs:{input:W},backend:a}),K=Se({inputs:[G,H],backend:a,attrs:{axis:0}}),Y=Se({inputs:[q,Z],backend:a,attrs:{axis:0}}),X=a.data.get(K.dataId).values,Q=a.data.get(Y.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(Z),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(Y),{real:X,imag:Q}}const kt={kernelName:r.rGP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,a=r.ZSL.sizeFromShape(s.shape),i=s.shape[s.shape.length-1],o=I({inputs:{x:s},backend:n,attrs:{shape:[a/i,i]}}),l=vt(o,!1,n),u=I({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};function St(e){const{backend:t,attrs:n}=e,{shape:s,value:a,dtype:i}=n,o=i||r.ZSL.inferDtype(a),l=r.ZSL.getArrayFromDType(o,r.ZSL.sizeFromShape(s));return function(e,t,n){e.fill(t)}(l,a),t.makeTensorInfo(s,o,l)}const Tt={kernelName:r.SQl,backendName:"cpu",kernelFunc:St},It={kernelName:r.BxF,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,a=n,i=r.ZSL.getTypedArrayFromDType(s.dtype,r.ZSL.sizeFromShape(s.shape)),[o,l,u,c]=s.shape,d=a.data.get(s.dataId).values;for(let e=0;e<o;e++){const t=e*u*l*c;for(let e=0;e<l;e++){const n=e*(u*c);for(let e=0;e<u;e++){const r=e*c;for(let s=0;s<c;s++){const a=Math.round(u-e-1),o=t+n+r+s;let l=d[o];a>=0&&a<u&&(l=d[t+n+a*c+s]),i[o]=l}}}}return{dataId:a.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};var Et=n(4540),At=n(5781);const Ct={kernelName:r.aAr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=Ie({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=I({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=(0,T.WQ)({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=(0,T.WQ)({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=I({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=S(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=S(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}},Nt={kernelName:r.T7M,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=Ue({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=(0,T.WQ)({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=S(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var $t=n(2698);const Ot={kernelName:r.O4G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:a}=t,i=r.ZSL.sizeFromShape(s.shape),o=a.shape,l=o[o.length-1],[u,c,d,h]=r.backend_util.prepareAndValidate(s,a);if(0===c)return n.makeTensorInfo(u,s.dtype,[]);const p=n.data.get(a.dataId).values,f=n.bufferSync(s),m=(0,$t.q)(p,f,s.dtype,c,l,d,h,s.shape,i);return n.makeTensorInfo(u,s.dtype,m.values)}};var Dt=n(756);const Ft={kernelName:r.mxL,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,indices:o}=t,{axis:l,batchDims:u}=a;(0,s.C)([i,o],"gatherV2");const c=r.ZSL.parseAxisParam(l,i.shape)[0],d=n.data.get(o.dataId).values,h=i.shape[c];for(let e=0;e<d.length;++e){const t=d[e];r.ZSL.assert(t<=h-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${h-1}]`))}let p=u;null==u&&(p=0);const f=r.ZSL.sizeFromShape(o.shape),m=r.backend_util.segment_util.collectGatherOpShapeInfo(i,o,c,p),g=I({inputs:{x:i},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),b=I({inputs:{x:o},backend:n,attrs:{shape:[m.batchSize,f/m.batchSize]}}),y=[m.batchSize,m.outerSize,f/m.batchSize,m.sliceSize],w=n.bufferSync(b),v=n.bufferSync(g),x=(0,Dt.G)(v,w,y);return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),n.makeTensorInfo(m.outputShape,x.dtype,x.values)}};var Rt=n(2196),Mt=n(7758);const Lt={kernelName:r.OAQ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,a=r.ZSL.sizeFromShape(s.shape),i=s.shape[s.shape.length-1],o=I({inputs:{x:s},backend:n,attrs:{shape:[a/i,i]}}),l=vt(o,!0,n),u=I({inputs:{x:l},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}},Pt=(0,u.v)(r.gIW,(e=>Number.isFinite(e)?1:0),"bool"),zt={kernelName:r.gIW,backendName:"cpu",kernelFunc:Pt},Bt=(0,u.v)(r.E3$,(e=>Math.abs(e)===1/0?1:0),"bool"),Vt={kernelName:r.E3$,backendName:"cpu",kernelFunc:Bt},Ut=(0,u.v)(r.iPs,(e=>Number.isNaN(e)?1:0),"bool"),jt={kernelName:r.iPs,backendName:"cpu",kernelFunc:Ut};var Wt=n(8921),Gt=n(2578),Ht=n(4524);const qt={kernelName:r.mnI,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=(0,Ht.G)(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}};var Zt=n(7424);const Kt=(0,u.v)(r.Cg$,(e=>Math.log1p(e))),Yt={kernelName:r.Cg$,backendName:"cpu",kernelFunc:Kt},Xt=(0,m.Z)(((e,t)=>e&&t)),Qt=(0,Z.j)(r.RUm,Xt,null,"bool"),Jt={kernelName:r.RUm,backendName:"cpu",kernelFunc:Qt},en=(0,u.v)(r.nZd,(e=>e?0:1),"bool"),tn={kernelName:r.nZd,backendName:"cpu",kernelFunc:en},nn=(0,m.Z)(((e,t)=>e||t)),rn=(0,Z.j)(r.LXA,nn,null,"bool"),sn={kernelName:r.LXA,backendName:"cpu",kernelFunc:rn},an={kernelName:r.jM4,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=a;(0,s.C)(i,"LRN");const d=i.shape[3],h=d-1,p=n.data.get(i.dataId).values,f=r.ZSL.sizeFromShape(i.shape),m=new Float32Array(f);function g(e){const t=e%d;let n=e-t+Math.max(0,t-o);const r=e-t+Math.min(t+o,h);let s=0;for(;n<=r;n++){const e=p[n];s+=e*e}return s}for(let e=0;e<f;e++){const t=g(e),n=p[e]*Math.pow(l+u*t,-c);m[e]=n}return n.makeTensorInfo(i.shape,i.dtype,m)}},on={kernelName:r.ToN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,y:o,dy:l}=t,{depthRadius:u,bias:c,alpha:d,beta:h}=a;(0,s.C)(l,"LRNGrad");const p=r.ZSL.sizeFromShape(l.shape),f=l.shape[3],m=n.data.get(l.dataId).values,g=n.data.get(i.dataId).values,b=n.data.get(o.dataId).values,y=new Float32Array(p),w=p;for(let e=0;e<w;e++){const t=e%f,n=e-t+Math.max(0,t-u),r=e-t+Math.min(f,t+u+1);let s=0;for(let e=n;e<r;e++)s+=Math.pow(g[e],2);s=d*s+c;for(let t=n;t<r;t++){let n=-2*d*h*g[t]*b[e]/s;e===t&&(n+=Math.pow(s,-h)),n*=m[e],y[t]+=n}}return n.makeTensorInfo(l.shape,i.dtype,y)}};var ln=n(5221),un=n(2486);function cn(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{reductionIndices:o,keepDims:l}=a,u=n;let c=i.shape;const d=c.length,h=r.ZSL.parseAxisParam(o,c);let p=h;const f=r.backend_util.getAxesPermutation(p,d);let m=u.data.get(i.dataId).values;if(null!=f){const e=new Array(d);for(let t=0;t<e.length;t++)e[t]=c[f[t]];m=(0,un._)(m,c,i.dtype,f,e),p=r.backend_util.getInnerMostAxes(p.length,d),c=e}(0,s.C)(i,"max"),r.backend_util.assertAxesAreInnerMostDims("max",p,d);const[g,b]=r.backend_util.computeOutAndReduceShapes(c,p),y=r.ZSL.sizeFromShape(b),w=(0,ln.j)(m,y,g,i.dtype),v=u.write(w,g,i.dtype);let x=g;return l&&(x=r.backend_util.expandShapeToKeepDim(g,h)),{dataId:v,shape:x,dtype:i.dtype}}const dn={kernelName:r.VAI,backendName:"cpu",kernelFunc:cn};var hn=n(7720);const pn={kernelName:r.t3d,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t;(0,s.C)(i,"maxPool");const{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=a;r.ZSL.assert(r.backend_util.eitherStridesOrDilationsAreOne(l,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '1'`));const d=r.backend_util.computePool2DInfo(i.shape,o,l,1,u,c);let p;if(1===d.filterWidth&&1===d.filterHeight&&r.ZSL.arraysEqual(d.inShape,d.outShape))p=(0,h.D)({inputs:{x:i},backend:n});else{const e=n.data.get(i.dataId).values,t=r.ZSL.computeStrides(i.shape),s=ee(e,i.shape,i.dtype,t,d,"max");p=n.makeTensorInfo(d.outShape,i.dtype,s.values)}return p}},fn={kernelName:r.ySp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{filterSize:o,strides:l,pad:u,dimRoundingMode:c,dataFormat:d}=a;(0,s.C)(i,"maxPool3d");const h=r.backend_util.computePool3DInfo(i.shape,o,l,1,u,c,d),p=ne(n.data.get(i.dataId).values,i.shape,i.dtype,r.ZSL.computeStrides(i.shape),h,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}},mn={kernelName:r.cHb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,input:o}=t,{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=a;(0,s.C)([i,o],"maxPool3DGrad");const h=r.backend_util.computePool3DInfo(o.shape,l,u,1,c,d),p=function(e,t){const n=(0,r.ra8)(t.outShape,"int32"),s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left;for(let r=0;r<t.batchSize;++r)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*s-p;let w=y;for(;w<0;)w+=o;const v=Math.min(t.inDepth,c+y);for(let s=0;s<t.outHeight;++s){const c=s*a-f;let p=c;for(;p<0;)p+=l;const x=Math.min(t.inHeight,d+c);for(let a=0;a<t.outWidth;++a){const f=a*i-m;let _=f;for(;_<0;)_+=u;const k=Math.min(t.inWidth,h+f);let S=Number.NEGATIVE_INFINITY,T=-1;for(let t=w;t<v;t+=o){const n=t-y;for(let s=p;s<x;s+=l){const a=s-c;for(let i=_;i<k;i+=u){const o=i-f,l=e.get(r,t,s,i,g);l>=S&&(S=l,T=n*d*h+a*d+o)}}}n.set(T,r,b,s,a,g)}}}return n}(n.bufferSync(o),h),f=h.strideDepth,m=h.strideHeight,g=h.strideWidth,b=h.dilationDepth,y=h.dilationHeight,w=h.dilationWidth,v=h.effectiveFilterDepth,x=h.effectiveFilterHeight,_=h.effectiveFilterWidth,k=v-1-h.padInfo.front,S=_-1-h.padInfo.left,T=x-1-h.padInfo.top,I=(0,r.ra8)(o.shape,"float32"),E=n.bufferSync(i);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inDepth;++n)for(let r=0;r<h.inHeight;++r)for(let s=0;s<h.inWidth;++s){const a=n-k,i=r-T,o=s-S;let l=0;for(let n=0;n<v;n+=b){const r=(a+n)/f;if(!(r<0||r>=h.outDepth||Math.floor(r)!==r))for(let s=0;s<x;s+=y){const a=(i+s)/m;if(!(a<0||a>=h.outHeight||Math.floor(a)!==a))for(let i=0;i<_;i+=w){const u=(o+i)/g;if(u<0||u>=h.outWidth||Math.floor(u)!==u)continue;const c=v*x*_-1-p.get(e,r,a,u,t)===n*x*_+s*_+i?1:0;0!==c&&(l+=E.get(e,r,a,u,t)*c)}}}I.set(l,e,n,r,s,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},gn={kernelName:r.RXX,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:i,input:o,output:l}=t,u=o;(0,s.C)([o,l],"maxPoolGrad");const{filterSize:c,strides:d,pad:h,dimRoundingMode:p}=a,f=r.backend_util.computePool2DInfo(u.shape,c,d,1,h,p),m=n.data.get(u.dataId).values,g=(0,r.ra8)(f.outShape,u.dtype,te(m,u.shape,u.dtype,f).values),b=f.strideHeight,y=f.strideWidth,w=f.dilationHeight,v=f.dilationWidth,x=f.effectiveFilterHeight,_=f.effectiveFilterWidth,k=_-1-f.padInfo.left,S=x-1-f.padInfo.top,T=(0,r.ra8)(u.shape,"float32"),I=n.data.get(i.dataId).values,E=(0,r.ra8)(i.shape,"float32",I);for(let e=0;e<f.batchSize;++e)for(let t=0;t<f.inChannels;++t)for(let n=0;n<f.inHeight;++n)for(let r=0;r<f.inWidth;++r){const s=n-S,a=r-k;let i=0;for(let n=0;n<x;n+=w){const r=(s+n)/b;if(!(r<0||r>=f.outHeight||Math.floor(r)!==r))for(let s=0;s<_;s+=v){const o=(a+s)/y;if(o<0||o>=f.outWidth||Math.floor(o)!==o)continue;const l=x*_-1-g.get(e,r,o,t)===n*_+s?1:0;0!==l&&(i+=E.get(e,r,o,t)*l)}}T.set(i,e,n,r,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}},bn={kernelName:r.TL8,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:a}=e,{filterSize:i,strides:o,pad:l,includeBatchInIndex:u}=t,c=n;(0,s.C)(a,"MaxPoolWithArgmax");const d=c.data.get(a.dataId).values,h=r.backend_util.computePool2DInfo(a.shape,i,o,[1,1],l),[p,f]=function(e,t,n,s,a){const i=ee(e,0,n,r.ZSL.computeStrides(t),a,"max"),o=te(e,t,n,a,!0,s);return[i.values,o.values]}(d,a.shape,a.dtype,u,h),m=c.write(p,h.outShape,a.dtype),g=c.write(f,h.outShape,a.dtype);return[{dataId:m,shape:h.outShape,dtype:a.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}},yn={kernelName:r.g5A,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{axis:i,keepDims:o}=s,l=r.ZSL.parseAxisParam(i,a.shape),u=r.backend_util.computeOutAndReduceShapes(a.shape,l)[1],c=r.ZSL.sizeFromShape(u),d=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=(0,fe.wg)({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});d.push(p);const f=bt({inputs:{a:p,b:h},backend:n});d.push(f);const m=Je({inputs:{x:f},backend:n,attrs:{axis:i,keepDims:o}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}},wn={kernelName:r.lNG,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{axis:o,keepDims:l}=a;(0,s.C)(i,"min");const u=r.ZSL.parseAxisParam(o,i.shape);let c=u;const d=r.backend_util.getAxesPermutation(c,i.shape.length);let h=i;null!=d&&(h=(0,L.m)({inputs:{x:i},backend:n,attrs:{perm:d}}),c=r.backend_util.getInnerMostAxes(c.length,i.shape.length)),r.backend_util.assertAxesAreInnerMostDims("min",c,h.shape.length);const[p,f]=r.backend_util.computeOutAndReduceShapes(h.shape,c),m=r.ZSL.sizeFromShape(f),g=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(p),h.dtype),b=n.data.get(h.dataId).values;for(let e=0;e<g.length;++e){const t=e*m;let n=b[t];for(let e=0;e<m;++e){const r=b[t+e];(Number.isNaN(r)||r<n)&&(n=r)}g[e]=n}null!=d&&n.disposeIntermediateTensorInfo(h);const y=n.makeTensorInfo(p,h.dtype,g);if(l){const e=I({inputs:{x:y},backend:n,attrs:{shape:r.backend_util.expandShapeToKeepDim(p,u)}});return n.disposeIntermediateTensorInfo(y),e}return y}};var vn=n(5118);const xn={kernelName:r.x7F,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{paddings:o,mode:l}=a;(0,s.C)(i,"mirrorPad");const u=o.map(((e,t)=>e[0]+i.shape[t]+e[1])),c=o.map((e=>e[0])),d=o.map(((e,t)=>e[0]+i.shape[t])),h="reflect"===l?0:1,p=n.data.get(i.dataId).values,f=i.shape.length,m=r.ZSL.computeStrides(i.shape),g=r.ZSL.sizeFromShape(u),b=u.length,y=r.ZSL.computeStrides(u),w=r.ZSL.getTypedArrayFromDType(i.dtype,g);for(let e=0;e<g;e++){let t=r.ZSL.indexToLoc(e,b,y);for(let e=0;e<b;e++)t[e]<c[e]?t[e]=2*c[e]-t[e]-h:t[e]>=d[e]&&(t[e]=2*(d[e]-1)-t[e]+h);t=t.map(((e,t)=>e-c[t]));const n=r.ZSL.locToIndex(t,f,m);w[e]=p[n]}return{dataId:n.write(w,u,i.dtype),shape:u,dtype:i.dtype}}},_n=(0,m.Z)(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),kn=(0,Z.j)(r.BLA,_n),Sn={kernelName:r.BLA,backendName:"cpu",kernelFunc:kn};var Tn=n(8273);function In(e){const{inputs:t,backend:n,attrs:s}=e,{logits:a}=t,{dim:i}=s,o=a.shape.length;let l=i;if(-1===l&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const u=r.ZSL.parseAxisParam([l],a.shape),c=cn({inputs:{x:a},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),d=r.backend_util.expandShapeToKeepDim(c.shape,u),h=I({inputs:{x:c},backend:n,attrs:{shape:d}}),p=(0,wt.jb)({inputs:{a,b:h},backend:n}),f=(0,ht.oN)({inputs:{x:p},backend:n}),m=Je({inputs:{x:f},backend:n,attrs:{axis:u,keepDims:!1}}),g=I({inputs:{x:m},backend:n,attrs:{shape:d}}),b=bt({inputs:{a:f,b:g},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),b}const En={kernelName:r.rFG,backendName:"cpu",kernelFunc:In},An={kernelName:r.WT3,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:i}=t,{numSamples:o,seed:l,normalized:u}=a;(0,s.C)(i,"multinomial");const c=u?i:In({inputs:{logits:i},backend:n,attrs:{dim:-1}}),d=c.shape[0],h=c.shape[1],p=n.data.get(c.dataId).values,f=[d,o],m=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(f),"int32");for(let e=0;e<d;++e){const t=e*h,n=new Float32Array(h-1);n[0]=p[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+p[t+e];const r=Tn.alea(l.toString()),s=e*o;for(let e=0;e<o;++e){const t=r();m[s+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){m[s+e]=r;break}}}return u||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(f,"int32",m)}};var Cn=n(1536);const Nn=r.kpo.nonMaxSuppressionV3Impl,$n={kernelName:r.SDM,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=r;(0,s.C)(a,"NonMaxSuppression");const c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,{selectedIndices:h}=Nn(c,d,o,l,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},On=r.kpo.nonMaxSuppressionV4Impl,Dn={kernelName:r.Zl4,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:c}=r;(0,s.C)(a,"NonMaxSuppressionPadded");const d=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:p,validOutputs:f}=On(d,h,o,l,u,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},Fn=r.kpo.nonMaxSuppressionV5Impl,Rn={kernelName:r.e0f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=r;(0,s.C)(a,"NonMaxSuppressionWithScore");const d=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,p=o,f=l,m=u,g=c,{selectedIndices:b,selectedScores:y}=Fn(d,h,p,f,m,g);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};var Mn=n(6699);const Ln={kernelName:r.urI,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:i}=t,{dtype:o,depth:l,onValue:u,offValue:c}=a;(0,s.C)(i,"oneHot");const d=r.ZSL.sizeFromShape(i.shape),h=new Float32Array(d*l);h.fill(c);const p=n.data.get(i.dataId).values;for(let e=0;e<d;++e)p[e]>=0&&p[e]<l&&(h[e*l+p[e]]=u);return n.makeTensorInfo([...i.shape,l],o,h)}};function Pn(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=(0,ke.x)({inputs:{input:r},backend:n}),t=Pn({inputs:{x:e},backend:n}),s=xe({inputs:{input:r},backend:n}),a=Pn({inputs:{x:s},backend:n}),i=(0,ye.f)({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return St({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const zn={kernelName:r.xJ3,backendName:"cpu",kernelFunc:Pn},Bn={kernelName:r.LWX,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=(0,ke.x)({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=xe({inputs:{input:s},backend:r}),i=Pn({inputs:{x:a},backend:r}),o=(0,ye.f)({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return St({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function Vn(e){const{inputs:t,backend:n,attrs:s}=e,{axis:a}=s;if(1===t.length)return pt({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const i=t[0].shape,o=t[0].dtype;t.forEach((e=>{r.ZSL.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),r.ZSL.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const l=[],u=Se({inputs:t.map((e=>{const t=pt({inputs:{input:e},backend:n,attrs:{dim:a}});return l.push(t),t})),backend:n,attrs:{axis:a}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const Un={kernelName:r.mM$,backendName:"cpu",kernelFunc:Vn},jn={kernelName:r.ODT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{paddings:o,constantValue:l}=a;(0,s.C)(i,"pad");const u=o.map(((e,t)=>e[0]+i.shape[t]+e[1])),c=o.map((e=>e[0])),d=n.data.get(i.dataId).values,h=r.ZSL.sizeFromShape(i.shape),p=i.shape.length,f=r.ZSL.computeStrides(i.shape),m=r.ZSL.sizeFromShape(u),g=u.length,b=r.ZSL.computeStrides(u),y=r.ZSL.getTypedArrayFromDType(i.dtype,m);0!==l&&y.fill(l);for(let e=0;e<h;e++){const t=r.ZSL.indexToLoc(e,p,f).map(((e,t)=>e+c[t]));y[r.ZSL.locToIndex(t,g,b)]=d[e]}return{dataId:n.write(y,u,i.dtype),shape:u,dtype:i.dtype}}},Wn=(0,m.Z)(((e,t)=>Math.pow(e,t))),Gn=(0,Z.j)(r.pyJ,Wn),Hn={kernelName:r.pyJ,backendName:"cpu",kernelFunc:Gn};var qn=n(9045),Zn=n(2722);const Kn={kernelName:r.oJ2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.data.get(e.dataId).values)),u=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=(0,Zn.u)(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}};var Yn=n(2290);const Xn={kernelName:r.CQC,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=(0,Yn._)(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var Qn=n(2368);const Jn={kernelName:r.mH5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=(0,Qn.K)(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}};var er=n(9836);const tr={kernelName:r.Q6t,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=(0,er.q)(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},nr=(0,u.v)(r.huO,(e=>1/e)),rr={kernelName:r.huO,backendName:"cpu",kernelFunc:nr},sr={kernelName:r.hgw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:i}=t,{alignCorners:o,halfPixelCenters:l,size:u}=a;(0,s.C)(i,"resizeBilinear");const c=r.ZSL.computeStrides(i.shape),[d,h]=u,[p,f,m,g]=i.shape,b=n.data.get(i.dataId).values,y=new Float32Array(r.ZSL.sizeFromShape([p,d,h,g])),w=[o&&d>1?f-1:f,o&&h>1?m-1:m],v=[o&&d>1?d-1:d,o&&h>1?h-1:h];let x=0;const _=w[0]/v[0],k=w[1]/v[1];for(let e=0;e<p;e++)for(let t=0;t<d;t++){let n;n=l?_*(t+.5)-.5:_*t;const r=Math.max(0,Math.floor(n)),s=n-r,a=Math.min(f-1,Math.ceil(n)),i=e*c[0]+r*c[1],o=e*c[0]+a*c[1];for(let e=0;e<h;e++){let t;t=l?k*(e+.5)-.5:k*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(m-1,Math.ceil(t)),u=i+n*c[2],d=o+n*c[2],h=i+a*c[2],p=o+a*c[2];for(let e=0;e<g;e++){const t=b[u+e],n=b[d+e],a=t+(b[h+e]-t)*r,i=a+(n+(b[p+e]-n)*r-a)*s;y[x++]=i}}}return n.makeTensorInfo([p,d,h,g],"float32",y)}},ar={kernelName:r.FCQ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:i,dy:o}=t,{alignCorners:l}=a;(0,s.C)([o,i],"resizeBilinearGrad");const u=r.ZSL.computeStrides(i.shape),[c,d,h,p]=i.shape,[,f,m]=o.shape,g=new Float32Array(c*d*h*p),b=[l&&f>1?d-1:d,l&&m>1?h-1:h],y=[l&&f>1?f-1:f,l&&m>1?m-1:m],w=b[0]/y[0],v=b[1]/y[1],x=n.data.get(o.dataId).values;let _=0;for(let e=0;e<c;e++){const t=e*u[0];for(let e=0;e<f;e++){const n=e*w,r=Math.floor(n),s=Math.min(Math.ceil(n),d-1),a=t+r*u[1],i=t+s*u[1],o=n-r,l=1-o;for(let e=0;e<m;e++){const t=e*v,n=Math.floor(t),r=Math.min(Math.ceil(t),h-1),s=t-n,c=1-s,d=a+n*u[2],f=a+r*u[2],m=i+n*u[2],b=i+r*u[2],y=l*c,w=l*s,k=o*c,S=o*s;for(let e=0;e<p;e++){const t=x[_++];g[d+e]+=t*y,g[f+e]+=t*w,g[m+e]+=t*k,g[b+e]+=t*S}}}}return n.makeTensorInfo([c,h,d,p],"float32",g)}},ir={kernelName:r.jOE,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:i}=t,{alignCorners:o,halfPixelCenters:l,size:u}=a;(0,s.C)(i,"resizeNearestNeighbor");const c=r.ZSL.computeStrides(i.shape),[d,h]=u,[p,f,m,g]=i.shape,b=n.data.get(i.dataId).values,y=new Float32Array(p*d*h*g),w=[o&&d>1?f-1:f,o&&h>1?m-1:m],v=[o&&d>1?d-1:d,o&&h>1?h-1:h],x=w[0]/v[0],_=w[1]/v[1];let k=0;for(let e=0;e<p;e++){const t=e*c[0];for(let e=0;e<d;e++){const n=l?x*(e+.5):x*e;let r=Math.min(f-1,o?Math.round(n):Math.floor(n));l&&(r=Math.max(0,r));const s=t+r*c[1];for(let e=0;e<h;e++){const t=l?_*(e+.5):_*e;let n=Math.min(m-1,o?Math.round(t):Math.floor(t));l&&(n=Math.max(0,n));const r=s+n*c[2];for(let e=0;e<g;e++){const t=b[r+e];y[k++]=t}}}}return n.makeTensorInfo([p,d,h,g],i.dtype,y)}},or={kernelName:r.XQy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:i,dy:o}=t,{alignCorners:l}=a;(0,s.C)([o,i],"resizeNearestNeighborGrad");const u=r.ZSL.computeStrides(i.shape),c=r.ZSL.computeStrides(o.shape),[d,h,p,f]=i.shape,[,m,g]=o.shape,b=new Float32Array(d*h*p*f),y=n.data.get(o.dataId).values,w=[l&&m>1?h-1:h,l&&g>1?p-1:p],v=[l&&m>1?m-1:m,l&&g>1?g-1:g],x=w[0]/v[0],_=w[1]/v[1],k=1/x,S=1/_,T=2*Math.ceil(k)+2,I=2*Math.ceil(S)+2;for(let e=0;e<d;e++){const t=e*u[0];for(let e=0;e<h;e++){const n=t+e*u[1],r=Math.floor(e*k),s=Math.floor(r-T/2);for(let r=0;r<p;r++){const a=n+r*u[2],i=Math.floor(r*S),o=Math.floor(i-I/2);for(let n=0;n<f;n++){let i=0;for(let a=0;a<T;a++){const u=a+s;if(u<0||u>=m)continue;const d=t+u*c[1],f=u*x;if(e===Math.min(h-1,l?Math.round(f):Math.floor(f)))for(let e=0;e<I;e++){const t=e+o;if(t<0||t>=g)continue;const s=d+t*c[2],a=t*_;r===Math.min(p-1,l?Math.round(a):Math.floor(a))&&(i+=y[s+n])}}b[a+n]=i}}}}return n.makeTensorInfo(i.shape,i.dtype,b)}},lr={kernelName:r.D7i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{dims:o}=a;(0,s.C)(i,"reverse");const l=i.shape.length,u=r.ZSL.parseAxisParam(o,i.shape);if(0===l)return(0,h.D)({inputs:{x:i},backend:n});const c=new r.ylz(i.shape,i.dtype),d=n.bufferSync(i);for(let e=0;e<c.size;e++){const t=c.indexToLoc(e),n=t.slice();u.forEach((e=>n[e]=i.shape[e]-1-n[e])),c.set(d.get(...n),...t)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},ur={kernelName:r.BK4,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:a,fillValue:i,center:o}=t,l=n,u=r.ZSL.getTypedArrayFromDType(s.dtype,r.ZSL.sizeFromShape(s.shape)),[c,d,h,p]=s.shape,[f,m]=r.backend_util.getImageCenter(o,d,h),g=Math.sin(a),b=Math.cos(a),y=l.data.get(s.dataId).values;for(let e=0;e<c;e++){const t=e*h*d*p;for(let e=0;e<d;e++){const n=e*(h*p);for(let r=0;r<h;r++){const s=r*p;for(let a=0;a<p;a++){const o=[c,e,r,a],l=o[2],w=o[1];let v=(l-f)*b-(w-m)*g,x=(l-f)*g+(w-m)*b;v=Math.round(v+f),x=Math.round(x+m);let _=i;"number"!=typeof i&&(_=3===a?255:i[a]),v>=0&&v<h&&x>=0&&x<d&&(_=y[t+x*(h*p)+v*p+a]),u[t+n+s+a]=_}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},cr=(0,u.v)(r.hVg,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),dr={kernelName:r.hVg,backendName:"cpu",kernelFunc:cr};var hr=n(8830),pr=n(2217);const fr={kernelName:r.pJc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:a,updates:i}=t,{shape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=r.backend_util.calculateShapes(i,a,o),p=n.bufferSync(a),f=n.bufferSync(i),m=(0,pr.b)(p,f,o,h,c,u,l,d,0,!0);return n.makeTensorInfo(o,m.dtype,m.values)}};function mr(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function gr(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const br={kernelName:r.uWl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sortedSequence:a,values:i}=t,{side:o}=s,l=function(e,t,n,s,a,i){const o=r.ZSL.getArrayFromDType("int32",n*a);for(let r=0;r<n;++r){const n=e.slice(r*s,(r+1)*s),l=r*a;for(let e=0;e<a;++e)o[l+e]="left"===i?mr(n,t[e+l]):gr(n,t[e+l])}return o}(n.data.get(a.dataId).values,n.data.get(i.dataId).values,a.shape[0],a.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",l)}},yr={kernelName:r.l6P,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:i,e:o}=t;(0,s.C)([a,i,o],"select");const l=a.shape.length,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values,h=(0,r.TuY)(i.dtype,o.dtype),p=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(i.shape),h);let f=0;const m=0===l||l>1||1===i.shape.length?1:r.ZSL.sizeFromShape(i.shape.slice(1));for(let e=0;e<u.length;e++)for(let t=0;t<m;t++)1===u[e]?p[f++]=c[e]:p[f++]=d[e];return n.makeTensorInfo(i.shape,h,p)}},wr=r.backend_util.SELU_SCALEALPHA,vr=r.backend_util.SELU_SCALE,xr=(0,u.v)(r.u$b,(e=>e>=0?vr*e:wr*(Math.exp(e)-1))),_r={kernelName:r.u$b,backendName:"cpu",kernelFunc:xr},kr=(0,u.v)(r.YVe,(e=>e<0?-1:e>0?1:0)),Sr={kernelName:r.YVe,backendName:"cpu",kernelFunc:kr},Tr=(0,u.v)(r.hql,(e=>Math.sin(e))),Ir={kernelName:r.hql,backendName:"cpu",kernelFunc:Tr},Er=(0,u.v)(r.J3C,(e=>Math.sinh(e))),Ar={kernelName:r.J3C,backendName:"cpu",kernelFunc:Er},Cr=Math.log(1.1920928955078125e-7)+2,Nr=(0,u.v)(r.Fin,(e=>{const t=e>-Cr,n=e<Cr,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),$r={kernelName:r.Fin,backendName:"cpu",kernelFunc:Nr},Or={kernelName:r.A8B,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{blockShape:o,paddings:l}=a;(0,s.C)([i],"spaceToBatchND");const u=r.ZSL.sizeFromShape(o),c=[[0,0]];c.push(...l);for(let e=1+o.length;e<i.shape.length;++e)c.push([0,0]);const d=jn.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:c,constantValue:0}}),h=r.backend_util.getReshaped(d.shape,o,u,!1),p=r.backend_util.getPermuted(h.length,o.length,!1),f=r.backend_util.getReshapedPermuted(d.shape,o,u,!1),m=I({inputs:{x:d},backend:n,attrs:{shape:h}}),g={x:m},b={perm:p},y=(0,L.m)({inputs:g,backend:n,attrs:b}),w=I({inputs:{x:y},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),w}};var Dr=n(3846);const Fr={kernelName:r.C8s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=(0,Dr.y)(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var Rr=n(3741);const Mr={kernelName:r.BoJ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=(0,Rr.l)(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}};var Lr=n(2999);const Pr={kernelName:r.L6G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=(0,Lr.z)(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},zr={kernelName:r.DvZ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=(0,Lr.z)(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},Br={kernelName:r.jgd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:a,sparseValues:i,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=r.backend_util.calculateShapes(i,a,l),f=!1,m=n.bufferSync(a);let g;switch(i.dtype){case"bool":{const e=n.bufferSync(i),t=Boolean(n.data.get(o.dataId).values[0]);g=(0,pr.b)(m,e,l,p,d,c,u,h,t,f);break}case"float32":{const e=n.bufferSync(i),t=n.data.get(o.dataId).values[0];g=(0,pr.b)(m,e,l,p,d,c,u,h,t,f);break}case"int32":{const e=n.bufferSync(i),t=n.data.get(o.dataId).values[0];g=(0,pr.b)(m,e,l,p,d,c,u,h,t,f);break}case"string":{const e=n.bufferSync(i),t=r.ZSL.decodeString(n.data.get(o.dataId).values[0]);g=(0,pr.b)(m,e,l,p,d,c,u,h,t,f);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(l,g.dtype,g.values)}},Vr={kernelName:r.Blb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:a}=t,{numOrSizeSplits:i,axis:o}=s,l=r.ZSL.parseAxisParam(o,a.shape)[0],u=r.backend_util.prepareSplitSize(a,i,l),c=new Array(a.shape.length).fill(0),d=a.shape.slice();return u.map((e=>{const t=[...d];t[l]=e;const r=(0,le.di)({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[l]+=e,r}))}};var Ur=n(6086);const jr={kernelName:r.M6A,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;(0,s.C)(n,"square");const a=r.data.get(n.dataId).values,i=new Float32Array(a.length);for(let e=0;e<a.length;++e){const t=a[e];i[e]=t*t}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Wr=n(8144),Gr=n(6771);const Hr=(0,u.v)(r.pnw,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),qr={kernelName:r.pnw,backendName:"cpu",kernelFunc:Hr};var Zr=n(5840);const Kr={kernelName:r.UcO,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i}=t,{begin:o,end:l,strides:u,beginMask:c,endMask:d,ellipsisMask:h,newAxisMask:p,shrinkAxisMask:f}=a;(0,s.C)(i,"stridedSlice");const{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:y,isSimpleSlice:w,begin:v,end:x,strides:_}=r.Kro.sliceInfo(i.shape,o,l,u,c,d,h,p,f);let k;if(b)k=I({inputs:{x:i},backend:n,attrs:{shape:g}});else if(y||w){r.ZSL.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const e=r.Kro.computeOutShape(v,x,_),t=(0,le.di)({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});k=I({inputs:{x:t},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(t)}else{const e=n.bufferSync(i),t=(0,Zr.e)(m,e,_,v);k=n.makeTensorInfo(g,t.dtype,t.values)}return k}};var Yr=n(1980);const Xr={kernelName:r.YAb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=(0,Yr.G)(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var Qr=n(1038);const Jr={kernelName:r.iW0,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=(0,Qr.S)(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var es=n(7429);const ts={kernelName:r.$jE,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=(0,es.f)(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},ns=(0,u.v)(r.oFs,(e=>Math.tan(e))),rs={kernelName:r.oFs,backendName:"cpu",kernelFunc:ns},ss=(0,u.v)(r.iuW,(e=>Math.tanh(e))),as={kernelName:r.iuW,backendName:"cpu",kernelFunc:ss},is={kernelName:r.X4r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=r.backend_util.calculateShapes(i,a,s.shape),h=n.bufferSync(a),p=n.bufferSync(i),f=n.bufferSync(s),m=(0,pr.b)(h,p,s.shape,d,u,l,o,c,f,!1);return n.makeTensorInfo(s.shape,m.dtype,m.values)}};var os=n(9009);const ls={kernelName:r.FAs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;(0,s.C)(a,"tile");const o=(0,os.D)(n.bufferSync(a),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}};var us=n(8749);const cs={kernelName:r.TBb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:o}=r;(0,s.C)(a,"topk");const l=n.data.get(a.dataId).values,[u,c]=(0,us.x)(l,a.shape,a.dtype,i,o);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}},ds={kernelName:r.dLy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{image:a,transforms:i}=t,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=n,[d,h,p,f]=a.shape,[m,g]=null!=c?c:[h,p],b=[d,m,g,f],y=r.ZSL.computeStrides(a.shape),w=y[0],v=y[1],x=y[2],_=r.ZSL.computeStrides(b),k=_[0],S=_[1],T=_[2],I=r.ZSL.getTypedArrayFromDType(a.dtype,r.ZSL.sizeFromShape(b));I.fill(u);const E=s.data.get(a.dataId).values,A=s.data.get(i.dataId).values;for(let e=0;e<d;++e){const t=1===i.shape[0]?A:A.subarray(8*e,8*e+8);for(let n=0;n<m;++n)for(let r=0;r<g;++r)for(let s=0;s<f;++s){let a;const i=t[6]*r+t[7]*n+1;if(0===i)continue;const c=(t[0]*r+t[1]*n+t[2])/i,d=(t[3]*r+t[4]*n+t[5])/i,f=hs(c,p,l),m=hs(d,h,l);switch(o){case"nearest":a=fs(E,h,p,w,v,x,e,m,f,s,u);break;case"bilinear":a=ms(E,h,p,w,v,x,e,m,f,s,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}I[e*k+n*S+r*T+s]=a}return s.makeTensorInfo(b,a.dtype,I)}return{dataId:s.write(I,b,a.dtype),shape:a.shape,dtype:a.dtype}}};function hs(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return r.ZSL.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return r.ZSL.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return r.ZSL.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function ps(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function fs(e,t,n,r,s,a,i,o,l,u,c){return ps(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function ms(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*ps(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*ps(e,t,n,r,s,a,i,d,f,u,c))+(o-d)*((f-l)*ps(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*ps(e,t,n,r,s,a,i,p,f,u,c))}var gs=n(1700);const bs={kernelName:r.EwU,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;(0,s.C)(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:l,outputShape:u,indices:c}=(0,gs.w)(o,a,i.shape,i.dtype);return[r.makeTensorInfo(u,i.dtype,l),r.makeTensorInfo([c.length],"int32",c)]}},ys={kernelName:r.dXR,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let e=0;e<i;e++)e!==a&&(l[u++]=s.shape[e]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let e=0;e<h.length;e++){c[a]=e;const t=(0,le.di)({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[e]=I({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return h}},ws={kernelName:r.pPe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:i,segmentIds:o}=t,{numSegments:l}=a;(0,s.C)(i,"unsortedSegmentSum");const u=[],c=[],d=i.shape.length-o.shape.length;let h=o;for(let e=0;e<d;++e){const t=pt({inputs:{input:h},backend:n,attrs:{dim:e+1}});h=t,c.push(t)}for(let e=0;e<l;++e){const t=r.ZSL.createScalarValue(e,"int32"),s=n.makeTensorInfo([],"int32",t),a=(0,rt.LC)({inputs:{a:s,b:h},backend:n}),o=(0,fe.wg)({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=(0,Xe.lw)({inputs:{a:o,b:i},backend:n}),d=Je({inputs:{x:l},backend:n,attrs:{axis:0,keepDims:!1}});u.push(d),c.push(s),c.push(a),c.push(o),c.push(l),c.push(d)}const p=Vn({inputs:u,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},vs=[N,$.lO,D,R,T.UK,M,P,z,B,V,j,G,q,X,J,re,se,ae,ie,C,oe,ue,de,he.LY,pe,fe.Ml,me.uf,be,ye.v,we,Te,Ee,Ae,Ce,Ne,$e,Oe,Fe,Me,Le,Pe,ze,Be,Ve,je,We,Ge,He,qe,Ze,Ke,Ye,tt,d,nt,rt.RY,dt,ht.AC,ft,mt.Yp,kt,Tt,It,Et.Hc,At.Uc,Ct,Nt,Ot,Ft,Rt.xp,Mt.VM,h.F,Lt,_e,zt,Vt,jt,f,Wt.YW,Gt.Q,qt,Zt.Fx,Yt,Jt,tn,sn,an,on,dn,hn.l9,pn,fn,mn,gn,bn,yn,wn,vn.Nu,xn,Sn,An,Xe.tJ,Cn.hd,$n,Dn,Rn,Mn.AL,Ln,Bn,Un,jn,Hn,y,qn.S3,Kn,Xn,Jn,tr,ke.r,yt,rr,v,_,E,sr,ar,ir,or,lr,ur,dr,hr.Lt,fr,br,yr,_r,k.X3,Sr,Ir,Ar,le.lv,En,$r,Or,Fr,Mr,Pr,zr,Br,Vr,Ur.Fu,jr,Wr.b2,Gr.C,qr,Kr,Xr,Jr,ts,wt.Zl,et,rs,as,is,ls,cs,ds,L.W,bs,ys,ws,zn];for(const e of vs)(0,r.tAK)(e)},574:(e,t,n)=>{"use strict";n.d(t,{dH:()=>a,lO:()=>i});var r=n(1592),s=n(3132);function a(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const i={kernelName:r.ljI,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;(0,s.C)(t,"abs");let i=new Float32Array(r.ZSL.sizeFromShape(t.shape));return i=a(n.data.get(t.dataId).values),n.makeOutput(i,t.shape,t.dtype)}}},161:(e,t,n)=>{"use strict";n.d(t,{UK:()=>u,WQ:()=>l,mx:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e+t)),o=(0,a.B)(((e,t,n,r)=>({real:e+n,imag:t+r}))),l=(0,a.j)(r.OMN,i,o),u={kernelName:r.OMN,backendName:"cpu",kernelFunc:l}},441:(e,t,n)=>{"use strict";n.d(t,{N:()=>a,X:()=>s});var r=n(1592);function s(e,t,n,s,a){const i=r.ZSL.sizeFromShape(s),o=r.ZSL.makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=a||(o[r]+=i>0?t[n]:1)}return o}function a(e,t,n,s=!1){const a=e.shape[0],i=e.shape[1],o=(0,r.ra8)([a,n],t.dtype);for(let r=0;r<a;r++)for(let a=0;a<i;a++){const i=e.get(r,a);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(s?o.set(1,r,i):t.size>0?o.set(o.get(r,i)+t.get(r,a),r,i):o.set(o.get(r,i)+1,r,i))}return o}},7540:(e,t,n)=>{"use strict";n.d(t,{LY:()=>l,f6:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e&t)),o=(0,a.j)(r.HNs,i),l={kernelName:r.HNs,backendName:"cpu",kernelFunc:o}},6051:(e,t,n)=>{"use strict";n.d(t,{Ml:()=>d,ct:()=>u,wg:()=>c});var r=n(1592),s=n(3957),a=n(2959),i=n(6154),o=n(3422),l=n(9828);function u(e,t,n,a){if("int32"===a)return[t,"int32",Int32Array.from(e)];if("bool"===a){const a=r.ZSL.toTypedArray([0],n),[i,o]=(0,s.Z)(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function c(e){const{inputs:t,backend:n,attrs:s}=e,{x:d}=t,{dtype:h}=s;if("complex64"===h){if("complex64"===d.dtype)return(0,o.D)({inputs:{x:d},backend:n});const e=(0,a.U)(n,d.shape,d.dtype),t=c({inputs:{x:d},backend:n,attrs:{dtype:"float32"}}),r=(0,i.f)({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===d.dtype){const e=(0,l.x)({inputs:{input:d},backend:n}),t=c({inputs:{x:e},backend:n,attrs:{dtype:h}});return n.disposeIntermediateTensorInfo(e),t}if(!r.ZSL.hasEncodingLoss(d.dtype,h)){const e=(0,o.D)({inputs:{x:d},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:h}}const p=n.data.get(d.dataId).values,[f,m,g]=u(p,d.shape,d.dtype,h);return n.makeTensorInfo(f,m,g)}const d={kernelName:r.KXH,backendName:"cpu",kernelFunc:c}},6725:(e,t,n)=>{"use strict";n.d(t,{YG:()=>i,uf:()=>l});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>Math.ceil(e))),o=(0,a.F)(r.QDP,i),l={kernelName:r.QDP,backendName:"cpu",kernelFunc:o}},6154:(e,t,n)=>{"use strict";function r(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}n.d(t,{f:()=>r,v:()=>s});const s={kernelName:n(1592).pr3,backendName:"cpu",kernelFunc:r}},3053:(e,t,n)=>{"use strict";n.d(t,{h:()=>s});var r=n(1592);function s(e,t,n,s){const a=r.ZSL.getArrayFromDType(n,r.ZSL.sizeFromShape(t));if(s&&"string"!==n){let t=0;e.forEach((e=>{const n=r.ZSL.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let s=0;e.forEach((e=>{const i="string"===n?r.backend_util.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const r=n*t[1]+s;for(let t=0;t<e.shape[1];++t)a[r+t]=i[o++]}s+=e.shape[1]}))}return a}},5309:(e,t,n)=>{"use strict";n.d(t,{LC:()=>o,RY:()=>l,z3:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e===t?1:0)),o=(0,a.j)(r.BRl,i,null,"bool"),l={kernelName:r.BRl,backendName:"cpu",kernelFunc:o}},9077:(e,t,n)=>{"use strict";n.d(t,{AC:()=>l,oN:()=>o,sG:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>Math.exp(e))),o=(0,a.F)(r.ox3,i,"float32"),l={kernelName:r.ox3,backendName:"cpu",kernelFunc:o}},4115:(e,t,n)=>{"use strict";n.d(t,{Yp:()=>l,uM:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>Math.expm1(e))),o=(0,a.F)(r.ybj,i),l={kernelName:r.ybj,backendName:"cpu",kernelFunc:o}},4540:(e,t,n)=>{"use strict";n.d(t,{Hc:()=>l,vS:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>Math.floor(e))),o=(0,a.F)(r.ZgB,i),l={kernelName:r.ZgB,backendName:"cpu",kernelFunc:o}},5781:(e,t,n)=>{"use strict";n.d(t,{C1:()=>i,Uc:()=>l});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>Math.floor(e/t))),o=(0,a.j)(r.ElG,i,null,"int32"),l={kernelName:r.ElG,backendName:"cpu",kernelFunc:o}},2698:(e,t,n)=>{"use strict";n.d(t,{q:()=>s});var r=n(1592);function s(e,t,n,s,a,i,o,l,u){const c=(0,r.ra8)([s,i],n);for(let n=0;n<s;n++){const r=[];let s=0;for(let t=0;t<a;t++){const i=e[n*a+t];s+=i*o[t],r.push(i)}if(s<0||s>=u/i)throw new Error(`Invalid indices: ${r} does not index into ${l}`);for(let e=0;e<i;e++)c.values[n*i+e]=t.get(...t.indexToLoc(s*i+e))}return c}},756:(e,t,n)=>{"use strict";n.d(t,{G:()=>s});var r=n(1592);function s(e,t,n){const s=(0,r.ra8)(n,e.dtype);for(let n=0;n<s.size;++n){const r=s.indexToLoc(n).slice(),a=r[0],i=r[2],o=t.locToIndex([a,i]);r[2]=t.values[o];const l=e.locToIndex(r);0<=l&&l<e.values.length&&(s.values[n]=e.values[l])}return s}},2196:(e,t,n)=>{"use strict";n.d(t,{rq:()=>i,xp:()=>l});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e>t?1:0)),o=(0,a.j)(r.XhZ,i,null,"bool"),l={kernelName:r.XhZ,backendName:"cpu",kernelFunc:o}},7758:(e,t,n)=>{"use strict";n.d(t,{VM:()=>l,lg:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e>=t?1:0)),o=(0,a.j)(r.lLS,i,null,"bool"),l={kernelName:r.lLS,backendName:"cpu",kernelFunc:o}},3422:(e,t,n)=>{"use strict";function r(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}n.d(t,{D:()=>r,F:()=>s});const s={kernelName:n(1592).lzr,backendName:"cpu",kernelFunc:r}},8921:(e,t,n)=>{"use strict";n.d(t,{WR:()=>i,YW:()=>l});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e<t?1:0)),o=(0,a.j)(r.mIA,i,null,"bool"),l={kernelName:r.mIA,backendName:"cpu",kernelFunc:o}},2578:(e,t,n)=>{"use strict";n.d(t,{Q:()=>l,cu:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e<=t?1:0)),o=(0,a.j)(r.CwD,i,null,"bool"),l={kernelName:r.CwD,backendName:"cpu",kernelFunc:o}},4524:(e,t,n)=>{"use strict";n.d(t,{G:()=>s});var r=n(1592);function s(e,t,n){const s=(t-e)/(n-1),a=r.ZSL.makeZerosTypedArray(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+s;return a}},7424:(e,t,n)=>{"use strict";n.d(t,{Fx:()=>l,px:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>Math.log(e))),o=(0,a.F)(r.tG8,i),l={kernelName:r.tG8,backendName:"cpu",kernelFunc:o}},5221:(e,t,n)=>{"use strict";n.d(t,{j:()=>s});var r=n(1592);function s(e,t,n,s){const a=r.ZSL.getTypedArrayFromDType(s,r.ZSL.sizeFromShape(n));for(let n=0;n<a.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}a[n]=s}return a}},7720:(e,t,n)=>{"use strict";n.d(t,{He:()=>i,l9:()=>l});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>Math.max(e,t))),o=(0,a.j)(r.LDN,i),l={kernelName:r.LDN,backendName:"cpu",kernelFunc:o}},5118:(e,t,n)=>{"use strict";n.d(t,{Nu:()=>l,hE:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>Math.min(e,t))),o=(0,a.j)(r.LG0,i),l={kernelName:r.LG0,backendName:"cpu",kernelFunc:o}},4160:(e,t,n)=>{"use strict";n.d(t,{BF:()=>i,lw:()=>l,tJ:()=>u});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e*t)),o=(0,a.B)(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),l=(0,a.j)(r.xu7,i,o),u={kernelName:r.xu7,backendName:"cpu",kernelFunc:l}},1536:(e,t,n)=>{"use strict";n.d(t,{Dk:()=>i,hd:()=>o});var r=n(1592),s=n(3132),a=n(4160);function i(e,t,n){const s=r.ZSL.createScalarValue(-1,n);return(0,a.BF)([],t,s,e,n)}const o={kernelName:r.l0G,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;(0,s.C)(r,"neg");const a=n.data.get(r.dataId).values,[o,l]=i(a,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,o)}}},6699:(e,t,n)=>{"use strict";n.d(t,{AL:()=>l,cl:()=>i});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e!==t?1:0)),o=(0,a.j)(r.ylV,i,null,"bool"),l={kernelName:r.ylV,backendName:"cpu",kernelFunc:o}},9045:(e,t,n)=>{"use strict";n.d(t,{S3:()=>o,_B:()=>i});var r=n(1592),s=n(3132),a=n(4425);function i(e,t,n,s){const[a,i]=r.backend_util.computeOutAndReduceShapes(e,s),o=(0,r.TuY)(t,"int32"),l=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(a),o),u=r.ZSL.sizeFromShape(i);for(let e=0;e<l.length;++e){const t=e*u;let r=1;for(let e=0;e<u;++e)r*=n[t+e];l[e]=r}return{outVals:l,outShape:a,outDtype:o}}const o={kernelName:r.kdj,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:l}=t,{axis:u,keepDims:c}=o;(0,s.C)(l,"prod");const d=l.shape.length,h=r.ZSL.parseAxisParam(u,l.shape),p=r.backend_util.getAxesPermutation(h,d);let f=h,m=l;const g=[];null!=p&&(m=(0,a.m)({inputs:{x:l},backend:n,attrs:{perm:p}}),g.push(m),f=r.backend_util.getInnerMostAxes(f.length,d));const b=n.data.get(m.dataId).values,{outVals:y,outShape:w,outDtype:v}=i(m.shape,m.dtype,b,f);let x=w;return c&&(x=r.backend_util.expandShapeToKeepDim(w,h)),g.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(x,v,y)}}},2722:(e,t,n)=>{"use strict";n.d(t,{u:()=>a});var r=n(1592);function s(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function a(e,t,n,a,i,o,l,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,s)=>{if(e<0||e>=n){const a=r.ZSL.indexToLoc(s,t.length,r.ZSL.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(o,l,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:d,valueSlices:h,numValues:p}=function(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let e=0;e<t.length-1;++e){l*=t[e];const n=t[e+1];for(let t=1;t<l+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],l=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[i];for(let e=i;e<l;++e)o[s].push(r[e+1]+t)}i=r[i],l=r[l]}l!==i&&(s.push([i,l]),a+=l-i)}return{outSplits:o,valueSlices:s,numValues:a}}(o,l,e,c),f=function(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,a=r.ZSL.getArrayFromDType("int32",s);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(d),m=function(e,t,n,a,i){const o=t.slice();o[0]=i;const l=r.ZSL.getArrayFromDType(n,r.ZSL.sizeFromShape(o)),u=e.length;return function(e,t,n,r,a,i){const o=s(t,2)[1],l=s(i,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)a[u*l+t]=e[n*o+t];++u}}(e,t,a,0===u?0:u/t[0],l,o),[l,o]}(n,a,i,h,p);return[f,m[0],m[1]]}},2290:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var r=n(1592);const s=2147483647;function a(e,t,n,a,i,o,l){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(l.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,c=0===i.length,d=0===l.length,h=[];u||h.push(t[0]),c||h.push(i[0]),d||h.push(l[0]);for(let e=1;e<h.length;++e)if(h[e]!==h[e-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===h.length?1:h[0],f=r.ZSL.getArrayFromDType("int32",p+1);f[0]=0;for(let t=0;t<p;++t){const n=u?e[0]:e[t],r=c?a[0]:a[t],i=d?o[0]:o[t];if(0===i)throw new Error("Requires delta != 0");let l;if(i>0&&r<n||i<0&&r>n)l=0;else if(l=Math.ceil(Math.abs((r-n)/i)),l>s)throw new Error(`Requires ((limit - start) / delta) <= ${s}`);f[t+1]=f[t]+l}const m=f[p],g=r.ZSL.getArrayFromDType(n,m);let b=0;for(let t=0;t<p;++t){const n=f[t+1]-f[t];let r=u?e[0]:e[t];const s=d?o[0]:o[t];for(let e=0;e<n;++e)g[b++]=r,r+=s}return[f,g]}},2368:(e,t,n)=>{"use strict";n.d(t,{K:()=>l});var r=n(1592),s=r.backend_util.RowPartitionType;class a{constructor(e,t,n,s,a,i,o,l,u,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=r.backend_util.getRowPartitionTypesHelper(c),this.raggedRank=r.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===s.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===s.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case s.VALUE_ROWIDS:return a.getMaxWidthValueRowID(t);case s.ROW_SPLITS:return a.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${s[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return o(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;r.backend_util.validateDefaultValueShape(n,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=r.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,s,t);a[0]<0&&(a[0]=e);for(let e=1;e<=this.raggedRank;++e)a[e]<0&&(a[e]=this.getMaxWidth(e));return a}calculateFirstParentOutputIndex(e,t,n){const s=Math.min(e,n),a=[];let i=0;for(let e=0;e<s;++e,i+=t)a.push(i);for(let t=s;t<e;++t)a.push(-1);return r.ZSL.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case s.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case s.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${s[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case s.FIRST_DIM_SIZE:return e[0];case s.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case s.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${s[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const s=o(t,!1),a=r.ZSL.getArrayFromDType(this.valuesDType,r.ZSL.sizeFromShape(s));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)r=this.calculateOutputIndex(e-1,r,n[e],t[e]);this.setOutput(this.raggedRank,r,a,s)}return[s,a]}setOutput(e,t,n,s){if(0===n.length)return;const a=this.values,o=n;let l=s.slice();l=l.slice(e+1);const u=r.ZSL.sizeFromShape(l),c=t.length;let d=this.defaultValue;if(d.length!==u&&1!==d.length){const e=this.defaultValueShape;(0,r.DZQ)((()=>{const t=(0,r.tQQ)(d,e),n=(0,r.hOW)(t,l);d=n.dataSync()}))}let h=0,p=0,f=0;for(let e=0;e<=c;++e){let r=e<c?t[e]:-1;if(r!==f){if(p<f){const e=a.subarray(h*u);i(o.subarray(p*u),e,(f-p)*u)}if(e>=c){const e=n.length;r=Math.floor(e/u)}if(r>f)if(1===this.defaultValue.length)o.subarray(f*u,r*u).fill(this.defaultValue[0]),f=r;else for(;r>f;)i(o.slice(f*u),d,u),++f;r<0?(h=e+1,p=f):(h=e,p=f,f=p+1)}else++f}}}function i(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function o(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function l(e,t,n,r,s,i,o,l,u,c){return new a(e,t,n,r,s,i,o,l,u,c).compute()}},9836:(e,t,n)=>{"use strict";n.d(t,{q:()=>s});var r=n(1592);function s(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return r.ZSL.makeZerosTypedArray(0,s);const a=Math.abs(Math.ceil((t-e)/n)),i=r.ZSL.makeZerosTypedArray(a,s);t<e&&1===n&&(n=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+n;return i}},9828:(e,t,n)=>{"use strict";function r(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}n.d(t,{r:()=>s,x:()=>r});const s={kernelName:n(1592).LRy,backendName:"cpu",kernelFunc:r}},8830:(e,t,n)=>{"use strict";n.d(t,{Lt:()=>l,Zy:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>1/Math.sqrt(e))),o=(0,a.F)(r.TOR,i),l={kernelName:r.TOR,backendName:"cpu",kernelFunc:o}},2217:(e,t,n)=>{"use strict";n.d(t,{b:()=>s});var r=n(1592);function s(e,t,n,s,a,i,o,l,u,c){const d=[s/a,a],h=e.values,p=t.values;if(0===s)return(0,r.ra8)(n,t.dtype);const f=u instanceof r.ylz?u:(0,r.ra8)(d,t.dtype);"string"==typeof u||"number"==typeof u?f.values.fill(u):"boolean"==typeof u&&f.values.fill(+u);for(let e=0;e<i;e++){const r=[];let i=0;for(let t=0;t<o;t++){const n=h[e*o+t];r.push(n),i+=n*l[t]}if(i<0||i>=s/a)throw new Error(`Invalid indices: ${r} does not index into ${n}`);for(let n=0;n<a;n++)c?f.values[i*a+n]+=p[e*a+n]:f.values[i*a+n]=0===t.rank?p[0]:p[e*a+n]}return f}},5834:(e,t,n)=>{"use strict";n.d(t,{X3:()=>l,ry:()=>o,zv:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>1/(1+Math.exp(-e)))),o=(0,a.v)(r.vI1,(e=>1/(1+Math.exp(-e)))),l={kernelName:r.vI1,backendName:"cpu",kernelFunc:o}},8592:(e,t,n)=>{"use strict";n.d(t,{HS:()=>a,di:()=>i,lv:()=>o});var r=n(1592),s=n(3132);function a(e,t,n,s,a){const i=r.Kro.isSliceContinous(s,t,n),o=r.ZSL.sizeFromShape(n),l=r.ZSL.computeStrides(s);if(i){const n=r.Kro.computeFlatOffset(t,l);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}const u="string"===a?r.backend_util.fromUint8ToStringArray(e):e,c=(0,r.ra8)(s,a,u),d=(0,r.ra8)(n,a);for(let e=0;e<d.size;++e){const n=d.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));d.set(c.get(...r),...n)}return"string"===a?r.backend_util.fromStringArrayToUint8(d.values):d.values}function i(e){const{inputs:t,backend:n,attrs:i}=e,{x:o}=t,{begin:l,size:u}=i;(0,s.C)(o,"slice");const[c,d]=r.Kro.parseSliceParams(o,l,u);r.Kro.assertParamsValid(o,c,d);const h=a(n.data.get(o.dataId).values,c,d,o.shape,o.dtype);return n.makeTensorInfo(d,o.dtype,h)}const o={kernelName:r.JiE,backendName:"cpu",kernelFunc:i}},3846:(e,t,n)=>{"use strict";n.d(t,{y:()=>s});var r=n(1592);function s(e,t,n,s,a,i,o){const l=t[0],u=i[0],c=new Array(u),d=new Array(l),h=t[1];if(0===u){if(0!==l)throw new Error(r.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));return[r.ZSL.getArrayFromDType(n,0),[0,h],r.ZSL.getArrayFromDType(a,0),c,d]}let p=!0,f=0;const m=new Array(u).fill(0);for(let t=0;t<l;++t){const n=e[t*h];if(n<0)throw new Error(r.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=u)throw new Error(r.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,u));++m[n],p=p&&n>=f,f=n}let g=!0;for(let e=0;e<u;++e){const t=0===m[e];c[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){const t=e,n=s;for(let e=0;e<l;++e)d[e]=e;return[t,[l,h],n,c,d]}{const t=m[u-1],i=r.ZSL.getArrayFromDType(n,t*h),p=r.ZSL.getArrayFromDType(a,t),f=new Array(u).fill(0);for(let t=0;t<l;++t){const n=e[t*h],r=f[n],a=(0===n?0:m[n-1])+r;f[n]++;for(let n=0;n<h;++n)i[a*h+n]=e[t*h+n];p[a]=s[t],d[t]=a}for(let e=0;e<u;++e)if(0===f[e]){const t=0===e?0:m[e-1];i[t*h+0]=e;for(let e=1;e<h;++e)i[t*h+e]=0;p[t]=o}return[i,[t,h],p,c,d]}}},3741:(e,t,n)=>{"use strict";n.d(t,{l:()=>s});var r=n(1592);function s(e,t,n,s,a){const i=r.ZSL.sizeFromShape(s),o=t[0],l=a.length,u=[];let c=1,d=-1;for(let e=0;e<l;++e){const t=a[e];if(-1===t){if(-1!==d)throw new Error(r.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,e));d=e,u.push(1)}else{if(t<0)throw new Error(r.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,t));c*=t,u.push(t)}}if(-1!==d){if(c<=0)throw new Error(r.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(i/c);if(c*e!==i)throw new Error(r.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(s,u));u[d]=e}if(r.ZSL.sizeFromShape(u)!==i)throw new Error(r.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(s,u));const h=s.length,p=[];if(h>0){p[h-1]=1;for(let e=h-2;e>=0;--e)p[e]=p[e+1]*s[e+1]}const f=[];if(l>0){f[l-1]=1;for(let e=l-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=r.ZSL.getArrayFromDType(n,o*l);for(let t=0;t<o;++t){let n=0;for(let r=0;r<h;++r)n+=e[t*h+r]*p[r];for(let e=0;e<l;++e)m[t*l+e]=Math.trunc(n/f[e]),n%=f[e]}return[m,[o,l],u]}},2999:(e,t,n)=>{"use strict";n.d(t,{z:()=>s});var r=n(1592);function s(e,t,n,s,a,i=!1,o=0){const l=s.length,u=[t[0],e.length/t[0]],c=u[1],d=l>0?a[l-1]+1:0;if(d<0)throw new Error(r.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=t.slice();h[0]=d;const p=h.reduce(((e,t)=>e*t),1),f=r.ZSL.getArrayFromDType(n,p);if(0===l)return d>0&&f.fill(o),[f,h];if(d<=0)throw new Error(r.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,b=0,y=a[m];for(;;){let t=0;if(g<l){if(t=a[g],y===t){++g;continue}if(y>=t)throw new Error(r.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=d)throw new Error(r.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,d));y>b&&f.fill(o,b*c,y*c);for(let t=m;t<g;++t){const n=s[t];if(n<0||n>=u[0])throw new Error(r.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,s[t],u[0]));for(let t=0;t<c;t++)f[y*c+t]+=e[n*c+t]}if(i)for(let e=0;e<c;e++)f[y*c+e]/=g-m;if(m=g,++g,b=y+1,y=t,g>l)break}return b<d&&f.fill(o,b*c,d*c),[f,h]}},6086:(e,t,n)=>{"use strict";n.d(t,{Fu:()=>l,x6:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)((e=>Math.sqrt(e))),o=(0,a.v)(r.dFH,(e=>Math.sqrt(e))),l={kernelName:r.dFH,backendName:"cpu",kernelFunc:o}},8144:(e,t,n)=>{"use strict";n.d(t,{RF:()=>i,b2:()=>l});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>{const n=e-t;return n*n})),o=(0,a.j)(r.Ddj,i),l={kernelName:r.Ddj,backendName:"cpu",kernelFunc:o}},6771:(e,t,n)=>{"use strict";n.d(t,{C:()=>l,_:()=>i});var r=n(1592),s=n(971),a=n(3064);const i=(0,s.o)(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),o=(0,a.F)(r.GZp,i),l={kernelName:r.GZp,backendName:"cpu",kernelFunc:o}},5840:(e,t,n)=>{"use strict";n.d(t,{e:()=>s});var r=n(1592);function s(e,t,n,s){const a=(0,r.ra8)(e,t.dtype);for(let e=0;e<a.size;e++){const r=a.indexToLoc(e),i=new Array(r.length);for(let e=0;e<i.length;e++)i[e]=r[e]*n[e]+s[e];a.set(t.get(...i),...r)}return a}},1980:(e,t,n)=>{"use strict";n.d(t,{G:()=>a});var r=n(1592);class s{constructor(e,t,n,s,a,i){this.separator=r.ZSL.encodeString(e),this.nGramWidths=t,this.leftPad=r.ZSL.encodeString(n),this.rightPad=r.ZSL.encodeString(s),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,s=t.length;if(s>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let r=1;r<s;++r){let s=t[r]>=e;if(s=s&&t[r]<=n,!s)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=s-1,i=r.ZSL.getArrayFromDType("int32",s);if(0===n||0===s){const e=new Array(n);for(let e=0;e<=a;++e)i[e]=0;return[e,i]}i[0]=0;for(let e=1;e<=a;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),i[e]=i[e-1]+r}const o=new Array(i[a]);for(let n=0;n<a;++n){const r=t[n];let s=i[n];if(this.nGramWidths.forEach((a=>{const i=t[n+1]-t[n],l=this.getNumNGrams(i,a);this.createNGrams(e,r,o,s,l,a),s+=l})),this.preserveShort&&s===i[n]){const a=t[n+1]-t[n];if(0===a)continue;const i=a+2*this.padWidth,l=1;this.createNGrams(e,r,o,s,l,i)}}return[o,i]}}function a(e,t,n,r,a,i,o,l){return new s(n,r,a,i,o,l).compute(e,t)}},1038:(e,t,n)=>{"use strict";n.d(t,{S:()=>a});var r=n(1592);function s(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function a(e,t,n){const a=e.length,i=[];let o=0,l=0;const u=new Array(a);for(let r=0;r<a;++r){const a=i.length;s(e[r],t,n,i);const c=i.length-a;u[r]=c,o+=c,l=Math.max(l,c)}const c=r.ZSL.getArrayFromDType("int32",2*o),d=new Array(o),h=[a,l];let p=0;for(let e=0;e<a;++e)for(let t=0;t<u[e];++t)c[2*p]=e,c[2*p+1]=t,d[p]=i[p],++p;return[c,d,h]}},7429:(e,t,n)=>{"use strict";n.d(t,{f:()=>s});var r=n(1592);function s(e,t){const n=r.ZSL.getArrayFromDType("int32",e.length);for(let s=0;s<e.length;++s)n[s]=r.ZSL.fingerPrint64(e[s]).modulo(t).getLowBitsUnsigned();return n}},1900:(e,t,n)=>{"use strict";n.d(t,{Zl:()=>u,dl:()=>i,jb:()=>l});var r=n(1592),s=n(3957),a=n(8410);const i=(0,s.Z)(((e,t)=>e-t)),o=(0,a.B)(((e,t,n,r)=>({real:e-n,imag:t-r}))),l=(0,a.j)(r.PbM,i,o),u={kernelName:r.PbM,backendName:"cpu",kernelFunc:l}},9009:(e,t,n)=>{"use strict";n.d(t,{D:()=>s});var r=n(1592);function s(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=(0,r.ra8)(n,e.dtype);for(let t=0;t<s.values.length;++t){const n=s.indexToLoc(t),r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=n[t]%e.shape[t];const a=e.locToIndex(r);s.values[t]=e.values[a]}return s}},8749:(e,t,n)=>{"use strict";n.d(t,{x:()=>i});var r=n(1592);const s=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function a(e,t,n=0,i=e.length-1){for(;i>n;){if(i-n>600){const r=i-n+1,s=t-n+1,o=Math.log(r),l=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*l*(r-l)/r)*Math.sign(s-r/2);a(e,t,Math.max(n,Math.floor(t-s*l/r+u)),Math.min(i,Math.floor(t+(r-s)*l/r+u)))}const o=e[t];let l=n,u=i;for(r.ZSL.swap(e,n,t),s(e[i],o)>0&&r.ZSL.swap(e,n,i);l<u;){for(r.ZSL.swap(e,l,u),l++,u--;s(e[l],o)<0;)l+=1;for(;s(e[u],o)>0;)u-=1}0===s(e[n],o)?r.ZSL.swap(e,n,u):(u+=1,r.ZSL.swap(e,u,i)),u<=t&&(n=u+1),t<=u&&(i=u-1)}}function i(e,t,n,i,o){const l=t[t.length-1],[u,c]=[e.length/l,l],d=r.ZSL.getTypedArrayFromDType(n,u*i),h=r.ZSL.getTypedArrayFromDType("int32",u*i);for(let t=0;t<u;t++){const n=t*c,r=e.subarray(n,n+c);let l=new Array(r.length);r.forEach(((e,t)=>l[t]={value:e,index:t})),i<l.length&&(a(l,i),l=l.slice(0,i)),o&&l.sort(s);const u=t*i,p=d.subarray(u,u+i),f=h.subarray(u,u+i);for(let e=0;e<i;e++)p[e]=l[e].value,f[e]=l[e].index}const p=t.slice();return p[p.length-1]=i,[(0,r.ra8)(p,n,d),(0,r.ra8)(p,"int32",h)]}},4425:(e,t,n)=>{"use strict";n.d(t,{W:()=>o,m:()=>i});var r=n(1592),s=n(3132),a=n(2486);function i(e){const{inputs:t,attrs:n,backend:r}=e,{x:i}=t,{perm:o}=n;(0,s.C)(i,"transpose");const l=i.shape.length,u=new Array(l);for(let e=0;e<u.length;e++)u[e]=i.shape[o[e]];const c=r.data.get(i.dataId).values,d=(0,a._)(c,i.shape,i.dtype,o,u);return{dataId:r.write(d,u,i.dtype),shape:u,dtype:i.dtype}}const o={kernelName:r.wx0,backendName:"cpu",kernelFunc:i}},2486:(e,t,n)=>{"use strict";n.d(t,{_:()=>s});var r=n(1592);function s(e,t,n,s,a){const i=t.length,o=r.ZSL.sizeFromShape(t),l=r.ZSL.computeStrides(t),u=r.ZSL.computeStrides(a),c=r.ZSL.getTypedArrayFromDType(n,r.ZSL.sizeFromShape(a));for(let t=0;t<o;++t){const n=r.ZSL.indexToLoc(t,i,l),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[s[e]];c[r.ZSL.locToIndex(a,i,u)]=e[t]}return c}},1700:(e,t,n)=>{"use strict";n.d(t,{w:()=>s});var r=n(1592);function s(e,t,n,s){const a=r.ZSL.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let e=0;e<a;e++)i[0]*=n[e];i[1]=n[a];for(let e=a+1;e<n.length;e++)i[2]*=n[e];const o=new Map,l=new Int32Array(n[a]),u=new r.ylz(i,s,e),c=[],d=1===i[0]&&1===i[2];for(let t=0;t<n[a];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)e.push(u.get(n,t,r));n=e.join(",")}const r=o.get(n);if(null!=r)l[t]=r;else{const e=o.size;o.set(n,e),l[t]=e,c.push(t)}}const h=i.slice();h[1]=o.size;const p=new r.ylz(h,s);c.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)p.set(u.get(n,e,r),n,t,r)}));const f=n.slice();return f[a]=h[1],{outputValues:p.values,outputShape:f,indices:l}}},7530:(e,t,n)=>{"use strict";n.r(t),n.d(t,{addImpl:()=>s.mx,bincountImpl:()=>a.X,bincountReduceImpl:()=>a.N,bitwiseAndImpl:()=>i.f6,castImpl:()=>o.ct,ceilImpl:()=>l.YG,concatImpl:()=>u.h,equalImpl:()=>c.z3,expImpl:()=>d.sG,expm1Impl:()=>h.uM,floorDivImpl:()=>f.C1,floorImpl:()=>p.vS,gatherNdImpl:()=>m.q,gatherV2Impl:()=>g.G,greaterEqualImpl:()=>y.lg,greaterImpl:()=>b.rq,lessEqualImpl:()=>v.cu,lessImpl:()=>w.WR,linSpaceImpl:()=>x.G,logImpl:()=>_.px,maxImpl:()=>k.j,maximumImpl:()=>S.He,minimumImpl:()=>T.hE,multiplyImpl:()=>I.BF,negImpl:()=>E.Dk,notEqualImpl:()=>A.cl,prodImpl:()=>C._B,raggedGatherImpl:()=>N.u,raggedRangeImpl:()=>$._,raggedTensorToTensorImpl:()=>O.K,rangeImpl:()=>D.q,rsqrtImpl:()=>F.Zy,scatterImpl:()=>R.b,sigmoidImpl:()=>M.zv,simpleAbsImpl:()=>r.dH,sliceImpl:()=>L.HS,sparseFillEmptyRowsImpl:()=>P.y,sparseReshapeImpl:()=>z.l,sparseSegmentReductionImpl:()=>B.z,sqrtImpl:()=>V.x6,squaredDifferenceImpl:()=>U.RF,staticRegexReplaceImpl:()=>j._,stridedSliceImpl:()=>W.e,stringNGramsImpl:()=>G.G,stringSplitImpl:()=>H.S,stringToHashBucketFastImpl:()=>q.f,subImpl:()=>Z.dl,tileImpl:()=>K.D,topKImpl:()=>Y.x,transposeImpl:()=>X._,uniqueImpl:()=>Q.w});var r=n(574),s=n(161),a=n(441),i=n(7540),o=n(6051),l=n(6725),u=n(3053),c=n(5309),d=n(9077),h=n(4115),p=n(4540),f=n(5781),m=n(2698),g=n(756),b=n(2196),y=n(7758),w=n(8921),v=n(2578),x=n(4524),_=n(7424),k=n(5221),S=n(7720),T=n(5118),I=n(4160),E=n(1536),A=n(6699),C=n(9045),N=n(2722),$=n(2290),O=n(2368),D=n(9836),F=n(8830),R=n(2217),M=n(5834),L=n(8592),P=n(3846),z=n(3741),B=n(2999),V=n(6086),U=n(8144),j=n(6771),W=n(5840),G=n(1980),H=n(1038),q=n(7429),Z=n(1900),K=n(9009),Y=n(8749),X=n(2486),Q=n(1700)},3957:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var r=n(1592);function s(e){return(t,n,s,a,i)=>{const o=r.backend_util.assertAndGetBroadcastShape(t,n),l=o.length,u=r.ZSL.computeStrides(o),c=r.ZSL.sizeFromShape(o),d=r.ZSL.getTypedArrayFromDType(i,c),h=t.length,p=n.length,f=r.ZSL.computeStrides(t),m=r.ZSL.computeStrides(n),g=r.backend_util.getBroadcastDims(t,o),b=r.backend_util.getBroadcastDims(n,o);if(g.length+b.length===0)for(let t=0;t<d.length;++t)d[t]=e(s[t%s.length],a[t%a.length]);else for(let t=0;t<d.length;++t){const n=r.ZSL.indexToLoc(t,l,u),i=n.slice(-h);g.forEach((e=>i[e]=0));const o=r.ZSL.locToIndex(i,h,f),c=n.slice(-p);b.forEach((e=>c[e]=0));const y=r.ZSL.locToIndex(c,p,m);d[t]=e(s[o],a[y])}return[d,o]}}},8410:(e,t,n)=>{"use strict";n.d(t,{B:()=>l,j:()=>o});var r=n(1592),s=n(3132),a=n(6051),i=n(6154);function o(e,t,n,o){return null==n?({inputs:n,backend:a})=>{const{a:i,b:l}=n,u=a;(0,s.C)([i,l],e);const c=u.data.get(i.dataId).values,d=u.data.get(l.dataId).values,h="string"===i.dtype?r.backend_util.fromUint8ToStringArray(c):c,p="string"===i.dtype?r.backend_util.fromUint8ToStringArray(d):d,f=o||i.dtype,[m,g]=t(i.shape,l.shape,h,p,f);return u.makeTensorInfo(g,f,m)}:({inputs:e,backend:r})=>{const{a:s,b:l}=e,u=r;if("complex64"===s.dtype||"complex64"===l.dtype){const e=(0,a.wg)({inputs:{x:s},backend:u,attrs:{dtype:"complex64"}}),t=u.data.get(e.dataId),r=t.complexTensorInfos.real,o=t.complexTensorInfos.imag,c=u.data.get(r.dataId).values,d=u.data.get(o.dataId).values,h=(0,a.wg)({inputs:{x:l},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(h.dataId),f=p.complexTensorInfos.real,m=p.complexTensorInfos.imag,g=u.data.get(f.dataId).values,b=u.data.get(m.dataId).values,[y,w,v]=n(s.shape,l.shape,c,d,g,b),x=u.makeTensorInfo(v,"float32",y),_=u.makeTensorInfo(v,"float32",w),k=(0,i.f)({inputs:{real:x,imag:_},backend:u});return u.disposeIntermediateTensorInfo(e),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(x),u.disposeIntermediateTensorInfo(_),k}{const e=u.data.get(s.dataId).values,n=u.data.get(l.dataId).values,r=o||s.dtype,[a,i]=t(s.shape,l.shape,e,n,r);return u.makeTensorInfo(i,r,a)}}}function l(e){return(t,n,s,a,i,o)=>{const l=r.backend_util.assertAndGetBroadcastShape(t,n),u=r.ZSL.sizeFromShape(l),c=l.length,d=r.ZSL.computeStrides(l),h=r.ZSL.getTypedArrayFromDType("float32",u),p=r.ZSL.getTypedArrayFromDType("float32",u),f=r.backend_util.getBroadcastDims(t,l),m=r.backend_util.getBroadcastDims(n,l),g=r.backend_util.mergeRealAndImagArrays(s,a),b=r.backend_util.mergeRealAndImagArrays(i,o),y=t.length,w=r.ZSL.computeStrides(t),v=n.length,x=r.ZSL.computeStrides(n);if(f.length+m.length===0)for(let t=0;t<h.length;t++){const n=t%g.length,r=t%b.length,s=e(g[2*n],g[2*n+1],b[2*r],b[2*r+1]);h[t]=s.real,p[t]=s.imag}else for(let t=0;t<h.length;t++){const n=r.ZSL.indexToLoc(t,c,d),s=n.slice(-y);f.forEach((e=>s[e]=0));const a=r.ZSL.locToIndex(s,y,w),i=n.slice(-v);m.forEach((e=>i[e]=0));const o=r.ZSL.locToIndex(i,v,x),l=e(g[2*a],g[2*a+1],b[2*o],b[2*o+1]);h[t]=l.real,p[t]=l.imag}return[h,p,l]}}},971:(e,t,n)=>{"use strict";n.d(t,{o:()=>s});var r=n(1592);function s(e){return(t,n,s)=>{const a=r.ZSL.getArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],s);return a}}},3064:(e,t,n)=>{"use strict";n.d(t,{F:()=>o,v:()=>i});var r=n(1592),s=n(3132),a=n(971);function i(e,t,n){return o(e,(0,a.o)(t),n)}function o(e,t,n){return({inputs:a,attrs:i,backend:o})=>{const{x:l}=a;(0,s.C)(l,e);const u=o,c=u.data.get(l.dataId).values;let d;if("string"===l.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");d=r.backend_util.fromUint8ToStringArray(c)}else d=c;const h=n||l.dtype,p=t(d,h,i);return u.makeTensorInfo(l.shape,h,p)}}},2959:(e,t,n)=>{"use strict";n.d(t,{U:()=>a});var r=n(1592),s=n(6154);function a(e,t,n="float32"){if("complex64"===n){const n=a(e,t,"float32"),r=a(e,t,"float32");return(0,s.f)({inputs:{real:n,imag:r},backend:e})}const i=r.ZSL.makeZerosTypedArray(r.ZSL.sizeFromShape(t),n);return e.makeTensorInfo(t,n,i)}},8412:(e,t,n)=>{"use strict";n.r(t),n.d(t,{GPGPUContext:()=>pt,MathBackendWebGL:()=>Pn,forceHalfFloat:()=>Bn,gpgpu_util:()=>s,setWebGLContext:()=>l,version_webgl:()=>zn,webgl:()=>Vn,webgl_util:()=>r});var r={};n.r(r),n.d(r,{assertNotComplex:()=>fe,bindCanvasToFramebuffer:()=>U,bindColorTextureToFramebuffer:()=>j,bindTextureToProgramUniformSampler:()=>V,bindTextureUnit:()=>L,bindVertexBufferToProgramAttribute:()=>M,callAndCheck:()=>b,canBeRepresented:()=>v,createFragmentShader:()=>S,createFramebuffer:()=>R,createProgram:()=>E,createStaticIndexBuffer:()=>$,createStaticVertexBuffer:()=>N,createTexture:()=>D,createVertexShader:()=>k,getBatchDim:()=>K,getExtensionOrThrow:()=>_,getFramebufferErrorMessage:()=>H,getMaxTexturesInShader:()=>ie,getNumChannels:()=>O,getProgramUniformLocation:()=>B,getProgramUniformLocationOrThrow:()=>z,getRowsCols:()=>Y,getShapeAs3D:()=>X,getTextureShapeFromLogicalShape:()=>Q,getWebGLDisjointQueryTimerVersion:()=>oe,getWebGLErrorMessage:()=>x,getWebGLMaxTextureSize:()=>re,hasExtension:()=>le,isCapableOfRenderingToFloatTexture:()=>ce,isDownloadFloatTextureEnabled:()=>de,isReshapeFree:()=>ee,isWebGLFenceEnabled:()=>pe,isWebGLVersionEnabled:()=>ue,linkProgram:()=>A,logShaderSourceAndInfoLog:()=>I,resetMaxTextureSize:()=>se,resetMaxTexturesInShader:()=>ae,unbindColorTextureFromFramebuffer:()=>W,unbindTextureUnit:()=>P,validateFramebuffer:()=>G,validateProgram:()=>C,validateTextureSize:()=>F});var s={};n.r(s),n.d(s,{bindVertexProgramAttributeStreams:()=>at,createBufferFromOutputTexture:()=>lt,createFloat16MatrixTexture:()=>Qe,createFloat16PackedMatrixTexture:()=>st,createFloat32MatrixTexture:()=>Ye,createIndexBuffer:()=>qe,createPackedMatrixTexture:()=>nt,createUnsignedBytesMatrixTexture:()=>et,createVertexBuffer:()=>He,createVertexShader:()=>Ge,downloadByteEncodedFloatMatrixFromOutputTexture:()=>ct,downloadFloat32MatrixFromBuffer:()=>ut,downloadMatrixFromPackedOutputTexture:()=>ht,downloadPackedMatrixFromBuffer:()=>dt,getInternalFormatForFloat16MatrixTexture:()=>Xe,getInternalFormatForFloat16PackedMatrixTexture:()=>rt,getInternalFormatForFloat32MatrixTexture:()=>Ke,getInternalFormatForPackedMatrixTexture:()=>tt,getInternalFormatForUnsignedBytesMatrixTexture:()=>Je,uploadDenseMatrixToTexture:()=>it,uploadPixelDataToTexture:()=>ot});var a=n(1592);const i={},o={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function l(e,t){i[e]=t}function u(e,t){if(!(e in i)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if((0,a._K2)().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete i[e]}),!1),(0,a._K2)().getBool("SOFTWARE_WEBGL_ENABLED")&&(o.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",o)||n.getContext("experimental-webgl",o):n.getContext("webgl2",o)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;i[e]=n}const n=i[e];return null==n||n.isContextLost()?(delete i[e],u(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),i[e])}var c,d,h;function p(e,t){return[t,e]}function f(e){const t=a.ZSL.sizeFromShape(e),n=Math.ceil(t/4);return a.ZSL.sizeToSquarishShape(n)}function m(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function g(e,t){const n=e;let r,s,i,o,l,u,c,d,h,p;return 2===(0,a._K2)().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,i=n.RGBA16F,o=n.RGBA32F,l=n.RED,c=4,d=1,h=n.HALF_FLOAT,p=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,i=e.RGBA,o=n.RGBA,l=e.RGBA,c=4,d=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:p}}function b(e,t){const n=t();return(0,a._K2)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+x(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(c||(c={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(d||(d={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(h||(h={}));const y=5.96e-8,w=65504;function v(e){return!!((0,a._K2)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||y<Math.abs(e)&&Math.abs(e)<w)}function x(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function _(e,t){return q(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function k(e,t){const n=q(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(b(e,(()=>e.shaderSource(n,t))),b(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function S(e,t){const n=q(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(b(e,(()=>e.shaderSource(n,t))),b(e,(()=>e.compileShader(n))),(0,a._K2)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw I(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const T=/ERROR: [0-9]+:([0-9]+):/g;function I(e,t){const n=T.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),i=s.length.toString().length+2,o=s.map(((e,t)=>a.ZSL.rightPad((t+1).toString(),i)+e));let l=0;for(let e=0;e<o.length;e++)l=Math.max(o[e].length,l);const u=o.slice(0,r-1),c=o.slice(r-1,r),d=o.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${a.ZSL.rightPad(c[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function E(e){return q(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function A(e,t){if(b(e,(()=>e.linkProgram(t))),!(0,a._K2)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function C(e,t){if(b(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function N(e,t){const n=q(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return b(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),b(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function $(e,t){const n=q(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return b(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),b(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function O(){return 2===(0,a._K2)().getNumber("WEBGL_VERSION")?1:4}function D(e){return q(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function F(e,t){const n=(0,a._K2)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function R(e){return q(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function M(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(b(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),b(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),b(e,(()=>e.enableVertexAttribArray(o))),!0)}function L(e,t,n){Z(e,n),b(e,(()=>e.activeTexture(e.TEXTURE0+n))),b(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function P(e,t){Z(e,t),b(e,(()=>e.activeTexture(e.TEXTURE0+t))),b(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function z(e,t,n){return q(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function B(e,t,n){return e.getUniformLocation(t,n)}function V(e,t,n,r){b(e,(()=>L(e,t,r))),b(e,(()=>e.uniform1i(n,r)))}function U(e){b(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),b(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),b(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function j(e,t,n){b(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),b(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function W(e,t){b(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),b(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function G(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+H(e,t))}function H(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function q(e,t,n){const r=b(e,(()=>t()));if(null==r)throw new Error(n);return r}function Z(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}function K(e,t=2){return a.ZSL.sizeFromShape(e.slice(0,e.length-t))}function Y(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function X(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[K(e),...Y(e)]),t}function Q(e,t=!1){let n=(0,a._K2)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,a._K2)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&(0,a._K2)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?a.ZSL.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=a.ZSL.squeezeShape(e);e=t.newShape}let s=a.ZSL.sizeFromShape(e),i=null;e.length<=1&&s<=n?i=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);const o=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const t=K(e);let n=2,r=2;e.length&&([n,r]=Y(e)),s=t*(n/2)*(r/2),i=a.ZSL.sizeToSquarishShape(s).map((e=>2*e))}else i=a.ZSL.sizeToSquarishShape(s);return i}function J(e){return e%2==0}function ee(e,t){if(e=e.slice(-2),t=t.slice(-2),a.ZSL.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(J(n)&&J(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&J(e[0])&&J(t[0])}let te,ne;function re(e){if(null==te){const t=u(e);te=t.getParameter(t.MAX_TEXTURE_SIZE)}return te}function se(){te=null}function ae(){ne=null}function ie(e){if(null==ne){const t=u(e);ne=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ne)}function oe(e){if(0===e)return 0;let t;const n=u(e);return t=le(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:le(n,"EXT_disjoint_timer_query")?1:0,t}function le(e,t){return null!=e.getExtension(t)}function ue(e){try{if(null!=u(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function ce(e){if(0===e)return!1;const t=u(e);if(1===e){if(!le(t,"OES_texture_float"))return!1}else if(!le(t,"EXT_color_buffer_float"))return!1;return he(t)}function de(e){if(0===e)return!1;const t=u(e);if(1!==e){if(le(t,"EXT_color_buffer_float"))return he(t);const e="EXT_color_buffer_half_float";if(le(t,e)){const n=t.getExtension(e);return function(e,t){const n=g(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}(t,n)}return!1}return!!le(t,"OES_texture_float")&&(!!le(t,"WEBGL_color_buffer_float")&&he(t))}function he(e){const t=g(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function pe(e){return 2===e&&null!=u(e).fenceSync}function fe(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&a.ZSL.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const me=(0,a._K2)();function ge(){let e,t,n,r,s,i,o,l,u,c;return 2===(0,a._K2)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",l=(0,a._K2)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",i="gl_FragColor",o="",l="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:u,defineRound:c}}function be(e,t,n="index"){const r=a.ZSL.computeStrides(t);return r.map(((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function ye(e,t,n="index"){const r=a.ZSL.computeStrides(t);return r.map(((t,s)=>`int ${e[s]} = ${n} / outShapeStrides[${s}]; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function we(e){const t=a.ZSL.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}me.registerFlag("HAS_WEBGL",(()=>me.getNumber("WEBGL_VERSION")>0)),me.registerFlag("WEBGL_VERSION",(()=>ue(2)?2:ue(1)?1:0)),me.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),me.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===me.get("WEBGL_VERSION"))),me.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),me.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),me.registerFlag("WEBGL_PACK",(()=>me.getBool("HAS_WEBGL"))),me.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_CLIP",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_REDUCE",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_LAZILY_UNPACK",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_CONV_IM2COL",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>me.getBool("WEBGL_PACK"))),me.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>re(me.getNumber("WEBGL_VERSION")))),me.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>ie(me.getNumber("WEBGL_VERSION")))),me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=me.getNumber("WEBGL_VERSION");return 0===e?0:oe(e)})),me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>me.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!a.eMq.isMobile())),me.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>ce(me.getNumber("WEBGL_VERSION")))),me.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!me.getBool("WEBGL_FORCE_F16_TEXTURES")&&me.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),me.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>de(me.getNumber("WEBGL_VERSION")))),me.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>pe(me.getNumber("WEBGL_VERSION")))),me.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>me.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),me.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),me.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>a.eMq.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),me.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),me.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),me.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),me.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),me.registerFlag("WEBGL_EXP_CONV",(()=>!1)),me.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>me.getBool("IS_TEST"))),me.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),me.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),me.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),me.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const ve="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:xe}=a.backend_util;function _e(e,t,n){const r=[];if(e.forEach((e=>{const t=a.ZSL.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=Oe(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),i=e.map((e=>function(e,t,n=!1,r){let s="";s+=n?Se(e,r):ke(e,r);const i=e.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=xe(e.shapeInfo.logicalShape,t.logicalShape),u=$e(o),c=o-i;let d;const h=["x","y","z","w","u","v"];d=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${h[e+c]} = 0;`)).join("\n");let p="";p=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+c]}`)).join(", ");let f="return outputValue;";const m=1===a.ZSL.sizeFromShape(e.shapeInfo.logicalShape),g=1===a.ZSL.sizeFromShape(t.logicalShape);if(1!==i||m||g){if(m&&!g)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?f="return vec4(outputValue.x);":l.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${p});\n      ${f}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=t.texShape,o=e.shapeInfo.texShape,l=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&l===u&&null==e.shapeInfo.flatOffset&&a.ZSL.arraysEqual(o,i))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const c=$e(u),d=xe(e.shapeInfo.logicalShape,t.logicalShape),h=u-l;let p;const f=["x","y","z","w","u","v"];p=0===l?"":u<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${f[e+h]} = 0;`)).join("\n");let m="";return m=u<2&&l>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${f[t+h]}`)).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${p}\n      return get${r}(${m});\n    }\n  `}(e,t)),s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,l=ge(),u=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,d,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Te}\n    ${Ie}\n    ${Ee}\n  `}(l);return t.isPacked?(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(a.ZSL.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(l)):(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return a.ZSL.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${ye(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=be(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${ye(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=be(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=be(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=be(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,n.enableShapeUniforms),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),n.packedInputs&&(h+=Ae),[h,u,d,s,c,i,n.userCode].join("\n")}function ke(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=Ce(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Ne(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=Ce(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&a.ZSL.arraysEqual(n,i)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=i[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:l}=a.ZSL.squeezeShape(n),u=o;if(u.length<n.length){const n=["row","col"];return`\n      ${ke(De(e,u),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Fe(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Ne(e)}\n      }\n    `;const c=i[0],d=i[1],h=Ce(r);return 1===d?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],o=n[2],{newShape:l,keptDims:u}=a.ZSL.squeezeShape(n),c=l;if(c.length<n.length){const n=["row","col","depth"];return`\n        ${ke(De(e,c),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Fe(n,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${Ne(e)}\n      }\n    `;const d=e.shapeInfo.texShape,h=d[0],p=d[1],f=e.shapeInfo.flatOffset;if(p===i&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===o&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const m=Ce(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${m};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${m};\n        vec2 uv = uvFromFlat(${h}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],o=n[2]*i,l=n[1]*o,{newShape:u,keptDims:c}=a.ZSL.squeezeShape(n);if(u.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${ke(De(e,u),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Fe(n,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${o}, ${i}, 1)));\n        ${Ne(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1],m=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,b=`int stride0 = ${r}Shape[1] * stride1;`;if(f===l&&null==d)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===i&&null==d)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=Ce(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${g}\n      ${b}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],i=t[3]*s,o=t[2]*i,l=t[1]*o,{newShape:u,keptDims:c}=a.ZSL.squeezeShape(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${ke(De(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Fe(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${o}, ${i}, ${s})) +\n          depth3;\n        ${Ne(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===l&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===s&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${o} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${Ce(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:i}=a.ZSL.squeezeShape(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${ke(De(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Fe(t,i)});\n      }\n    `}const o=t[5],l=t[4]*o,u=t[3]*l,c=t[2]*u,d=t[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${u}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Ne(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];if(m===d&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===o&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${u} +\n          depth2 * ${l} + depth3 * ${o} + depth4 + ${Ce(n)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Se(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${ge().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=ge();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,o=i[0],l=i[1],u=ge();if(null!=i&&a.ZSL.arraysEqual(n,i))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${Se(De(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Fe(a,r)});\n        }\n      `}const o=ge();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=ge();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<i-1;e++)p=`int b${e}, `+p,h*=a[i-e-1],f=`b${e} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const Te="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ie="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ee="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ae="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ce(e){return`offset${e}`}function Ne(e){const t=e.name,n=a.ZSL.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function $e(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Oe(e,t,n){const{newShape:r,keptDims:s}=a.ZSL.squeezeShape(t),i=t.length,o=e&&3===i&&1===t[0],l=o?t.slice(1):r,u=!e&&i>1&&!a.ZSL.arraysEqual(t,n)&&r.length<i||o;return{useSqueezeShape:u,uniformShape:u?l:t,keptDims:s}}function De(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Fe(e,t){return t.map((t=>e[t])).join(", ")}function Re(e,t,n){const r=[],s=[];let i,o,l,u=null,c=null;c=e.getUniformLocation(n,"NAN",!1),1===(0,a._K2)().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const d=!1;for(const s of t.variableNames){const a={name:s,uniform:e.getUniformLocation(n,s,d),offset:e.getUniformLocation(n,`offset${s}`,d)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${s}Shape`,d),a.texShape=e.getUniformLocation(n,`${s}TexShape`,d)),r.push(a)}if(t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",d),l=e.getUniformLocation(n,"outShapeStrides",d),o=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms)for(const r of t.customUniforms)s.push(e.getUniformLocation(n,r.name,d));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:o}}function Me(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],i=s.shape;if(!a.ZSL.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(e.isUniform&&s.isUniform)return;const o=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!a.ZSL.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)}))}function Le(e){return(0,a._K2)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class Pe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=c.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ge();this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ye(["r","c","d"],e):be(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class ze{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=c.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ge();this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ye(["r","c","d"],e):be(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class Be{constructor(e){this.variableNames=["A"],this.outTexUsage=d.DOWNLOAD;const t=ge();this.outputShape=e,this.userCode=`\n      ${ve}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Ve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=d.DOWNLOAD;const t=ge();this.outputShape=e,this.userCode=`\n      ${ve}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const Ue={R:0,G:1,B:2,A:3};class je{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ge();this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let e=0;e<n.length;e++){const t=n[e];a+=`\n          if(offset == ${e}) {\n            result = values[${Ue[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":we(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class We{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=ge();this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let s=0;s<=1;s++){const a=2*t+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":we(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function Ge(e){const t=ge();return k(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function He(e){return N(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function qe(e){return $(e,new Uint16Array([0,1,2,2,1,3]))}function Ze(e,t,n,r,s,i){F(t,n);const o=D(e),l=e.TEXTURE_2D;return b(e,(()=>e.bindTexture(l,o))),b(e,(()=>e.texParameteri(l,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),b(e,(()=>e.texParameteri(l,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),b(e,(()=>e.texParameteri(l,e.TEXTURE_MIN_FILTER,e.NEAREST))),b(e,(()=>e.texParameteri(l,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===(0,a._K2)().getNumber("WEBGL_VERSION")?b(e,(()=>e.texImage2D(l,0,r,t,n,0,s,i,null))):b(e,(()=>e.texStorage2D(l,1,r,t,n))),b(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function Ke(e){return e.internalFormatFloat}function Ye(e,t,n,r){const[s,a]=p(t,n);return Ze(e,s,a,Ke(r),r.textureFormatFloat,e.FLOAT)}function Xe(e){return e.internalFormatHalfFloat}function Qe(e,t,n,r){const[s,a]=p(t,n);return Ze(e,s,a,Xe(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Je(e){return e.downloadTextureFormat}function et(e,t,n,r){const[s,a]=p(t,n);return Ze(e,s,a,Je(r),e.RGBA,e.UNSIGNED_BYTE)}function tt(e){return e.internalFormatPackedFloat}function nt(e,t,n,r){const[s,a]=m(t,n);return Ze(e,s,a,tt(r),e.RGBA,e.FLOAT)}function rt(e){return e.internalFormatPackedHalfFloat}function st(e,t,n,r){const[s,a]=m(t,n);return Ze(e,s,a,rt(r),e.RGBA,r.textureTypeHalfFloat)}function at(e,t,n){return b(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),M(e,t,"clipSpacePos",n,3,20,0)&&M(e,t,"uv",n,2,20,12)}function it(e,t,n,r,s,i){let o,l,u;b(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(o=new Uint8Array(n*r*4),l=e.UNSIGNED_BYTE,u=e.RGBA):(o=new Float32Array(n*r*4),l=e.FLOAT,u=i.internalFormatPackedFloat),o.set(s),2===(0,a._K2)().getNumber("WEBGL_VERSION")?b(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,l,o))):b(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,l,o))),b(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function ot(e,t,n){b(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===(0,a._K2)().getNumber("WEBGL_VERSION")?b(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):b(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===(0,a._K2)().getNumber("WEBGL_VERSION")?b(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):b(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),b(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function lt(e,t,n,r){const s=e.createBuffer();b(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const a=16*t*n;return b(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),b(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),b(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),s}function ut(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function ct(e,t,n,r){const[s,a]=p(t,n),i=new Uint8Array(t*n*4);return b(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}function dt(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=m(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function ht(e,t,n){const r=new Float32Array(t*n*4);return b(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}class pt{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=(0,a._K2)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,l(t,e)):this.gl=u(t),e=this.gl,2===(0,a._K2)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>b(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>b(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>b(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>b(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>b(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>b(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>b(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>b(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,a._K2)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=_(this.gl,e),le(this.gl,t))this.textureHalfFloatExtension=_(this.gl,t);else if((0,a._K2)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),le(this.gl,r))this.colorBufferHalfFloatExtension=_(this.gl,r);else if((0,a._K2)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",le(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!le(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=He(this.gl),this.indexBuffer=qe(this.gl),this.framebuffer=R(this.gl),this.textureConfig=g(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,a._K2)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;b(e,(()=>e.finish())),b(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),b(e,(()=>e.deleteFramebuffer(this.framebuffer))),b(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),b(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),b(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Ye(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Qe(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),et(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),ot(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),it(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),st(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),nt(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(W(this.gl,this.framebuffer),this.outputTexture=null),b(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>ct(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return dt(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return ut(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=lt(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,a._K2)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>ht(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=Ge(t));const n=E(t);b(t,(()=>t.attachShader(n,this.vertexShader))),b(t,(()=>t.attachShader(n,e))),A(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&C(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;b(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),at(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(b(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&C(this.gl,this.program),b(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?z(this.gl,e,t):B(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),b(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),V(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=m(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&C(this.gl,this.program),G(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}b(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),b(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=_(this.gl,2===(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await a.ZSL.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in(0,a._K2)().platform&&(n=(0,a._K2)().platform.setTimeoutCustom.bind((0,a._K2)().platform)),a.ZSL.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),j(this.gl,e,this.framebuffer),this.debug&&G(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(j(this.gl,this.outputTexture,this.framebuffer),this.debug&&G(this.gl)):W(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;j(r,e,this.framebuffer),this.debug&&G(r),this.outputTexture=e,b(r,(()=>r.viewport(0,0,t,n))),b(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),b(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}var ft=n(7530);const{addImpl:mt,bincountImpl:gt,bincountReduceImpl:bt,bitwiseAndImpl:yt,castImpl:wt,ceilImpl:vt,concatImpl:xt,equalImpl:_t,expImpl:kt,expm1Impl:St,floorImpl:Tt,gatherNdImpl:It,gatherV2Impl:Et,greaterImpl:At,greaterEqualImpl:Ct,lessImpl:Nt,lessEqualImpl:$t,linSpaceImpl:Ot,logImpl:Dt,maxImpl:Ft,maximumImpl:Rt,minimumImpl:Mt,multiplyImpl:Lt,negImpl:Pt,notEqualImpl:zt,prodImpl:Bt,raggedGatherImpl:Vt,raggedRangeImpl:Ut,raggedTensorToTensorImpl:jt,rangeImpl:Wt,rsqrtImpl:Gt,scatterImpl:Ht,sigmoidImpl:qt,simpleAbsImpl:Zt,sliceImpl:Kt,sparseFillEmptyRowsImpl:Yt,sparseReshapeImpl:Xt,sparseSegmentReductionImpl:Qt,sqrtImpl:Jt,staticRegexReplaceImpl:en,stridedSliceImpl:tn,stringNGramsImpl:nn,stringSplitImpl:rn,stringToHashBucketFastImpl:sn,subImpl:an,tileImpl:on,topKImpl:ln,transposeImpl:un,uniqueImpl:cn}=ft;function dn(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function hn(e,t){return 1===t?[e]:dn(e,t)}class pn{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Le(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=hn("rc",this.rank),t=$e(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class fn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}(e.map(((e,t)=>t)),t);return r.map(((t,s)=>`int ${e[s]} = ${n} / ${r[s]}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`)).join("")}(["r","c","d"],"inputShape"):be(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":we(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class mn{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=bn(t,n),s=yn(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=gn(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===h.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===h.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===h.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===h.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===h.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=bn(n,r),i=yn(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=gn(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=(0,a._K2)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(e);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function gn(e,t,n,r,s){const a=function(e,t){switch(e){case h.PACKED_2X2_FLOAT32:return tt(t);case h.PACKED_2X2_FLOAT16:return rt(t);case h.UNPACKED_FLOAT32:return Ke(t);case h.UNPACKED_FLOAT16:return Xe(t);case h.PACKED_4X1_UNSIGNED_BYTE:return Je(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=m(e[0],e[1]);i=t*n}else{const[t,n]=p(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function bn(e,t){if(e===d.UPLOAD)return h.PACKED_2X2_FLOAT32;if(e===d.RENDER||null==e)return function(e){return(0,a._K2)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?h.PACKED_2X2_FLOAT32:h.UNPACKED_FLOAT32:e?h.PACKED_2X2_FLOAT16:h.UNPACKED_FLOAT16}(t);if(e===d.DOWNLOAD||e===d.PIXELS)return h.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function yn(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class wn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const vn="if (isnan(x)) return x;",xn="return x;",_n="return abs(x);",kn="return (x >= 0.0) ? x : (exp(x) - 1.0);",Sn=vn+"\n  return (x < 0.0) ? 0.0 : x;\n",Tn=vn+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",In="return x;",En="return 1.0 / (1.0 + exp(-1.0 * x));",An="return x;",Cn="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Nn="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",$n="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",On="return 1.0 / (1.0 + exp(-1.0 * x));";class Dn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Fn{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length);const t=e.length,n=hn("rc",t),r=$e(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const Rn=a.kpo.whereImpl,Mn={},Ln=(0,a._K2)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Pn extends a.uI_{nextDataId(){return Pn.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,a._K2)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof pt)t=e;else{const n=u((0,a._K2)().getNumber("WEBGL_VERSION"),e);t=new pt(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=u((0,a._K2)().getNumber("WEBGL_VERSION"));t=new pt(e),this.binaryCache=((n=(0,a._K2)().getNumber("WEBGL_VERSION"))in Mn||(Mn[n]={}),Mn[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new mn(this.gpgpu),this.numMBBeforeWarning=null==(0,a._K2)().global.screen?1024:(0,a._K2)().global.screen.height*(0,a._K2)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new a.GJx(this,(0,a.Hi9)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=X(t),u=new je(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if(((0,a._K2)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,a._K2)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:d.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if((0,a._K2)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:d.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=t;if(null!=i){let t;t=l?new Dn(o,In):new wn(o,In);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let c,d;if(u&&(c=a.ZSL.now()),"complex64"===r){const e=this.readSync(s.real.dataId),t=this.readSync(s.imag.dataId);d=a.backend_util.mergeRealAndImagArrays(e,t)}else d=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=a.ZSL.now()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=t;if(null!=s){let t;t=l?new Dn(r,In):new wn(r,In);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:i}],i),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,a._K2)().getBool("DEBUG")&&!(0,a._K2)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,a._K2)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,d=null;if("complex64"!==i&&(0,a._K2)().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);d=this.gpgpu.createBufferFromTexture(t.texture.texture,...f(r))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];c=a.backend_util.mergeRealAndImagArrays(t,n)}else if(null==d)c=this.getValuesFromTexture(e);else{const e=a.ZSL.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=d){const e=this.gpgpu.gl;b(e,(()=>e.deleteBuffer(d)))}const h=this.convertAndCacheOnCPU(e,c),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,a.Hi9)().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:i,dtype:o,isPacked:l,texture:u}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=l?new Dn(s,In):new wn(s,In);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:o}],o),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==u)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),d=(0,a.Hi9)().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>a.ZSL.decodeString(e)));return(0,a.ra8)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,a.ra8)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!v(n)){if((0,a._K2)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=a.ZSL.sizeFromShape(t);if((0,a._K2)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...f(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const i=(0,a._K2)().getBool("WEBGL_PACK")&&!0===r,o=i?X(t):t,l=i?new Ve(o):new Be(o),u=this.runWebGLProgram(l,[{shape:o,dtype:n,dataId:e}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=a.ZSL.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=a.ZSL.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);o.kernelMs=a.ZSL.sum(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:a.ZSL.now(),endMs:null}}endTimer(e){return(0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=a.ZSL.now(),e)}async getQueryTime(e){if((0,a._K2)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Ln){return(0,a._K2)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&a.ZSL.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){a.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Rn(e.shape,t)}packedUnaryOp(e,t,n){const r=new Dn(e.shape,t),s=this.compileAndRun(r,[e],n);return(0,a.Hi9)().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Zt(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,_n,e.dtype);const t=new wn(e.shape,_n),n=this.compileAndRun(t,[e]);return(0,a.Hi9)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&a.ZSL.isString(n[0])){const s=n.map((e=>a.ZSL.encodeString(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return(0,a.Hi9)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new Fn(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new pn(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[K(e.shape),...Y(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[K(t),...Y(t)],a=new fn(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:i}=n;if(null!=t){const e=a.ZSL.sizeFromShape(s),n=t[0]*t[1]*4;a.ZSL.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=X(s);let l;l=r?new ze(o):new Pe(o);const u=[null!=t?t:f(o)];return{dtype:i,shape:s,dataId:this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:e}],i,u,!0,t).dataId}}runWebGLProgram(e,t,n,r,s=!1,i){const o=this.makeTensorInfo(e.outputShape,n),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===c.DENSE){const t=null!=i?i:f(e.outputShape);l.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===a.ZSL.sizeFromShape(o.shape))return l.values=a.ZSL.getTypedArrayFromDType(o.dtype,0),o;const u=[],d=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&a.ZSL.sizeFromShape(t.shape)<=(0,a._K2)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!ee(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const h={shape:o.shape,texData:l,isUniform:!1},p=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const i=t.texData.texShape,{useSqueezeShape:o,uniformShape:l,keptDims:u}=Oe(e.packedInputs,t.shape,i);let c="",d="",h="";if(1===l.length&&e.packedInputs){const e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==l.length||e.packedInputs){if(l.length>2&&!e.packedInputs){const e=a.ZSL.computeStrides(l);h=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else d=`${l[0]>1}_${l[1]>1}`;const p=t.shape.length,f=2===l.length&&a.ZSL.arraysEqual(t.shape,i),m=1===a.ZSL.sizeFromShape(t.shape),g=a.backend_util.getBroadcastDims(t.shape,n.shape),b=!e.packedInputs&&p===n.shape.length&&a.ZSL.arraysEqual(i,n.texData.texShape),y=e.packedInputs||l.length>2?"":`${i[0]>1}_${i[1]>1}`;r+=`${p}_${b}_${o?u:""}_${l.length}_${m}_${g}_${f}_${c}_${d}_${h}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let i=e.constructor.name;return i+="_"+r+"_"+s+`${(0,a._K2)().getNumber("WEBGL_VERSION")}`,i}(e,d,h),m=this.getAndSaveBinary(p,(()=>function(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),i=s.map((e=>e.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=_e(s,o,t),u=S(e.gl,l),c=e.createProgram(u);return(0,a._K2)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:l,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:u,source:l,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},Re(e,t,c)))}(this.gpgpu,e,d,h))),g=null!=this.activeTimers;let b;g&&(b=this.startTimer()),(0,a._K2)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(Me(t.inShapeInfos,n),Me([t.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):e.setOutputMatrixTexture(i.texture,o[0],o[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===(0,a._K2)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){const s=n[r],{uniform:i,offset:o,shape:l,texShape:u}=t.variablesLocations[r];if(l){const{uniformShape:n}=Oe(t.program.packedInputs,s.shape,s.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(l,new Int32Array(n));break;case 2:e.gl.uniform2iv(l,new Int32Array(n));break;case 3:e.gl.uniform3iv(l,new Int32Array(n));break;case 4:e.gl.uniform4iv(l,new Int32Array(n))}}if(u&&e.gl.uniform2i(u,s.texData.texShape[0],s.texData.texShape[1]),null!=i)if(s.isUniform)if(a.ZSL.sizeFromShape(s.shape)<2)e.gl.uniform1f(i,s.uniformValues[0]);else{let t=s.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(i,t)}else null!=s.texData.slice&&null!=o&&e.gl.uniform1i(o,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,i,r)}const l=t.outShapeLocation;if(l)switch(r.shape.length){case 1:e.gl.uniform1iv(l,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(l,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(l,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(l,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=a.ZSL.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let n=0;n<t.program.customUniforms.length;++n){const r=t.program.customUniforms[n],a=t.customUniformLocations[n],i=s[n];if("float"===r.type)e.gl.uniform1fv(a,i);else if("vec2"===r.type)e.gl.uniform2fv(a,i);else if("vec3"===r.type)e.gl.uniform3fv(a,i);else if("vec4"===r.type)e.gl.uniform4fv(a,i);else if("int"===r.type)e.gl.uniform1iv(a,i);else if("ivec2"===r.type)e.gl.uniform2iv(a,i);else if("ivec3"===r.type)e.gl.uniform3iv(a,i);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(a,i)}}e.executeProgram()}(this.gpgpu,m,d,h,r),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),g&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const y=(0,a._K2)().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const e=a.ZSL.now();e-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,a._K2)().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===s){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,a._K2)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,a.DZQ)((()=>{if(!(0,a._K2)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,a._K2)().getBool("DEBUG");(0,a._K2)().set("DEBUG",!1);const t=this.abs((0,a.d_2)(1e-8)).dataSync()[0];if((0,a._K2)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:i,usage:o,isPacked:l}=t;if(null!=i)return;const u=null!=this.activeTimers;let c;u&&(c=a.ZSL.now());let h=t.texShape;if(null==h&&(h=Q(n,l),t.texShape=h),null!=s){const e=X(n);let i,o=h[1],p=h[0];const f=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!l&&f||([o,p]=m(h[0],h[1])),i=l?new We(e,f):new je(e,f);const g=f?[p,o]:h,b=this.makeTensorInfo(g,r),y=this.texData.get(b.dataId);y.usage=f?d.PIXELS:d.UPLOAD,y.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),o,p,s);const w=[[p,o]],v=!0,x=this.runWebGLProgram(i,[b],r,w,v),_=this.texData.get(x.dataId);t.texShape=_.texShape,t.isPacked=_.isPacked,t.usage=_.usage,(0,a._K2)().get("ENGINE_COMPILE_ONLY")?this.disposeData(x.dataId):(t.texture=_.texture,t.values=null,this.texData.delete(x.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=a.ZSL.now()-c)}else{const e=this.acquireTexture(h,o,r,l);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*a.ZSL.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await(0,a.dA1)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw I(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=Re(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:i,channels:o}=e,l=(0,a.Hi9)().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,t,n,s,i,o);return(0,a.Hi9)().makeTensorFromDataId(u,t,n,l)}}Pn.nextDataId=0;const zn="4.18.0";function Bn(){(0,a._K2)().set("WEBGL_FORCE_F16_TEXTURES",!0)}a.eMq.isBrowser()&&(0,a.gJX)("webgl",(()=>new Pn),2);const Vn={forceHalfFloat:Bn},Un="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class jn{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=a.backend_util.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Le(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Wn="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Gn{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a.backend_util.assertAndGetBroadcastShape(t,n);const s=this.outputShape.length;this.enableShapeUniforms=Le(s);let i="";if(r)if(0===s||1===a.ZSL.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${$e(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=hn("coords",s);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Hn(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const qn={kernelName:a.lzr,backendName:"webgl",kernelFunc:Hn};function Zn(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=Hn({inputs:{x:r},backend:n}),l=Hn({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const Kn={kernelName:a.pr3,backendName:"webgl",kernelFunc:Zn},Yn="return (a < 0.) ? b * a : a;",Xn="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Qn={kernelName:a.X0$,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:i}=r,o=n.makeTensorInfo([],"float32",a.ZSL.createScalarValue(i,"float32")),l=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gn(Xn,s.shape,o.shape):new jn(Yn,s.shape,o.shape),u=n.runWebGLProgram(l,[s,o],"float32");return n.disposeIntermediateTensorInfo(o),u}},Jn="return (a < 0.) ? b * a : a;",er="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",tr={kernelName:a.Ncv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,i=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gn(er,r.shape,s.shape):new jn(Jn,r.shape,s.shape);return n.runWebGLProgram(i,[r,s],"float32")}},nr="if (isnan(x)) return x;";function rr({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,l=i,u=r||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=n){const e=l.texData.get(o.dataId),t=n(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=(0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Dn(o.shape,t):new wn(o.shape,e),l.runWebGLProgram(c,[o],u)}}function sr({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:l})=>{const{a:u,b:c}=o,d=l;if(r&&"complex64"===u.dtype){const t=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},i={dataId:r.dataId,dtype:r.dtype,shape:c.shape},o=new jn(e,u.shape,c.shape);return d.runWebGLProgram(o,[s,i],(0,a.TuY)(n.dtype,r.dtype))})),i=Zn({inputs:{real:r,imag:s},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(s),i}const h=i||(0,a.TuY)(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){const e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?a.backend_util.fromUint8ToStringArray(e):e,r="string"===u.dtype?a.backend_util.fromUint8ToStringArray(t):t,[i,o]=s(u.shape,c.shape,n,r,h),l=d.makeTensorInfo(o,h);return d.texData.get(l.dataId).values=i,l}let p;return p=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Gn(t,u.shape,c.shape,n):new jn(e,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function ar(e,t=!1){if("linear"===e)return t?An:xn;if("relu"===e)return t?Nn:Sn;if("elu"===e)return t?Cn:kn;if("relu6"===e)return t?$n:Tn;if("prelu"===e)return t?er:Jn;if("leakyrelu"===e)return t?Xn:Yn;if("sigmoid"===e)return t?On:En;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class ir{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Le(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",w="rc.x";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${w};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const or={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class lr{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=a.backend_util.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const ur="return a * b;";function cr(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,i=a.backend_util.upcastType(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new lr(or.REAL,r.shape,s.shape),i=new lr(or.IMAG,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=Zn({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[a,o]=Lt(r.shape,s.shape,e.values,t.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=a,l}let o;return o=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gn(ur,r.shape,s.shape):new jn(ur,r.shape,s.shape),n.runWebGLProgram(o,[r,s],i)}const dr={kernelName:a.xu7,backendName:"webgl",kernelFunc:cr};function hr(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:i}=r,o=n,l=a.ZSL.sizeFromShape(s.shape),u=a.ZSL.inferFromImplicitShape(i,l),c=a.ZSL.sizeFromShape(u);a.ZSL.assert(l===c,(()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`));const d=o.texData.get(s.dataId);return!d.isPacked||ee(s.shape,u)||null!==d.texture&&ee(d.shape,u)?(o.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function(e,t,n){const r=[K(e.shape),...Y(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[K(t),...Y(t)],i=new fn(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,u,o)}const pr={kernelName:a.R23,backendName:"webgl",kernelFunc:hr};class fr{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:i}=e;this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${a.ZSL.isInt(e)?e.toPrecision(2):e}, ones);`}let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class mr{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function gr(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=a.backend_util.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let i=e;for(let a=0;a<s.length;a++){const{inSize:o,windowSize:l,outSize:u}=s[a];let c,d;c="mean"===n?0===a?new fr({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new fr({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new mr({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=i,i=r.runWebGLProgram(c,[i],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class br{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=$e(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class yr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=$e(this.rank),s=dn("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=s[e];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function wr(e,t,n){const r=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yr(e.shape,t):new br(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function vr(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:o}=r;return function(e,t,n,r){const s=t,i=e.shape.length,o=a.ZSL.parseAxisParam(s,e.shape);let l=o;const u=a.backend_util.getAxesPermutation(l,i),c=null!=u;let d=e;c&&(d=wr(e,u,r),l=a.backend_util.getInnerMostAxes(l.length,i)),a.backend_util.assertAxesAreInnerMostDims("sum",l,i);const[h,p]=a.backend_util.computeOutAndReduceShapes(d.shape,l);let f=h;n&&(f=a.backend_util.expandShapeToKeepDim(h,o));const m=a.ZSL.sizeFromShape(p),g=hr({inputs:{x:d},attrs:{shape:[a.ZSL.sizeFromShape(e.shape)/m,m]},backend:r}),b=gr(g,(0,a.chL)(e.dtype),"sum",r),y=hr({inputs:{x:b},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),c&&r.disposeIntermediateTensorInfo(d),y}(s,i,o,n)}const xr={kernelName:a.WuN,backendName:"webgl",kernelFunc:vr};function _r(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let e=0;e<l.length;e++)l[e]=s.shape[a[e]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=un(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=t}else u=wr(s,a,i);return u}const kr={kernelName:a.wx0,backendName:"webgl",kernelFunc:_r},Sr=1e3;function Tr({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}){const c=e.shape.length,d=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],p=r?t.shape[d-1]:t.shape[d-2],f=n?e.shape[c-1]:e.shape[c-2],m=r?t.shape[d-2]:t.shape[d-1],g=e.shape.slice(0,-2),b=t.shape.slice(0,-2),y=a.ZSL.sizeFromShape(g),w=a.ZSL.sizeFromShape(b),v=a.ZEY.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);a.ZSL.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const x=n?[y,h,f]:[y,f,h],_=r?[w,m,p]:[w,p,m],k=hr({inputs:{x:e},backend:s,attrs:{shape:x}}),S=hr({inputs:{x:t},backend:s,attrs:{shape:_}}),T=[k,S],I=Math.max(y,w),E=n?k.shape[1]:k.shape[2],A=null!=i,C=null!=o,N="leakyrelu"===u,$=null!=u?ar(u,!0):null;let O;if((1===f||1===m)&&E>Sr&&!1===(A||C||N||null!=$)){let e=k,t=S;n&&(e=_r({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),T.push(e)),r&&(t=_r({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),T.push(t));const a=1===m;let i=e;1!==m&&(i=hr({inputs:{x:e},backend:s,attrs:{shape:[I,E,1]}}),T.push(i));const o=1===m?2:1;let l=t;a&&(l=hr({inputs:{x:t},backend:s,attrs:{shape:[I,1,E]}}),T.push(l));const u=cr({inputs:{a:i,b:l},backend:s});O=vr({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{const u=(0,a.TuY)(e.dtype,t.dtype),c=new ir(x,_,[I,f,m],n,r,A,$,C,N),d=[k,S];if(null!=i&&d.push(i),C&&d.push(o),N){const e=s.makeTensorInfo([],"float32",a.ZSL.createScalarValue(l,"float32"));d.push(e),T.push(e)}O=s.runWebGLProgram(c,d,u)}const D=hr({inputs:{x:O},backend:s,attrs:{shape:v}});T.push(O);for(const e of T)s.disposeIntermediateTensorInfo(e);return D}const Ir={kernelName:a.Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return Tr({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},Er="return abs(x);",Ar={kernelName:a.ljI,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=Zt(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=(0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Dn(r.shape,Er):new wn(r.shape,Er),n.runWebGLProgram(s,[r],r.dtype)}},Cr=rr({opSnippet:vn+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Nr={kernelName:a.Vvy,backendName:"webgl",kernelFunc:Cr},$r=rr({opSnippet:vn+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Or={kernelName:a.PH8,backendName:"webgl",kernelFunc:$r},Dr="return a + b;",Fr=sr({opSnippet:Dr,packedOpSnippet:Dr,supportsComplex:!0,cpuKernelImpl:mt}),Rr={kernelName:a.OMN,backendName:"webgl",kernelFunc:Fr};class Mr{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class Lr{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const Pr={kernelName:a.EkD,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return Hn({inputs:{x:s[0]},backend:r});if(s.length>(0,a._K2)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const i=s.map((e=>e.dtype)).reduce(((e,t)=>(0,a.TuY)(e,t))),o=s.map((e=>e.shape)),l=(0,a._K2)().getBool("WEBGL_PACK")?new Lr(s[0].shape,o):new Mr(s[0].shape,o);return r.runWebGLProgram(l,s,i)}},zr={kernelName:a.u8Z,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:o}=r,l=s.shape.length,u=a.ZSL.parseAxisParam(i,s.shape);let c=u;const d=a.backend_util.getAxesPermutation(c,l);let h=s;null!=d&&(h=_r({inputs:{x:s},backend:n,attrs:{perm:d}}),c=a.backend_util.getInnerMostAxes(c.length,l)),a.backend_util.assertAxesAreInnerMostDims("all",c,l);const[p,f]=a.backend_util.computeOutAndReduceShapes(h.shape,c),m=hr({inputs:{x:h},backend:n,attrs:{shape:[-1,a.ZSL.sizeFromShape(f)]}}),g=gr(m,m.dtype,"all",n);let b;return b=hr(o?{inputs:{x:g},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(p,u)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),b}},Br={kernelName:a.FSt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:o}=r,l=s.shape.length,u=a.ZSL.parseAxisParam(i,s.shape);let c=u;const d=a.backend_util.getAxesPermutation(c,l);let h=s;null!=d&&(h=_r({inputs:{x:s},backend:n,attrs:{perm:d}}),c=a.backend_util.getInnerMostAxes(c.length,l)),a.backend_util.assertAxesAreInnerMostDims("any",c,l);const[p,f]=a.backend_util.computeOutAndReduceShapes(h.shape,c),m=hr({inputs:{x:h},backend:n,attrs:{shape:[-1,a.ZSL.sizeFromShape(f)]}}),g=gr(m,m.dtype,"any",n);let b;return b=hr(o?{inputs:{x:g},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(p,u)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),b}};class Vr{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Ur{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,a.ZSL.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],i=Math.ceil(s/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=$e(l),c=hn("coords",l);let d,h;if(1===i){h=l+1;const e=$e(h);d=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[l-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map((e=>"int "+e)),g=hn("sourceLocR",h-1).concat("inIdx.r"),b=hn("sourceLocG",h-1).concat("inIdx.g"),y=hn("sourceLocB",h-1).concat("inIdx.b"),w=hn("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${w.join()})));`,_=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${b.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${_};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${_};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function jr(e,t,n,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const o=a.backend_util.computeOptimalWindowSize(i),l={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},u=new Vr(l,n,null==r),c=[t];null!=r&&c.push(r);const d=e.runWebGLProgram(u,c,"int32");if(1===d.shape[1])return d;const h=jr(e,t,n,d);return e.disposeIntermediateTensorInfo(d),h}function Wr(e,t,n,r=null){const s=null!=r?r.shape:t.shape,i=s[s.length-1],o=a.backend_util.computeOptimalWindowSize(i),l=new Ur(s,o,n,null==r),u=null==r?[t]:[t,r],c=e.runWebGLProgram(l,u,"int32");if(c.shape.length===t.shape.length){const r=Wr(e,t,n,c);return e.disposeIntermediateTensorInfo(c),r}return c}function Gr(e,t,n,r){const s=[n];if(a.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!(0,a._K2)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],i=e.texData.get(t.dataId);let o=t;null!==i&&i.isPacked&&(o=e.unpackTensor(t),n.push(o));const[l,u]=a.backend_util.computeOutAndReduceShapes(o.shape,s),c=a.ZSL.sizeFromShape(u),d=hr({inputs:{x:o},backend:e,attrs:{shape:[-1,c]}});n.push(d);const h=jr(e,d,r);n.push(h);const p=hr({inputs:{x:h},backend:e,attrs:{shape:l}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),p}return Wr(e,t,r)}const Hr={kernelName:a.Jp_,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i}=r;let o=a.ZSL.parseAxisParam(i,s.shape);const l=a.backend_util.getAxesPermutation(o,s.shape.length);let u=s;const c=[];null!=l&&(u=_r({inputs:{x:s},backend:n,attrs:{perm:l}}),c.push(u),o=a.backend_util.getInnerMostAxes(o.length,u.shape.length)),a.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);const d=Gr(n,u,o[0],"max");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},qr={kernelName:a.p_m,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i}=r;let o=a.ZSL.parseAxisParam(i,s.shape);const l=a.backend_util.getAxesPermutation(o,s.shape.length);let u=s;const c=[];null!=l&&(u=_r({inputs:{x:s},backend:n,attrs:{perm:l}}),c.push(u),o=a.backend_util.getInnerMostAxes(o.length,u.shape.length)),a.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);const d=Gr(n,u,o[0],"min");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},Zr=rr({opSnippet:vn+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Kr={kernelName:a.QKF,backendName:"webgl",kernelFunc:Zr},Yr=rr({opSnippet:vn+"return log(x + sqrt(x * x + 1.0));"}),Xr={kernelName:a.epO,backendName:"webgl",kernelFunc:Yr},Qr=rr({opSnippet:vn+"\n  return atan(x);\n"}),Jr={kernelName:a.TyE,backendName:"webgl",kernelFunc:Qr},es=sr({opSnippet:Un+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Wn+"\n  return result;\n"}),ts={kernelName:a.lxb,backendName:"webgl",kernelFunc:es},ns=rr({opSnippet:vn+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),rs={kernelName:a.zP9,backendName:"webgl",kernelFunc:ns};class ss{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),v=a%4,x=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${x}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${x}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class as{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let w="0.0";if(y||(w="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const x=4*Math.floor(a/4),_=a%4,k=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n        }\n        setOutput(${v});\n      }\n    `}}const is={kernelName:a.ho8,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;fe(s,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const c=a.backend_util.computePool2DInfo(s.shape,i,o,1,l,u);if(1===c.filterWidth&&1===c.filterHeight&&a.ZSL.arraysEqual(c.inShape,c.outShape))return Hn({inputs:{x:s},backend:n});const d=new ss(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}},os={kernelName:a.cS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u,dataFormat:c}=r,d=a.backend_util.computePool3DInfo(s.shape,i,o,[1,1,1],l,u,c),h=new as(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class ls{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class us{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const cs={kernelName:a.wwC,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,o=i,{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=a.backend_util.computePool3DInfo(o.shape,l,u,[1,1,1],c,d),p=new us(h);return n.runWebGLProgram(p,[s],o.dtype)}},ds={kernelName:a.VCH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,o=i;fe([s,i],"avgPoolGrad");const{filterSize:l,strides:u,pad:c}=r,d=a.backend_util.computePool2DInfo(o.shape,l,u,1,c),h=new ls(d);return n.runWebGLProgram(h,[s],o.dtype)}},hs={kernelName:a.jAQ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return Tr({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class ps{constructor(e,t,n,r,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],a.backend_util.assertAndGetBroadcastShape(e,t),a.backend_util.assertAndGetBroadcastShape(e,n);let o="0.0";null!=r&&(a.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";null!=s&&(a.backend_util.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class fs{constructor(e,t,n,r,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],a.backend_util.assertAndGetBroadcastShape(e,t),a.backend_util.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=r&&(a.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=s&&(a.backend_util.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const ms={kernelName:a.i5R,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:i,offset:o,scale:l}=e;a.ZSL.assert(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.ZSL.assert(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.ZSL.assert(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=n;null==u&&(u=.001);const c=[r,s,i];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));const p=(0,a._K2)().getBool("WEBGL_PACK_NORMALIZATION")?new fs(r.shape,s.shape,i.shape,d,h,u):new ps(r.shape,s.shape,i.shape,d,h,u);return t.runWebGLProgram(p,c,c[0].dtype)}};class gs{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=$e(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return bs.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${bs[t]} = start[${t}] + coords.${bs[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const bs=["x","y","z","w","u","v"];class ys{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=$e(this.rank),n=hn("coords",this.rank),r=hn("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function ws(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:i,size:o}=r,[l,u]=a.Kro.parseSliceParams(s,i,o);if(a.Kro.assertParamsValid(s,l,u),0===a.ZSL.sizeFromShape(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=Kt(e.values,l,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:c}=n.texData.get(s.dataId),d=a.Kro.isSliceContinous(s.shape,l,u);if(c||!d){const e=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ys(u):new gs(u),t=[l];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),i=r.makeTensorInfo(n,e.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=n,o.dtype=e.dtype;let l=a.Kro.computeFlatOffset(t,a.ZSL.computeStrides(e.shape));s.slice&&(l+=s.slice.flatOffset),o.slice={flatOffset:l,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),i}(s,l,u,n)}const vs={kernelName:a.JiE,backendName:"webgl",kernelFunc:ws},xs={kernelName:a.Ik2,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:i,crops:o}=r;a.ZSL.assert(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const l=i.reduce(((e,t)=>e*t)),u=a.backend_util.getReshaped(s.shape,i,l),c=a.backend_util.getPermuted(u.length,i.length),d=a.backend_util.getReshapedPermuted(s.shape,i,l),h=a.backend_util.getSliceBeginCoords(o,i.length),p=a.backend_util.getSliceSize(d,o,i.length),f=[],m=hr({inputs:{x:s},backend:n,attrs:{shape:u}}),g=_r({inputs:{x:m},backend:n,attrs:{perm:c}}),b=hr({inputs:{x:g},backend:n,attrs:{shape:d}}),y=ws({inputs:{x:b},backend:n,attrs:{begin:h,size:p}});return f.push(m),f.push(g),f.push(b),f.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},_s={kernelName:a.N4F,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=gt(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}},ks={kernelName:a.HNs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,i=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=(0,a._K2)().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===o){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=yt(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let l;return l=i?new Gn("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new jn("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(l,[r,s],r.dtype)}},Ss={kernelName:a.vj7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=a.backend_util.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeTensorInfo([l.length],"int32",Int32Array.from(l))}},Ts=sr({opSnippet:"return float(a != b);",cpuKernelImpl:zt,dtype:"bool"}),Is={kernelName:a.ylV,backendName:"webgl",kernelFunc:Ts};function Es(e){const{inputs:t,backend:n}=e,{input:r}=t;return Hn({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const As={kernelName:a.LRy,backendName:"webgl",kernelFunc:Es},Cs={kernelName:a.KXH,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:i}=n,{dtype:o}=s;if("complex64"===o){if("complex64"===i.dtype)return Hn({inputs:{x:i},backend:r});const t=a.Ul9(i.shape),n=e({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),s=Zn({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===i.dtype){const t=Es({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(t),n}if(!a.ZSL.hasEncodingLoss(i.dtype,o)){const e=Hn({inputs:{x:i},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(r.shouldExecuteOnCPU([i])){const e=r.texData.get(i.dataId).values,[t,n,s]=wt(e,i.shape,i.dtype,o);return r.makeTensorInfo(t,n,s)}if("int32"===o)return function(e,t){const n=new wn(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",a.ZSL.getTypedArrayFromDType("bool",1)),t=Ts({inputs:{a:i,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}},Ns="return ceil(x);",$s=rr({opSnippet:Ns,packedOpSnippet:Ns,cpuKernelImpl:vt}),Os={kernelName:a.QDP,backendName:"webgl",kernelFunc:$s};class Ds{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Fs{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Rs={kernelName:a.vaV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:i,clipValueMax:o}=r;let l;l=(0,a._K2)().getBool("WEBGL_PACK_CLIP")?new Fs(s.shape):new Ds(s.shape);const u=[[i],[o]];return n.runWebGLProgram(l,[s],s.dtype,u)}};class Ms{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Ls(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const Ps={kernelName:a.$zE,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new Ms(r.shape),i=[Ls(r,s.complexTensorInfos.real),Ls(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class zs{constructor(e){this.outputShape=[],this.outputShape=a.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Bs{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=a.backend_util.computeOutShape(e,t);const n=this.outputShape,r=n.length,s=$e(r),i=hn("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const l=new Array(e.length-1);l[0]=e[0][t];for(let n=1;n<l.length;n++)l[n]=l[n-1]+e[n][t];const u=o[t],c=o.slice(-2),d=o.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let e=1;e<l.length;e++){const t=l[e-1];h+=`\n        if (${u} < ${l[e]}  && ${u} >= ${l[e-1]}) {\n          return getChannel(\n            getT${e}(${Vs(o,u,t)}),\n            vec2(${Vs(c,u,t)}));\n        }`}const p=l.length,f=l[l.length-1];h+=`\n        return getChannel(\n          getT${p}(${Vs(o,u,f)}),\n          vec2(${Vs(c,u,f)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Vs(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function Us(e){const{inputs:t,backend:n}=e,{input:r}=t;return Hn({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const js={kernelName:a.dv8,backendName:"webgl",kernelFunc:Us};function Ws(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>Es({inputs:{input:e},backend:n}))),s=e.map((e=>Us({inputs:{input:e},backend:n}))),a=Ws(r,t,n),i=Ws(s,t,n),o=Zn({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=a.ZSL.sizeFromShape(e.shape.slice(t));return hr({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),i=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=a.backend_util.computeOutShape(s.map((e=>e.shape)),1),l=1===s[0].shape[0],u=xt(i,o,r,l),c=a.backend_util.computeOutShape(e.map((e=>e.shape)),t),d=n.makeTensorInfo(c,r,u);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}const i=e.filter((e=>a.ZSL.sizeFromShape(e.shape)>0)),o=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const t=o?new wn(e[0].shape,In):new Dn(e[0].shape,In);return n.runWebGLProgram(t,e,r)}const l=(0,a._K2)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const e=[];for(let r=0;r<i.length;r+=l){const s=i.slice(r,r+l);e.push(Ws(s,t,n))}const r=Ws(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(o){const e=new Bs(i.map((e=>e.shape)),t);return n.runWebGLProgram(e,i,r)}const{tensors2D:u,outShape:c}=function(e,t,n){const r=a.backend_util.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>hr({inputs:{x:e},attrs:{shape:[-1,a.ZSL.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(i,t,n),d=new zs(u.map((e=>e.shape))),h=n.runWebGLProgram(d,u,r);u.forEach((e=>n.disposeIntermediateTensorInfo(e)));const p=hr({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),p}function Gs(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,i=a.ZSL.parseAxisParam(s,t[0].shape)[0],o=t.map((e=>e.shape));a.backend_util.assertParamsConsistent(o,i);const l=a.backend_util.computeOutShape(t.map((e=>e.shape)),i);if(0===a.ZSL.sizeFromShape(l))return n.makeTensorInfo(l,t[0].dtype,[]);const u=t.filter((e=>a.ZSL.sizeFromShape(e.shape)>0));return 1===u.length?Hn({inputs:{x:u[0]},backend:n}):Ws(u,i,n)}const Hs={kernelName:a.$dB,backendName:"webgl",kernelFunc:Gs};class qs{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let w="",v="";n&&(w=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${v}\n        setOutput(result);\n      }\n    `}}class Zs{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ks{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Le(this.outputShape.length);const i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)h+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<c;e++)h+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(d+1)/2;t++){const n=2*t;if(h+=`\n           xC = xCCorner + ${n*l};\n           `,1===o){if(n<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,h+=1===l&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<c)){const e=i%2==0?a.ZSL.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):h+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<c&&(h+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<c&&(h+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<c&&(h+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${f}\n         setOutput(result);\n       }\n     `}}class Ys{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Le(this.outputShape.length);const{dataFormat:n}=t,r=ge(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function Xs(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Qs({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape,c=r.texData.get(e.dataId),d=n.inChannels,h=u[0]*u[1]*u[2],p=n.outChannels,f="channelsLast"===n.dataFormat,m=!1;let g;const b=[];if(null!=i){const e=Xs(i.shape,f);null!=e&&(i=hr({inputs:{x:i},backend:r,attrs:{shape:e}}),b.push(i))}if(null!=s){const e=Xs(s.shape,f);null!=e&&(s=hr({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}if((1!==h&&1!==p||!(d>Sr))&&c.isPacked&&f&&null!=c.texture&&u[2]%2!=0&&a.ZSL.arraysEqual(c.shape.slice(-3),u.slice(-3))){const d=u[0]*u[1]*(u[2]+1),h={dataId:e.dataId,shape:[1,d,n.inChannels],dtype:e.dtype},p=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,a.ZSL.assert(ee(c.shape,h.shape),(()=>`packed reshape ${c.shape} to ${h.shape} isn't free`));const f=hr({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(f);const y=Tr({a:h,b:f,backend:r,transposeA:!1,transposeB:m,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),w=r.texData.get(y.dataId);a.ZSL.assert(w.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=p,w.shape=n.outShape,g=Hn({inputs:{x:y},backend:r}),g.shape=n.outShape,b.push(y)}else{const a=n.outHeight*n.outWidth,u=hr({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,a,n.inChannels]:[n.batchSize,n.inChannels,a]}}),c=hr({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=Tr({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:r,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=hr({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),b.push(u),b.push(c),b.push(d)}for(const e of b)r.disposeIntermediateTensorInfo(e);return g}function Js({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=n,m="channelsLast"===f,g=u*c*d,b=p*h,y=[n.batchSize,g,b],w=[];if(null!=i){const e=Xs(i.shape,m);null!=e&&(i=hr({inputs:{x:i},backend:r,attrs:{shape:e}}),w.push(i))}if(null!=s){const e=Xs(s.shape,m);null!=e&&(s=hr({inputs:{x:s},backend:r,attrs:{shape:e}}),w.push(s))}const v=hr({inputs:{x:t},backend:r,attrs:{shape:[1,g,a.ZSL.sizeFromShape(t.shape)/g]}});w.push(v);const x=new Ys(y,n),_=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(x,[e],"float32",_),S=hr({inputs:{x:k},backend:r,attrs:{shape:y}});w.push(k),w.push(S);const T=null!=s,I=null!=i,E="leakyrelu"===l,A=l?ar(l,!0):null,C=new ir(m?S.shape:v.shape,m?v.shape:S.shape,m?[n.batchSize,b,n.outChannels]:[n.batchSize,n.outChannels,b],!0,!1,T,A,I,E),N=m?[S,v]:[v,S];if(s&&N.push(s),I&&N.push(i),E){const e=r.makeTensorInfo([],"float32",a.ZSL.createScalarValue(o,"float32"));N.push(e),w.push(e)}const $=r.runWebGLProgram(C,N,"float32"),O=hr({inputs:{x:$},backend:r,attrs:{shape:n.outShape}});w.push($);for(const e of w)r.disposeIntermediateTensorInfo(e);return O}const ea={kernelName:a.p2J,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d}=r,h=a.backend_util.convertConv2DDataFormat(u),p=a.backend_util.computeConv2DInfo(s.shape,i.shape,o,c,l,d,!1,h);let f;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&(0,a._K2)().getBool("WEBGL_EXP_CONV")){const e=new Ks(p),t=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];f=n.runWebGLProgram(e,[s,i],"float32",t)}else if((0,a._K2)().getBool("WEBGL_CONV_IM2COL"))f=Js({x:s,filter:i,convInfo:p,backend:n});else{const e=new qs(p);f=n.runWebGLProgram(e,[s,i],"float32")}else f=Qs({x:s,filter:i,convInfo:p,backend:n});const m=hr({inputs:{x:f},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(f),m}};class ta{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class na{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ra{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sa{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const aa={kernelName:a.rFm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:o,pad:l,dataFormat:u,dimRoundingMode:c,filterShape:d}=r,h=a.backend_util.convertConv2DDataFormat(u),p=a.backend_util.computeConv2DInfo(s.shape,d,o,1,l,c,!1,h),f=new ta(p);return n.runWebGLProgram(f,[s,i],"float32")}};class ia{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Le(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const oa={kernelName:a.jfg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{inputShape:o,strides:l,pad:u,dataFormat:c,dimRoundingMode:d}=r,h=a.backend_util.convertConv2DDataFormat(c),p=a.backend_util.computeConv2DInfo(o,i.shape,l,1,u,d,!1,h);if((0,a._K2)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[p.strideHeight,p.strideWidth]],t=new ia(p);return n.runWebGLProgram(t,[s,i],"float32",e)}{const e=new na(p);return n.runWebGLProgram(e,[s,i],"float32")}}},la={kernelName:a.A1h,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:o,pad:l,dilations:u}=r,c=a.backend_util.computeConv3DInfo(s.shape,i.shape,o,u,l),d=new Zs(c);return n.runWebGLProgram(d,[s,i],"float32")}},ua={kernelName:a.iGz,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:o,pad:l,filterShape:u}=r,c=a.backend_util.computeConv3DInfo(s.shape,u,o,1,l),d=new ra(c);return n.runWebGLProgram(d,[s,i],"float32")}},ca={kernelName:a.gC7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{pad:o,strides:l,inputShape:u}=r,c=a.backend_util.computeConv3DInfo(u,i.shape,l,1,o),d=new sa(c);return n.runWebGLProgram(d,[s,i],"float32")}},da=rr({opSnippet:nr+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Wn}\n  return result;\n`}),ha={kernelName:a.Mn0,backendName:"webgl",kernelFunc:da},pa=rr({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),fa={kernelName:a.MnK,backendName:"webgl",kernelFunc:pa};class ma{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,b]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,w,v]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${w};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const ga={kernelName:a.MRQ,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new ma(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var ba;!function(e){e.Prod="*",e.Sum="+"}(ba||(ba={}));class ya{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===ba.Prod?"1.0":"0.0",i=n?a:`getX(${wa(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${$e(s)} coords = getOutputCoords();\n        int end = ${va(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${va(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${wa(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function wa(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function va(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function xa(e,t,n,r,s,i){const o=t.shape.length,l=a.backend_util.getAxesPermutation([r],o);let u=t;null!=l&&(u=_r({inputs:{x:t},backend:n,attrs:{perm:l}}));const c=a.backend_util.getInnerMostAxes(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const d=u.shape[c];let h=Hn({inputs:{x:u},backend:n});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){const r=new ya(e,u.shape,!1,i),s=[[t]],a=h;h=n.runWebGLProgram(r,[h],h.dtype,s),n.disposeIntermediateTensorInfo(a)}if(s){const t=new ya(e,u.shape,s,i),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=l){const e=_r({inputs:{x:h},backend:n,attrs:{perm:a.backend_util.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),e}return h}const _a={kernelName:a.jj_,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return xa(ba.Prod,s,n,a,i,o)}},ka={kernelName:a.nY8,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return xa(ba.Sum,s,n,a,i,o)}},Sa={kernelName:a.wNW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=gt(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=bt(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class Ta{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Ia={kernelName:a.TMz,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),d=new Ta("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(d,[s],s.dtype)}};class Ea{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Le(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class Aa{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Le(this.outputShape.length);const i=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<d;e++)p+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;p+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<d;e++)p+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(h+1)/2;e++){const t=2*e;if(p+=`\n          xC = xCCorner + ${t*u};\n          `,1===l){if(t<d&&(o%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,p+=1===u&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<d)){const e=o%2==0?a.ZSL.nearestLargerEven(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,p+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):p+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<d&&(o%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<d&&(p+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<d&&(p+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<d&&(p+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",m="";n&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const Ca={kernelName:a.tGH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:o,pad:l,dilations:u,dimRoundingMode:c}=r;let d=u;null==d&&(d=[1,1]),a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(o,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`));const h=a.backend_util.computeConv2DInfo(s.shape,i.shape,o,d,l,c,!0);let p;p=(0,a._K2)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new Aa(h):new Ea(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(p,[s,i],"float32",f)}};class Na{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $a{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Oa={kernelName:a.X$8,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:o,dilations:l,pad:u,dimRoundingMode:c,filterShape:d}=r,h=a.backend_util.computeConv2DInfo(s.shape,d,o,l,u,c,!0),p=new Na(h);return n.runWebGLProgram(p,[s,i],"float32")}},Da={kernelName:a.nVu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{strides:o,dilations:l,pad:u,dimRoundingMode:c,inputShape:d}=r,h=a.backend_util.computeConv2DInfo(d,i.shape,o,l,u,c,!0),p=new $a(h);return n.runWebGLProgram(p,[s,i],"float32")}};class Fa{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Ra={kernelName:a.ORI,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],i=a.ZSL.sizeFromShape(r.shape),o=hr({inputs:{x:r},backend:n,attrs:{shape:[i]}}),l=new Fa(i),u=n.runWebGLProgram(l,[o],o.dtype),c=hr({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),c}};class Ma{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const La={kernelName:a.jxD,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:o,pad:l,dilations:u}=r,c=a.backend_util.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u);let d;const h=new Ma(c);d=n.runWebGLProgram(h,[s,i],"float32");const p=hr({inputs:{x:d},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(d),p}},Pa={kernelName:a.Qgm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,i=t,{allDims:o,summedDims:l,idDims:u}=a.backend_util.decodeEinsumEquation(s,i.length);a.backend_util.checkEinsumDimSizes(o.length,u,i);const{path:c,steps:d}=a.backend_util.getEinsumComputePath(l,u),h=d.length;let p=null,f=o.length;const m=[];for(let e=0;e<h;++e){for(const t of d[e]){const{permutationIndices:e,expandDims:r}=a.backend_util.getEinsumPermutation(f,u[t]);let s;a.backend_util.isIdentityPermutation(e)?s=i[t]:(s=_r({inputs:{x:i[t]},backend:n,attrs:{perm:e}}),m.push(s));const o=s.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);a.ZSL.arraysEqual(s.shape,o)||(s=hr({inputs:{x:s},backend:n,attrs:{shape:o}}),m.push(s)),null===p?p=s:(p=cr({inputs:{a:s,b:p},backend:n}),m.push(p))}e<h-1&&(c[e]>=0&&(p=vr({inputs:{x:p},backend:n,attrs:{axis:c[e]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeIntermediateTensorInfo(e);return p}},za=rr({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Ba={kernelName:a.Pah,backendName:"webgl",kernelFunc:za},Va={kernelName:a.rsH,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,i=(0,a._K2)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gn("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new jn("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(i,[r,s],r.dtype)}},Ua=sr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:_t}),ja={kernelName:a.BRl,backendName:"webgl",kernelFunc:Ua},Wa=rr({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${a.backend_util.ERF_P};\n  float a1 = ${a.backend_util.ERF_A1};\n  float a2 = ${a.backend_util.ERF_A2};\n  float a3 = ${a.backend_util.ERF_A3};\n  float a4 = ${a.backend_util.ERF_A4};\n  float a5 = ${a.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Ga={kernelName:a._s9,backendName:"webgl",kernelFunc:Wa},Ha=rr({opSnippet:nr+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:kt,dtype:"float32"}),qa={kernelName:a.ox3,backendName:"webgl",kernelFunc:Ha};function Za(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:i}=t,o=i.shape.length,l=i.shape.slice();let u=s;return s<0&&(a.ZSL.assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),u=o+s+1),l.splice(u,0,1),hr({inputs:{x:i},backend:r,attrs:{shape:l}})}const Ka={kernelName:a.ybN,backendName:"webgl",kernelFunc:Za},Ya="return exp(x) - 1.0;",Xa=rr({opSnippet:Ya,packedOpSnippet:Ya,cpuKernelImpl:St}),Qa={kernelName:a.ybj,backendName:"webgl",kernelFunc:Xa};class Ja{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function ei(e,t,n){const r=n.texData.get(e.dataId),s=a.ZSL.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=hr({inputs:{x:e},backend:n,attrs:{shape:[s/i,i]}}),l=o.shape,u=new Ja("real",l,t),c=new Ja("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Zn({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=hr({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}const ti={kernelName:a.rGP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ei(r,!1,n)}};class ni{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function ri(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:i}=n;if(i=i||a.ZSL.inferDtype(s),"string"===i){const e=a.ZSL.getArrayFromDType(i,a.ZSL.sizeFromShape(r));return e.fill(s),t.makeTensorInfo(r,i,e)}{const e=new ni(r,s),n=[[s]];return t.runWebGLProgram(e,[],i,n)}}const si={kernelName:a.SQl,backendName:"webgl",kernelFunc:ri};class ai{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ii={kernelName:a.BxF,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new ai(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},oi="return floor(x);",li=rr({opSnippet:oi,packedOpSnippet:oi,cpuKernelImpl:Tt}),ui={kernelName:a.ZgB,backendName:"webgl",kernelFunc:li},ci=sr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),di={kernelName:a.ElG,backendName:"webgl",kernelFunc:ci};class hi{constructor(e){this.variableNames=["A"];const t=ge(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class pi{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ge(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const fi={kernelName:a.awo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:i}=r,o="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],h=[c,u],p=[c,u,i];if(l||o){const e=(0,a._K2)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=mi&&e===gi||(gi=e,mi=document.createElement("canvas").getContext("2d",{willReadFrequently:gi})),mi.canvas.width=u,mi.canvas.height=c,mi.drawImage(s,0,0,u,c),s=mi.canvas}const f=n.makeTensorInfo(h,"int32");n.texData.get(f.dataId).usage=d.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),s);const m=(0,a._K2)().getBool("WEBGL_PACK")?new pi(p):new hi(p),g=n.runWebGLProgram(m,[f],"int32");return n.disposeData(f.dataId),g}};let mi,gi=(0,a._K2)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const bi={kernelName:a.aAr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=t,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=r,g=a.backend_util.convertConv2DDataFormat(d),b=a.backend_util.computeConv2DInfo(s.shape,i.shape,u,h,c,p,!1,g);let y;const w=[],v=null!=o,x=null!=l,_="leakyrelu"===f,k=()=>{const e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=hr({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return w.push(t),t}return e};if(v&&e.push(t(o,d)),x&&e.push(t(l,d)),_){const t=n.makeTensorInfo([],"float32",a.ZSL.createScalarValue(m,"float32"));e.push(t),w.push(t)}return e};if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(b.strideWidth<=2&&"channelsLast"===g&&(0,a._K2)().getBool("WEBGL_EXP_CONV")){const e=f?ar(f,!0):null,t=new Ks(b,v,e,x,_),r=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",r)}else if((0,a._K2)().getBool("WEBGL_CONV_IM2COL"))y=Js({x:s,filter:i,convInfo:b,backend:n,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{const e=f?ar(f,!1):null,t=new qs(b,v,e,x,_),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=Qs({x:s,filter:i,convInfo:b,backend:n,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});const S=hr({inputs:{x:y},backend:n,attrs:{shape:b.outShape}});return w.push(y),w.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}},yi={kernelName:a.T7M,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=t,{strides:u,pad:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=[];let g=d;null==g&&(g=[1,1]),a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`));const b=a.backend_util.computeConv2DInfo(s.shape,i.shape,u,g,c,h,!0),y=(0,a._K2)().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels==1,w=p?ar(p,y):null,v=[s,i],x=null!=o,_=null!=l,k="leakyrelu"===p;if(x&&v.push(o),_&&v.push(l),k){const e=n.makeTensorInfo([],"float32",a.ZSL.createScalarValue(f,"float32"));v.push(e),m.push(e)}let S;S=y?new Aa(b,x,w,_,k):new Ea(b,x,w,_,k);const T=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],I=n.runWebGLProgram(S,v,"float32",T);return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};class wi{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=$e(n.length);let a="\n    int index;";for(let e=0;e<this.sliceDim;e++)a+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const vi={kernelName:a.O4G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,i=s.shape,o=i[i.length-1],l=a.ZSL.sizeFromShape(r.shape),[u,c,d,h]=a.backend_util.prepareAndValidate(r,s),p=hr({inputs:{x:s},backend:n,attrs:{shape:[c,o]}}),f=hr({inputs:{x:r},backend:n,attrs:{shape:[a.ZSL.sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=It(e,t,r.dtype,c,o,d,h,r.shape,l);return n.makeTensorInfo(u,r.dtype,a.values)}const m=new wi(o,h,[c,d],r.shape),g=n.runWebGLProgram(m,[f,p],f.dtype),b=hr({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),b}};class xi{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=$e(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function _i(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:i}=t,{axis:o,batchDims:l}=r,u=a.ZSL.parseAxisParam(o,s.shape)[0];if((0,a._K2)().get("DEBUG")){const e=n.readSync(i.dataId),t=s.shape[u];for(let n=0;n<e.length;++n){const r=e[n];a.ZSL.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const c=a.backend_util.segment_util.collectGatherOpShapeInfo(s,i,u,l),d=a.ZSL.sizeFromShape(i.shape),h=[],p=hr({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=hr({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}});h.push(p),h.push(f);const m=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const e=n.bufferSync(f),t=n.bufferSync(p),r=Et(t,e,m);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const g=new xi(p.shape,m),b=n.runWebGLProgram(g,[p,f],p.dtype);h.push(b);const y=hr({inputs:{x:b},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const ki={kernelName:a.mxL,backendName:"webgl",kernelFunc:_i},Si=sr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:At,dtype:"bool"}),Ti={kernelName:a.XhZ,backendName:"webgl",kernelFunc:Si},Ii=sr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Ct}),Ei={kernelName:a.lLS,backendName:"webgl",kernelFunc:Ii},Ai={kernelName:a.OAQ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return ei(r,!0,n)}},Ci=rr({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Ni={kernelName:a.gIW,backendName:"webgl",kernelFunc:Ci},$i=rr({opSnippet:"return float(isinf(x));",dtype:"bool"}),Oi={kernelName:a.E3$,backendName:"webgl",kernelFunc:$i},Di=rr({opSnippet:"return float(isnan(x));",dtype:"bool"}),Fi={kernelName:a.iPs,backendName:"webgl",kernelFunc:Di},Ri=sr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Nt,dtype:"bool"}),Mi={kernelName:a.mIA,backendName:"webgl",kernelFunc:Ri},Li=sr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:$t,dtype:"bool"}),Pi={kernelName:a.CwD,backendName:"webgl",kernelFunc:Li},zi={kernelName:a.mnI,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=Ot(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},Bi=rr({opSnippet:nr+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Dt}),Vi={kernelName:a.tG8,backendName:"webgl",kernelFunc:Bi},Ui=rr({opSnippet:nr+"\n  return log(1.0 + x);\n"}),ji={kernelName:a.Cg$,backendName:"webgl",kernelFunc:Ui},Wi=sr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Gi={kernelName:a.RUm,backendName:"webgl",kernelFunc:Wi},Hi=rr({opSnippet:"return float(!(x >= 1.0));"}),qi={kernelName:a.nZd,backendName:"webgl",kernelFunc:Hi},Zi=sr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Ki={kernelName:a.LXA,backendName:"webgl",kernelFunc:Zi};class Yi{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class Xi{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const Qi={kernelName:a.jM4,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:i,bias:o,alpha:l,beta:u}=r,c=(0,a._K2)().getBool("WEBGL_PACK_NORMALIZATION")?new Xi(s.shape,i,o,l,u):new Yi(s.shape,i,o,l,u);return n.runWebGLProgram(c,[s],s.dtype)}};class Ji{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const eo={kernelName:a.ToN,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new Ji(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)}};function to(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:i,keepDims:o}=r,l=s.shape.length,u=a.ZSL.parseAxisParam(i,s.shape);let c=u;const d=a.backend_util.getAxesPermutation(c,l),h=null!=d,p=n.shouldExecuteOnCPU([s]);let f=s;if(h){if(p){const e=n.texData.get(f.dataId).values,t=new Array(l);for(let e=0;e<t.length;e++)t[e]=s.shape[d[e]];const r=un(e,s.shape,s.dtype,d,t);f=n.makeTensorInfo(t,s.dtype),n.texData.get(f.dataId).values=r}else f=wr(s,d,n);c=a.backend_util.getInnerMostAxes(c.length,l)}a.backend_util.assertAxesAreInnerMostDims("max",c,l);const[m,g]=a.backend_util.computeOutAndReduceShapes(f.shape,c);let b,y=m;if(o&&(y=a.backend_util.expandShapeToKeepDim(m,u)),p){const e=n.texData.get(f.dataId).values,t=Ft(e,a.ZSL.sizeFromShape(g),y,s.dtype);b=n.makeTensorInfo(y,s.dtype),n.texData.get(b.dataId).values=t}else b=function(e,t,n,r){const s=a.ZSL.sizeFromShape(t),i=hr({inputs:{x:e},attrs:{shape:[a.ZSL.sizeFromShape(e.shape)/s,s]},backend:r}),o=gr(i,e.dtype,"max",r),l=hr({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}(f,g,y,n);return h&&n.disposeIntermediateTensorInfo(f),b}const no={kernelName:a.VAI,backendName:"webgl",kernelFunc:to},ro=sr({opSnippet:Un+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Wn+"\n  return result;\n",cpuKernelImpl:Rt}),so={kernelName:a.LDN,backendName:"webgl",kernelFunc:ro},ao={kernelName:a.t3d,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;fe(s,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const c=a.backend_util.computePool2DInfo(s.shape,i,o,1,l,u);if(1===c.filterWidth&&1===c.filterHeight&&a.ZSL.arraysEqual(c.inShape,c.outShape))return Hn({inputs:{x:s},backend:n});const d=new ss(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}},io={kernelName:a.ySp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=a.backend_util.computePool3DInfo(s.shape,i,o,[1,1,1],l,c,u),h=new as(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class oo{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lo{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const uo={kernelName:a.cHb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,o=i,{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=a.backend_util.computePool3DInfo(o.shape,l,u,[1,1,1],c,d),p=new as(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new lo(h),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},co={kernelName:a.RXX,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i,output:o}=t,l=i;fe([i,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:h}=r,p=a.backend_util.computePool2DInfo(l.shape,u,c,1,d,h),f=new ss(p,"max",!0),m=n.runWebGLProgram(f,[l],l.dtype),g=new oo(p),b=n.runWebGLProgram(g,[s,m],l.dtype);return n.disposeIntermediateTensorInfo(m),b}},ho={kernelName:a.TL8,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=t,u=n;a.ZSL.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];a.ZSL.assert(a.backend_util.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=a.backend_util.computePool2DInfo(r.shape,s,i,c,o),[h,p]=function(e,t,n,r){let s=new ss(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new ss(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,l,d,u);return[h,p]}},po={kernelName:a.g5A,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:i}=t,o=n,l=r.shape.length,u=a.ZSL.parseAxisParam(i,r.shape);let c=u;const d=a.backend_util.getAxesPermutation(c,l),h=null!=d,p=o.shouldExecuteOnCPU([r]),f=[];let m=r;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let e=0;e<t.length;e++)t[e]=r.shape[d[e]];const n=un(e,r.shape,r.dtype,d,t);m=o.makeTensorInfo(t,r.dtype),o.texData.get(m.dataId).values=n}else m=wr(r,d,o);f.push(m),c=a.backend_util.getInnerMostAxes(c.length,l)}a.backend_util.assertAxesAreInnerMostDims("sum",c,l);const[g,b]=a.backend_util.computeOutAndReduceShapes(m.shape,c);let y=g;s&&(y=a.backend_util.expandShapeToKeepDim(g,u));const w=function(e,t,n,r){const s=a.ZSL.sizeFromShape(t),i=hr({inputs:{x:e},attrs:{shape:[a.ZSL.sizeFromShape(e.shape)/s,s]},backend:r}),o=gr(i,"float32","mean",r),l=hr({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}(m,b,y,o);for(const e of f)o.disposeIntermediateTensorInfo(e);return w}},fo={kernelName:a.lNG,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:o}=r,l=s.shape.length,u=a.ZSL.parseAxisParam(i,s.shape);let c=u;const d=a.backend_util.getAxesPermutation(c,l);let h=s;null!=d&&(h=_r({inputs:{x:s},backend:n,attrs:{perm:d}}),c=a.backend_util.getInnerMostAxes(c.length,s.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",c,l);const[p,f]=a.backend_util.computeOutAndReduceShapes(h.shape,c),m=hr({inputs:{x:h},backend:n,attrs:{shape:[-1,a.ZSL.sizeFromShape(f)]}}),g=gr(m,m.dtype,"min",n);let b;return b=hr(o?{inputs:{x:g},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(p,u)}}:{inputs:{x:g},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(h),b}},mo=sr({opSnippet:Un+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Wn+"\n  return result;\n",cpuKernelImpl:Mt}),go={kernelName:a.LG0,backendName:"webgl",kernelFunc:mo};class bo{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=$e(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class yo{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=$e(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=hn("rc",r),l=hn("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const wo={kernelName:a.x7F,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:i}=n,o=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yo(r.shape,s,i):new bo(r.shape,s,i);return t.runWebGLProgram(o,[r],r.dtype)}},vo=sr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Wn+"\n  return result;\n"}),xo={kernelName:a.BLA,backendName:"webgl",kernelFunc:vo};class _o{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const ko=sr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),So={kernelName:a.sDr,backendName:"webgl",kernelFunc:ko},To="return a - b;",Io=sr({opSnippet:To,packedOpSnippet:To,supportsComplex:!0,cpuKernelImpl:an}),Eo={kernelName:a.PbM,backendName:"webgl",kernelFunc:Io};function Ao(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:i}=r,o=a.ZSL.parseAxisParam([i],s.shape),l=to({inputs:{x:s},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=a.backend_util.expandShapeToKeepDim(l.shape,o),c=hr({inputs:{x:l},backend:n,attrs:{shape:u}}),d=Io({inputs:{a:s,b:c},backend:n}),h=Ha({inputs:{x:d},backend:n}),p=vr({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),f=hr({inputs:{x:p},backend:n,attrs:{shape:u}}),m=ko({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}const Co={kernelName:a.rFG,backendName:"webgl",kernelFunc:Ao},No={kernelName:a.WT3,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:Ao({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new _o(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},$o=vn+"\n  return -x;\n",Oo={kernelName:a.l0G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=Pt(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=(0,a._K2)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Dn(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new wn(r.shape,$o),n.runWebGLProgram(s,[r],r.dtype)}},Do=a.kpo.nonMaxSuppressionV3Impl,Fo={kernelName:a.SDM,backendName:"webgl",kernelFunc:function(e){a.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=r,c=n.readSync(s.dataId),d=n.readSync(i.dataId),{selectedIndices:h}=Do(c,d,o,l,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Ro=a.kpo.nonMaxSuppressionV4Impl,Mo={kernelName:a.Zl4,backendName:"webgl",kernelFunc:function(e){a.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:c}=r,d=n.readSync(s.dataId),h=n.readSync(i.dataId),{selectedIndices:p,validOutputs:f}=Ro(d,h,o,l,u,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},Lo=a.kpo.nonMaxSuppressionV5Impl,Po={kernelName:a.e0f,backendName:"webgl",kernelFunc:function(e){a.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=r,d=n.readSync(s.dataId),h=n.readSync(i.dataId),p=o,f=l,m=u,g=c,{selectedIndices:b,selectedScores:y}=Lo(d,h,p,f,m,g);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class zo{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const Bo={kernelName:a.urI,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:i,depth:o,onValue:l,offValue:u}=r,c=a.ZSL.sizeFromShape(s.shape),d=new zo(c,o,l,u),h=hr({inputs:{x:s},backend:n,attrs:{shape:[c]}}),p=n.runWebGLProgram(d,[h],i);n.disposeIntermediateTensorInfo(h);const f=hr({inputs:{x:p},backend:n,attrs:{shape:[...s.shape,o]}});return n.disposeIntermediateTensorInfo(p),f}};function Vo(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Es({inputs:{input:r},backend:n}),t=Vo({inputs:{x:e},backend:n}),s=Us({inputs:{input:r},backend:n}),a=Vo({inputs:{x:s},backend:n}),i=Zn({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return ri({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Uo={kernelName:a.xJ3,backendName:"webgl",kernelFunc:Vo},jo={kernelName:a.LWX,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=Es({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=Us({inputs:{input:s},backend:r}),i=Vo({inputs:{x:a},backend:r}),o=Zn({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return ri({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},Wo={kernelName:a.mM$,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return Za({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach((e=>{a.ZSL.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),a.ZSL.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const l=[],u=Gs({inputs:t.map((e=>{const t=Za({inputs:{input:e},backend:n,attrs:{dim:s}});return l.push(t),t})),backend:n,attrs:{axis:s}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class Go{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=$e(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Ho{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=$e(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=hn("rc",r),l=hn("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const qo=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:i,constantValue:o}=r;if(0===a.ZSL.sizeFromShape(s.shape))return ri({backend:n,attrs:{shape:i.map(((e,t)=>e[0]+s.shape[t]+e[1])),value:o,dtype:s.dtype}});const l=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ho(s.shape,i,o):new Go(s.shape,i,o),u=[[o]];return n.runWebGLProgram(l,[s],s.dtype,u)},Zo={kernelName:a.ODT,backendName:"webgl",kernelFunc:qo},Ko=sr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Wn+"\n  return result;\n"}),Yo={kernelName:a.pyJ,backendName:"webgl",kernelFunc:Ko},Xo={kernelName:a.kdj,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:o}=r,l=s.shape.length,u=[],c=a.ZSL.parseAxisParam(i,s.shape);let d=c;const h=a.backend_util.getAxesPermutation(d,l);let p,f=s;if(null!=h&&(f=_r({inputs:{x:s},backend:n,attrs:{perm:h}}),d=a.backend_util.getInnerMostAxes(d.length,l),u.push(f)),a.backend_util.assertAxesAreInnerMostDims("prod",d,l),n.shouldExecuteOnCPU([f])){const e=n.texData.get(f.dataId).values,{outVals:t,outShape:r,outDtype:s}=Bt(f.shape,f.dtype,e,d);p=n.makeTensorInfo(r,s,t)}else{const[e,t]=a.backend_util.computeOutAndReduceShapes(f.shape,d),r=a.ZSL.sizeFromShape(t),i=hr({inputs:{x:f},backend:n,attrs:{shape:[-1,r]}}),o=gr(i,(0,a.chL)(s.dtype),"prod",n);p=hr({inputs:{x:o},backend:n,attrs:{shape:e}}),u.push(i),u.push(o)}if(o){u.push(p);const e=a.backend_util.expandShapeToKeepDim(p.shape,c);p=hr({inputs:{x:p},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},Qo={kernelName:a.oJ2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.readSync(e.dataId))),u=s.map((e=>e.shape)),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=Vt(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},Jo={kernelName:a.CQC,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Ut(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},el={kernelName:a.mH5,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=jt(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}},tl=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=Wt(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},nl={kernelName:a.Q6t,backendName:"webgl",kernelFunc:tl},rl=rr({opSnippet:"return 1.0 / x;"}),sl={kernelName:a.huO,backendName:"webgl",kernelFunc:rl},al=rr({opSnippet:vn+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),il={kernelName:a.fUj,backendName:"webgl",kernelFunc:al},ol=rr({opSnippet:vn+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),ll={kernelName:a.P_L,backendName:"webgl",kernelFunc:ol};class ul{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class cl{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const dl={kernelName:a.hgw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:l}=r,[u,c]=l,d=(0,a._K2)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cl(s.shape,u,c,i,o):new ul(s.shape,u,c,i,o);return n.runWebGLProgram(d,[s],"float32")}};class hl{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const pl={kernelName:a.FCQ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new hl(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class fl{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class ml{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const gl={kernelName:a.jOE,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:l}=r,[u,c]=l,d=(0,a._K2)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ml(s.shape,u,c,i,o):new fl(s.shape,u,c,i,o);return n.runWebGLProgram(d,[s],s.dtype)}};class bl{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const yl={kernelName:a.XQy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new bl(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class wl{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=$e(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class vl{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=hn("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=$e(n);function o(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const xl={kernelName:a.D7i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:i}=r,o=s.shape.length,l=a.ZSL.parseAxisParam(i,s.shape);if(0===o)return Hn({inputs:{x:s},backend:n});const u=(0,a._K2)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vl(s.shape,l):new wl(s.shape,l);return n.runWebGLProgram(u,[s],s.dtype)}};class _l{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const kl={kernelName:a.BK4,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:i,center:o}=t,l=n,u=new _l(r.shape,i),[c,d]=a.backend_util.getImageCenter(o,r.shape[1],r.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[r],r.dtype,h)}},Sl=rr({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Tl={kernelName:a.hVg,backendName:"webgl",kernelFunc:Sl},Il=rr({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Gt}),El={kernelName:a.TOR,backendName:"webgl",kernelFunc:Il};class Al{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=$e(s.length),u=$e(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}class Cl{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const l=$e(s.length),u=$e(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}const Nl={kernelName:a.pJc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=a.backend_util.calculateShapes(i,s,o),p=[h/c,c];if(0===h)return n.makeTensorInfo(o,s.dtype);const f=hr({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),m=hr({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let b;b=(0,a._K2)().getBool("WEBGL_PACK")?new Cl(u,l,f.shape.length,m.shape.length,d,p):new Al(u,l,f.shape.length,m.shape.length,d,p);const y=n.runWebGLProgram(b,[m,f,g],m.dtype),w=hr({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),w}};class $l{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===(0,a._K2)().getNumber("WEBGL_VERSION")?"while (left < right) {":s,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Ol={kernelName:a.uWl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new $l(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class Dl{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=$e(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const Fl={kernelName:a.l6P,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:i}=t,o=new Dl(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(o,[r,s,i],(0,a.TuY)(s.dtype,i.dtype))}},Rl=rr({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${a.backend_util.SELU_SCALEALPHA};\n  float scale = ${a.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Ml={kernelName:a.u$b,backendName:"webgl",kernelFunc:Rl},Ll=rr({opSnippet:nr+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:qt}),Pl={kernelName:a.vI1,backendName:"webgl",kernelFunc:Ll},zl=rr({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Bl={kernelName:a.YVe,backendName:"webgl",kernelFunc:zl},Vl=rr({opSnippet:nr+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Wn}\n  return result;\n`}),Ul={kernelName:a.hql,backendName:"webgl",kernelFunc:Vl},jl=rr({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Wl={kernelName:a.J3C,backendName:"webgl",kernelFunc:jl},Gl=rr({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Hl={kernelName:a.Fin,backendName:"webgl",kernelFunc:Gl},ql={kernelName:a.A8B,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:i,paddings:o}=r;a.ZSL.assert(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const l=i.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...o);for(let e=1+i.length;e<s.shape.length;++e)u.push([0,0]);const c=[],d=qo({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=a.backend_util.getReshaped(d.shape,i,l,!1),p=a.backend_util.getPermuted(h.length,i.length,!1),f=a.backend_util.getReshapedPermuted(d.shape,i,l,!1),m=hr({inputs:{x:d},backend:n,attrs:{shape:h}}),g=_r({inputs:{x:m},backend:n,attrs:{perm:p}}),b=hr({inputs:{x:g},backend:n,attrs:{shape:f}});return c.push(d),c.push(m),c.push(g),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Zl={kernelName:a.C8s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=Yt(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},Kl={kernelName:a.BoJ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=Xt(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},Yl={kernelName:a.L6G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Qt(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},Xl={kernelName:a.DvZ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Qt(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},Ql={kernelName:a.jgd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:l}=r,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=a.backend_util.calculateShapes(i,s,l),f=!1;if("string"===i.dtype){const e=n.bufferSync(s),t=n.bufferSync(i),r=a.ZSL.decodeString(n.readSync(o.dataId)[0]),m=Ht(e,t,l,p,d,c,u,h,r,f);return n.makeTensorInfo(l,m.dtype,m.values)}const m=new Al(c,u,s.shape.length,i.shape.length,h,[p,1],f),g=n.runWebGLProgram(m,[i,s,o],i.dtype),b=hr({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(g),b}},Jl={kernelName:a.Blb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,l=a.ZSL.parseAxisParam(o,s.shape)[0],u=a.backend_util.prepareSplitSize(s,i,l),c=s.shape.length,d=new Array(c).fill(0),h=s.shape.slice();return u.map((e=>{const t=[...h];t[l]=e;const r=ws({inputs:{x:s},backend:n,attrs:{begin:d,size:t}});return d[l]+=e,r}))}},eu="return sqrt(x);",tu=rr({opSnippet:eu,packedOpSnippet:eu,cpuKernelImpl:Jt}),nu={kernelName:a.dFH,backendName:"webgl",kernelFunc:tu},ru=rr({opSnippet:"return x * x;"}),su={kernelName:a.M6A,backendName:"webgl",kernelFunc:ru},au="return (a - b) * (a - b);",iu=sr({opSnippet:au,packedOpSnippet:au}),ou={kernelName:a.Ddj,backendName:"webgl",kernelFunc:iu},lu={kernelName:a.GZp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const i=n.readSync(s.dataId),o=a.backend_util.fromUint8ToStringArray(i),l=en(o,"string",r);return n.makeTensorInfo(s.shape,"string",l)}},uu={kernelName:a.pnw,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=vn+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new wn(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class cu{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=$e(n.length),a=$e(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const du={kernelName:a.UcO,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:w,end:v,strides:x}=a.Kro.sliceInfo(s.shape,i,o,l,u,c,d,h,p);let _;if(g)_=hr({inputs:{x:s},backend:n,attrs:{shape:m}});else if(b||y){a.ZSL.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=a.Kro.computeOutShape(w,v,x),t=ws({inputs:{x:s},backend:n,attrs:{begin:w,size:e}});_=hr({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=(0,a.ra8)(s.shape,s.dtype,e),r=tn(f,t,x,w);_=n.makeTensorInfo(m,s.dtype,r.values)}else{const e=new cu(w,x,f);_=n.runWebGLProgram(e,[s],s.dtype)}const k=hr({inputs:{x:_},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(_),k}},hu={kernelName:a.YAb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=nn(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},pu={kernelName:a.iW0,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=rn(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}},fu={kernelName:a.$jE,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=sn(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},mu=rr({opSnippet:"return tan(x);"}),gu={kernelName:a.oFs,backendName:"webgl",kernelFunc:mu},bu=rr({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),yu={kernelName:a.iuW,backendName:"webgl",kernelFunc:bu},wu={kernelName:a.X4r,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:i,updates:o}=t,{}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=a.backend_util.calculateShapes(o,i,s.shape),p=[h/c,c];if(0===h)return n.makeTensorInfo(s.shape,i.dtype);const f=hr({inputs:{x:i},backend:n,attrs:{shape:[u,l]}}),m=hr({inputs:{x:o},backend:n,attrs:{shape:[u,c]}}),g=hr({inputs:{x:s},backend:n,attrs:{shape:p}}),b=new Al(u,l,f.shape.length,m.shape.length,d,p,!1,!0),y=n.runWebGLProgram(b,[m,f,g],g.dtype),w=hr({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),w}};class vu{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=$e(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function xu(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>a.ZSL.decodeString(e))):e,r=(0,a.ra8)(s.shape,s.dtype,t),o=on(r,i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new vu(s.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}const _u={kernelName:a.FAs,backendName:"webgl",kernelFunc:xu};class ku{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Su{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Tu(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function Iu(e){let t=1;for(;t<e;)t*=2;return t}const Eu={kernelName:a.TBb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:i,sorted:o}=r,l=(0,a._K2)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=(0,a._K2)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,d=c[c.length-1];if(n.shouldExecuteOnCPU([s])||d<l||i>u){const e=n.readSync(s.dataId),[t,r]=ln(e,c,s.dtype,i,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===i)return c[c.length-1]=0,[n.makeTensorInfo(c,s.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===d)return[s,ri({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),p=null!==h&&h.isPacked,f=p?n.unpackTensor(s):s,m=a.ZSL.sizeFromShape(c)/d,g=hr({inputs:{x:f},attrs:{shape:[m,d]},backend:n});p&&Tu(n,f);const b=Iu(i),y=Iu(d);let w=null;const v=()=>null===w?[g,g]:[g,w],x=(e,t,r)=>{const s=v(),a=new ku(r),i=[[d],[null===w?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=w;w=n.runWebGLProgram(a,s,"int32",i),Tu(n,o)};for(let e=1;e<b;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)x(t,n,[m,y])}for(let e=y;e>b;e/=2){const t=v(),r=new Su([m,e/2]),s=[[d],[null===w?1:0],[b]],a=w;w=n.runWebGLProgram(r,t,"int32",s),Tu(n,a);const i=b/2,o=2*i;for(let e=i;e>=1;e/=2)x(o,e,w.shape)}let _=w;w=ws({inputs:{x:w},backend:n,attrs:{begin:0,size:[m,i]}}),Tu(n,_);let k=_i({inputs:{x:g,indices:w},backend:n,attrs:{axis:1,batchDims:1}});Tu(n,g);const S=c.slice(0,-1);S.push(i),_=w,w=hr({inputs:{x:w},attrs:{shape:S},backend:n}),Tu(n,_);const T=k;return k=hr({inputs:{x:k},attrs:{shape:S},backend:n}),Tu(n,T),[k,w]}};class Au{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Cu={kernelName:a.dLy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=new Au(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}},Nu={kernelName:a.EwU,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;fe(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=cn(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},$u={kernelName:a.dXR,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(u[c++]=i.shape[e]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let e=0;e<f.length;e++){h[a]=e;const t=ws({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),r=hr({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class Ou{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Du=[Ir,Ar,Nr,Or,Rr,Pr,zr,Br,Hr,qr,Kr,Xr,Jr,ts,rs,is,os,cs,ds,hs,ms,xs,_s,ks,Ss,Cs,Os,Rs,Kn,Ps,Hs,ea,aa,oa,la,ua,ca,ha,fa,ga,_a,ka,Sa,Ia,Ca,Oa,Da,Ra,La,Pa,Ba,Va,ja,Ga,qa,Ka,Qa,ti,si,ii,ui,di,fi,bi,yi,vi,ki,Ti,Ei,qn,Ai,js,Ni,Oi,Fi,Qn,Mi,Pi,zi,Vi,ji,Gi,qi,Ki,Qi,eo,no,so,ao,io,uo,co,ho,po,fo,go,wo,xo,No,dr,Oo,Fo,Mo,Po,Is,Bo,jo,Wo,Zo,Yo,tr,Xo,Qo,Jo,el,nl,As,So,sl,il,ll,pr,dl,pl,gl,yl,xl,kl,Tl,El,Nl,Ol,Fl,Ml,Pl,Bl,Ul,Wl,vs,Co,Hl,ql,Zl,Kl,Yl,Xl,Ql,Jl,nu,su,ou,lu,uu,du,hu,pu,fu,Eo,xr,gu,yu,wu,_u,Eu,Cu,kr,Nu,$u,{kernelName:a.pPe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:i}=t,{numSegments:o}=r,l=s.shape.length,u=[];let c=0;const d=a.backend_util.getAxesPermutation([c],l);let h=s;null!=d&&(h=_r({inputs:{x:s},backend:n,attrs:{perm:d}}),u.push(h),c=a.backend_util.getInnerMostAxes(1,l)[0]);const p=a.backend_util.segment_util.computeOutShape(h.shape,c,o),f=a.ZSL.sizeFromShape([h.shape[c]]),m=hr({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});u.push(m);const g=(0,a.chL)(s.dtype),b=(e,t,r,s,i)=>{const o=e.shape[0],l=e.shape[1],c=a.backend_util.segment_util.segOpComputeOptimalWindowSize(l,i),d=new Ou({windowSize:c,inSize:l,batchSize:o,numSegments:i},t),h=n.compileAndRun(d,[e,r],s);if(u.push(h),h.shape[1]===i)return h;const p=tl({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=xu({inputs:{x:p},backend:n,attrs:{reps:[l/c]}});return u.push(p),u.push(f),b(h,t,f,s,i)},y=hr({inputs:{x:b(m,"unsortedSegmentSum",i,g,o)},backend:n,attrs:{shape:p}});let w=y;if(null!=d){u.push(y);const e=a.backend_util.getUndoAxesPermutation(d);w=_r({inputs:{x:w},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),w}},Uo];for(const e of Du)(0,a.tAK)(e)},7164:(e,t,n)=>{"use strict";n.d(t,{k7:()=>Ge,Ad:()=>C,ox:()=>He,R9:()=>qe,Nn:()=>E,uW:()=>Ze});var r={};n.r(r),n.d(r,{json:()=>P});var s={};n.r(s),n.d(s,{json:()=>z});var a={};n.r(a),n.d(a,{json:()=>B});var i={};n.r(i),n.d(i,{json:()=>V});var o={};n.r(o),n.d(o,{json:()=>U});var l={};n.r(l),n.d(l,{json:()=>j});var u={};n.r(u),n.d(u,{json:()=>W});var c={};n.r(c),n.d(c,{json:()=>G});var d={};n.r(d),n.d(d,{json:()=>H});var h={};n.r(h),n.d(h,{json:()=>q});var p={};n.r(p),n.d(p,{json:()=>Z});var f={};n.r(f),n.d(f,{json:()=>K});var m={};n.r(m),n.d(m,{json:()=>Y});var g={};n.r(g),n.d(g,{json:()=>X});var b={};n.r(b),n.d(b,{json:()=>Q});var y={};n.r(y),n.d(y,{json:()=>J});var w={};n.r(w),n.d(w,{json:()=>ee});var v={};n.r(v),n.d(v,{json:()=>te});var x={};n.r(x),n.d(x,{json:()=>ne});var _={};n.r(_),n.d(_,{OP_SCOPE_SUFFIX:()=>we.BTT,abs:()=>we.tnl,acos:()=>we.HQu,acosh:()=>we.FqL,add:()=>we.WQq,addN:()=>we.QiD,all:()=>we.Q7R,any:()=>we.bzn,argMax:()=>we.FLi,argMin:()=>we.XRg,asin:()=>we.qRo,asinh:()=>we.yHs,atan:()=>we.rYl,atan2:()=>we.FPz,atanh:()=>we.rfv,avgPool:()=>we.$jT,avgPool3d:()=>we.sub,basicLSTMCell:()=>we.lZX,batchNorm:()=>we.$v7,batchNorm2d:()=>we.BFc,batchNorm3d:()=>we.kSi,batchNorm4d:()=>we.T5N,batchToSpaceND:()=>we.GTe,bincount:()=>we.HbZ,bitwiseAnd:()=>we.vjT,booleanMaskAsync:()=>we.ftb,broadcastArgs:()=>we.ROE,broadcastTo:()=>we.hOW,buffer:()=>we.ra8,cast:()=>we.wgE,ceil:()=>we.mkO,clipByValue:()=>we.zQh,clone:()=>we.o8B,complex:()=>we.faB,concat:()=>we.xWs,concat1d:()=>we.I1m,concat2d:()=>we.RPU,concat3d:()=>we.O5O,concat4d:()=>we.P1l,conv1d:()=>we.kA9,conv2d:()=>we.Xtf,conv2dTranspose:()=>we.wX9,conv3d:()=>we.IPL,conv3dTranspose:()=>we.jIJ,cos:()=>we.gnS,cosh:()=>we.yIG,cosineWindow:()=>we._jP,cumprod:()=>we.Lp0,cumsum:()=>we.rCv,denseBincount:()=>we.aOp,depthToSpace:()=>we.Rj8,depthwiseConv2d:()=>we.Gl3,diag:()=>we.smy,dilation2d:()=>we.X7t,div:()=>we.y4m,divNoNan:()=>we.ek5,dot:()=>we.Omf,dropout:()=>we.EZY,einsum:()=>we._3C,elu:()=>we.Pqc,enclosingPowerOfTwo:()=>we.FJY,ensureShape:()=>we.QP2,equal:()=>we.LCg,erf:()=>we.Y12,euclideanNorm:()=>we.p4S,exp:()=>we.oNF,expandDims:()=>we.UG6,expm1:()=>we.IYd,eye:()=>we.y5U,fft:()=>we.hVP,fill:()=>we.GSj,floor:()=>we.RIf,floorDiv:()=>we.wh_,fused:()=>we.cZk,gather:()=>we.kgh,gatherND:()=>we.SY9,greater:()=>we.rhj,greaterEqual:()=>we.DQN,ifft:()=>we.KGM,imag:()=>we.ngS,image:()=>we.Slp,inTopKAsync:()=>we.U4u,irfft:()=>we.ggX,isFinite:()=>we.MIs,isInf:()=>we.EN4,isNaN:()=>we.yrW,leakyRelu:()=>we.H8d,less:()=>we.M7h,lessEqual:()=>we.InN,linalg:()=>we.mPL,linspace:()=>we.mT8,localResponseNormalization:()=>we.Kgs,log:()=>we.Rm2,log1p:()=>we.Kko,logSigmoid:()=>we.nqI,logSoftmax:()=>we.HPB,logSumExp:()=>we.VZ,logicalAnd:()=>we.n76,logicalNot:()=>we.NSZ,logicalOr:()=>we.ztW,logicalXor:()=>we.rxB,losses:()=>we.YYh,lowerBound:()=>we.yzS,matMul:()=>we.NoW,max:()=>we.T9B,maxPool:()=>we.jgi,maxPool3d:()=>we.NYV,maxPoolWithArgmax:()=>we.RO,maximum:()=>we.PhQ,mean:()=>we.i2o,meshgrid:()=>we.OYQ,min:()=>we.jkA,minimum:()=>we.BpO,mirrorPad:()=>we.FFZ,mod:()=>we.ziu,moments:()=>we.Clk,movingAverage:()=>we.CRk,mul:()=>we.lKK,multiRNNCell:()=>we.YDF,multinomial:()=>we.OjQ,neg:()=>we.HZy,norm:()=>we.xbf,notEqual:()=>we.Ec,oneHot:()=>we.Mw0,ones:()=>we.SaS,onesLike:()=>we.P61,op:()=>we.op,outerProduct:()=>we.X4o,pad:()=>we.eVF,pad1d:()=>we.BZs,pad2d:()=>we.grY,pad3d:()=>we.XHu,pad4d:()=>we.WLX,pool:()=>we.dzn,pow:()=>we.n7C,prelu:()=>we.NsG,print:()=>we.yyV,prod:()=>we._eU,raggedGather:()=>we.whe,raggedRange:()=>we.iyU,raggedTensorToTensor:()=>we.Q0_,rand:()=>we._9M,randomGamma:()=>we.pR9,randomNormal:()=>we.FE$,randomStandardNormal:()=>we.m0H,randomUniform:()=>we.YeY,randomUniformInt:()=>we.HYA,range:()=>we.y17,real:()=>we.xav,reciprocal:()=>we.VOZ,relu:()=>we.VVh,relu6:()=>we.j__,reshape:()=>we.tQQ,reverse:()=>we.BEg,reverse1d:()=>we.QD2,reverse2d:()=>we.LMr,reverse3d:()=>we.I2l,reverse4d:()=>we.JYU,rfft:()=>we.z8$,round:()=>we.LIG,rsqrt:()=>we.Z$r,scalar:()=>we.d_2,scatterND:()=>we.NFr,searchSorted:()=>we.sZg,selu:()=>we.WfX,separableConv2d:()=>we.wdz,setdiff1dAsync:()=>we.F12,sigmoid:()=>we.ry7,sign:()=>we._SZ,signal:()=>we.vPA,sin:()=>we.F8e,sinh:()=>we.L0l,slice:()=>we.dik,slice1d:()=>we.Q$M,slice2d:()=>we.zAd,slice3d:()=>we.wck,slice4d:()=>we.R0O,softmax:()=>we.Vs9,softplus:()=>we.lw0,spaceToBatchND:()=>we.eDJ,sparse:()=>we.lMo,sparseToDense:()=>we.Zhr,spectral:()=>we.lOn,split:()=>we.lDo,sqrt:()=>we.RZD,square:()=>we.EwI,squaredDifference:()=>we.Pbu,squeeze:()=>we.r2V,stack:()=>we.t$z,step:()=>we.PMw,stridedSlice:()=>we.Ym9,string:()=>we.YjP,sub:()=>we.jbE,sum:()=>we.czq,tan:()=>we.Mlm,tanh:()=>we.ymU,tensor:()=>we.OEK,tensor1d:()=>we.tGX,tensor2d:()=>we.KtR,tensor3d:()=>we.$_$,tensor4d:()=>we.g9W,tensor5d:()=>we.Lpo,tensor6d:()=>we.yxw,tensorScatterUpdate:()=>we.NNh,tile:()=>we.Vsq,topk:()=>we.rfw,transpose:()=>we.mgz,truncatedNormal:()=>we.efE,unique:()=>we.AmM,unsortedSegmentSum:()=>we.zAU,unstack:()=>we.K$i,upperBound:()=>we.rni,variable:()=>we.bvq,where:()=>we._M9,whereAsync:()=>we.YJN,zeros:()=>we.Ul9,zerosLike:()=>we.POl});var k,S,T=n(1592);(0,T._K2)().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(k||(k={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(S||(S={}));const I={};function E(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};I[e]=n}function A(e){return I[e]}function C(e){delete I[e]}function N(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return $(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)})).map((e=>$(e,n,r,s)))}const l=$(t.inputNames[o],n,r,s),u=l.dataSync();return"number"===a.type?u[0]:T.ZSL.toNestedArray(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function $(e,t,n,r){const[s,a]=R(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[F(s,e)]));return void 0!==i?t[F(s,i)][a]:void 0}function O(e,t,n){return t[F(e,n.currentContextId)]}function D(e,t){const[n,r,s]=R(e,t);return[F(n,t&&t.currentContextId),r,s]}function F(e,t){return t?`${e}-${t}`:e}function R(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function M(e,t,n){let r=N("pad",e,t,n);if("explicit"===r){r=N("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function L(e){return e.kept?e:(0,T.o8B)(e)}const P=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],z=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],B=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],V=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],U=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],j=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],W=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],G=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],H=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],q=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Z=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],K=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Y=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],X=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Q=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],J=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ee=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],te=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],ne=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class re{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[r,s,a,i,o,l,u,c,d,h,p,f,m,g,b,y,w,v,x].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=D(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=D(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=D(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=A(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=ae(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ae(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=me(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=me(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=oe(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=oe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=fe(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=fe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=ie(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ie(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=be(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=be(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=pe(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=pe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=ge(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ge(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=ce(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ce(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=de(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=de(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=ue(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=D(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:le(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n})),Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[s,,a]=D(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=D(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function se(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=(0,T._K2)().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function ae(e,t,n,r=!1){const s=e[t];return null!=s?se(s.s,r):n}function ie(e,t,n){const r=e[t];return r?r.b:n}function oe(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function le(e){switch("string"==typeof e&&(e=k[e]),e){case k.DT_FLOAT:case k.DT_HALF:return"float32";case k.DT_INT32:case k.DT_INT64:case k.DT_INT8:case k.DT_UINT8:return"int32";case k.DT_BOOL:return"bool";case k.DT_DOUBLE:return"float32";case k.DT_STRING:return"string";case k.DT_COMPLEX64:case k.DT_COMPLEX128:return"complex64";default:return null}}function ue(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function ce(e,t,n){const r=e[t];return r&&r.type?le(r.type):n}function de(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>le(e))):n}function he(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function pe(e,t,n){const r=e[t];return r&&r.shape?he(r.shape):n}function fe(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function me(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>se(e,r))):n}function ge(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>he(e))):n}function be(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class ye{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return $(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return $(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return oe(this.node.rawAttrs,e,t);if(null!=n.s)return ae(this.node.rawAttrs,e,t);if(null!=n.b)return ie(this.node.rawAttrs,e,t);if(null!=n.shape)return pe(this.node.rawAttrs,e,t);if(null!=n.type)return ce(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return fe(this.node.rawAttrs,e,t);if(null!=n.list.s)return me(this.node.rawAttrs,e,t);if(null!=n.list.shape)return ge(this.node.rawAttrs,e,t);if(null!=n.list.b)return be(this.node.rawAttrs,e,t);if(null!=n.list.type)return de(this.node.rawAttrs,e,t)}return t}}var we=n(2740);function ve(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){T.ZSL.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];T.ZSL.assert(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function xe(e){return"number"!=typeof e&&!e.some((e=>e<0))}function _e(e,t,n){let r=ke(e,n);const s=!xe(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=ke(e.shape,r)})),!xe(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function ke(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class Se{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=(0,T.d_2)(0),(0,T.aCs)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),ve(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,(0,T.aCs)(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,T.OEK)([],[0].concat(this.elementShape));const n=this.readMany(e);return ve(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),(0,T.t$z)(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,T.OEK)([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return ve(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),(0,T.xWs)(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,(0,T.K$i)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];(0,T.DZQ)((()=>{t=(0,T.tQQ)(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=(0,T.tQQ)((0,T.dik)(t,i,o),this.elementShape)}return a}));const i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,a)}}class Te{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);ve(t,e.shape,"TensorList shape mismatch: "),(0,T.aCs)(e)})),this.idTensor=(0,T.d_2)(0),this.maxNumElements=r,(0,T.aCs)(this.idTensor)}copy(){return new Te([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);ve(e,this.elementShape,"TensorList shape mismatch: ");const r=_e(this.elementShape,this.tensors,e);return(0,T.DZQ)((()=>{const e=this.tensors.map((e=>(0,T.tQQ)(e,r)));return(0,T.t$z)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=_e(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,ve(r.shape,e,"TensorList shape mismatch: "),(0,T.tQQ)(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ve(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,T.aCs)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Te([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);ve(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=_e(this.elementShape,this.tensors,t);return(0,T.tQQ)(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ve(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,T.aCs)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ve(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=_e(this.elementShape,this.tensors,n);return 0===e.length?(0,T.OEK)([],[0].concat(r)):(0,T.DZQ)((()=>{const t=e.map((e=>(0,T.tQQ)(this.tensors[e],r)));return(0,T.t$z)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ve(this.elementShape,t,"TensorList shape mismatch: ");const n=_e(this.elementShape,this.tensors,t);return 0===this.size()?(0,T.OEK)([],[0].concat(n)):(0,T.DZQ)((()=>{const e=this.tensors.map((e=>(0,T.tQQ)(e,n)));return(0,T.xWs)(e,0)}))}}function Ie(e,t,n){const[r,s]=N("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=N("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=N("strides",e,t,n),d=M(e,t,n),h=N("dataFormat",e,t,n).toUpperCase(),p=N("dilations",e,t,n);let[f,m]=N("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:N("leakyreluAlpha",e,t,n)}}function Ee(e,t,n){return{boxes:N("boxes",e,t,n),scores:N("scores",e,t,n),maxOutputSize:N("maxOutputSize",e,t,n),iouThreshold:N("iouThreshold",e,t,n),scoreThreshold:N("scoreThreshold",e,t,n),softNmsSigma:N("softNmsSigma",e,t,n)}}var Ae=n(9e3);class Ce{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,T.d_2)(0),this.tensorMap=new Map,(0,T.aCs)(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ae.d(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),(0,T.DZQ)((()=>{const e=(0,T.K$i)(t),r=n.length,s=e.length;T.ZSL.assert(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];(0,T.aCs)(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return(0,T.DZQ)((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return(0,T.t$z)(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function Ne(e,t,n,r,s=T.DZQ){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(N("a",e,t,n),N("b",e,t,n))];case"AddN":return[r.addN(N("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(N("a",e,t,n),N("b",e,t,n))];case"Mul":return[r.mul(N("a",e,t,n),N("b",e,t,n))];case"RealDiv":case"Div":return[r.div(N("a",e,t,n),N("b",e,t,n))];case"DivNoNan":return[r.divNoNan(N("a",e,t,n),N("b",e,t,n))];case"FloorDiv":return[r.floorDiv(N("a",e,t,n),N("b",e,t,n))];case"Sub":return[r.sub(N("a",e,t,n),N("b",e,t,n))];case"Minimum":return[r.minimum(N("a",e,t,n),N("b",e,t,n))];case"Maximum":return[r.maximum(N("a",e,t,n),N("b",e,t,n))];case"Pow":return[r.pow(N("a",e,t,n),N("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(N("a",e,t,n),N("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(N("x",e,t,n))];case"Acos":return[r.acos(N("x",e,t,n))];case"Acosh":return[r.acosh(N("x",e,t,n))];case"Asin":return[r.asin(N("x",e,t,n))];case"Asinh":return[r.asinh(N("x",e,t,n))];case"Atan":return[r.atan(N("x",e,t,n))];case"Atan2":return[r.atan2(N("x",e,t,n),N("y",e,t,n))];case"Atanh":return[r.atanh(N("x",e,t,n))];case"Ceil":return[r.ceil(N("x",e,t,n))];case"Complex":return[r.complex(N("real",e,t,n),N("imag",e,t,n))];case"Cos":return[r.cos(N("x",e,t,n))];case"Cosh":return[r.cosh(N("x",e,t,n))];case"Elu":return[r.elu(N("x",e,t,n))];case"Erf":return[r.erf(N("x",e,t,n))];case"Exp":return[r.exp(N("x",e,t,n))];case"Expm1":return[r.expm1(N("x",e,t,n))];case"Floor":return[r.floor(N("x",e,t,n))];case"Log":return[r.log(N("x",e,t,n))];case"Log1p":return[r.log1p(N("x",e,t,n))];case"Imag":return[r.imag(N("x",e,t,n))];case"Neg":return[r.neg(N("x",e,t,n))];case"Reciprocal":return[r.reciprocal(N("x",e,t,n))];case"Real":return[r.real(N("x",e,t,n))];case"Relu":return[r.relu(N("x",e,t,n))];case"Round":return[r.round(N("x",e,t,n))];case"Selu":return[r.selu(N("x",e,t,n))];case"Sigmoid":return[r.sigmoid(N("x",e,t,n))];case"Sin":return[r.sin(N("x",e,t,n))];case"Sign":return[r.sign(N("x",e,t,n))];case"Sinh":return[r.sinh(N("x",e,t,n))];case"Softplus":return[r.softplus(N("x",e,t,n))];case"Sqrt":return[r.sqrt(N("x",e,t,n))];case"Square":return[r.square(N("x",e,t,n))];case"Tanh":return[r.tanh(N("x",e,t,n))];case"Tan":return[r.tan(N("x",e,t,n))];case"ClipByValue":return[r.clipByValue(N("x",e,t,n),N("clipValueMin",e,t,n),N("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(N("x",e,t,n))];case"Rsqrt":return[r.rsqrt($(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(N("x",e,t,n),N("alpha",e,t,n))];case"Prelu":return[r.prelu(N("x",e,t,n),N("alpha",e,t,n))];case"IsNan":return[r.isNaN($(e.inputNames[0],t,n))];case"IsInf":return[r.isInf($(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite($(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return(async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=N("thenBranch",e,t,n),s=N("elseBranch",e,t,n),a=N("cond",e,t,n),i=N("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=N("body",e,t,n),s=N("cond",e,t,n),a=N("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=a;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[L(N("pred",e,t,n))];case"Switch":{const r=N("pred",e,t,n);let s=N("data",e,t,n);return s.kept||(s=L(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==$(e,t,n)));return r?[L($(r,t,n))]:void 0}case"Enter":{const r=N("frameName",e,t,n),s=N("tensor",e,t,n);return n.enterFrame(r),[L(s)]}case"Exit":{const r=N("tensor",e,t,n);return n.exitFrame(),[L(r)]}case"NextIteration":{const r=N("tensor",e,t,n);return n.nextIteration(),[L(r)]}case"TensorArrayV3":{const r=N("size",e,t,n),s=N("dtype",e,t,n),a=N("elementShape",e,t,n),i=N("dynamicSize",e,t,n),o=N("clearAfterRead",e,t,n),l=N("identicalElementShapes",e,t,n),u=N("name",e,t,n),c=new Se(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,(0,T.d_2)(1)]}case"TensorArrayWriteV3":{const r=N("tensorArrayId",e,t,n),s=N("index",e,t,n),a=N("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=N("tensorArrayId",e,t,n),s=N("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=N("tensorArrayId",e,t,n),s=N("indices",e,t,n),a=N("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=N("tensorArrayId",e,t,n),s=N("indices",e,t,n),a=N("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=N("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=N("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=N("tensorArrayId",e,t,n),s=N("tensor",e,t,n),a=N("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=N("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[(0,T.d_2)(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=N("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=N("tensorListId",e,t,n),s=N("index",e,t,n),a=N("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=N("tensorListId",e,t,n),s=N("index",e,t,n),a=N("elementShape",e,t,n),i=N("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=N("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new Te([],n,e.dtype,r),i=(0,T.K$i)(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}(N("tensor",e,t,n),r,N("elementShape",e,t,n),N("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=N("elementShape",e,t,n),s=N("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=N(a,e,t,n),o=function(e,t,n,r){return new Te([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=N("tensorListId",e,t,n),s=N("indices",e,t,n),a=N("elementShape",e,t,n),i=N("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=N("tensorListId",e,t,n),s=N("elementShape",e,t,n),a=N("elementDType",e,t,n),i=N("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);ve(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=(0,T.K$i)(e);return new Te(s,t,r)}(N("tensor",e,t,n),N("elementShape",e,t,n),N("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=N("tensorListId",e,t,n),s=n.getTensorList(r.id),a=N("dtype",e,t,n),i=N("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=N("tensorListId",e,t,n),s=N("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=N("tensorListId",e,t,n),s=N("elementShape",e,t,n),a=N("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=N("tensor",e,t,n),s=N("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=ke(e.shape.slice(1),n),i=0===r?0:e.size/r,o=(0,T.DZQ)((()=>{const n=[];e=(0,T.tQQ)(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],l=[1,t[r],i];n[r]=(0,T.tQQ)((0,T.dik)(e,o,l),a)}return e.dispose(),n})),l=new Te([],n,e.dtype,t.length);for(let e=0;e<o.length;e++)l.setItem(e,o[e]);return l}(r,N("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=N("tensorListId",e,t,n),s=n.getTensorList(r.id);return[(0,T.d_2)(s.size(),"int32")]}case"TensorListResize":{const r=N("tensorListId",e,t,n),s=N("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"convolution":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Conv1D":{const s=N("stride",e,t,n),a=N("pad",e,t,n),i=N("dataFormat",e,t,n).toUpperCase(),o=N("dilation",e,t,n);return[r.conv1d(N("x",e,t,n),N("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=N("strides",e,t,n),a=M(e,t,n),i=N("dataFormat",e,t,n).toUpperCase(),o=N("dilations",e,t,n);return[r.conv2d(N("x",e,t,n),N("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=Ie(e,t,n);return[r.fused.conv2d({x:N("x",e,t,n),filter:N("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=Ie(e,t,n);return[r.fused.depthwiseConv2d({x:N("x",e,t,n),filter:N("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=N("outputShape",e,t,n),a=N("strides",e,t,n),i=M(e,t,n);return[r.conv2dTranspose(N("x",e,t,n),N("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=N("strides",e,t,n),a=M(e,t,n),i=N("dilations",e,t,n),o=N("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(N("input",e,t,n),N("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("dataFormat",e,t,n).toUpperCase(),o=N("dilations",e,t,n);return[r.conv3d(N("x",e,t,n),N("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("kernelSize",e,t,n);return[r.avgPool(N("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("kernelSize",e,t,n);return[r.maxPool(N("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("kernelSize",e,t,n),o=N("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(N("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("kernelSize",e,t,n);return[r.avgPool3d(N("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("kernelSize",e,t,n);return[r.maxPool3d(N("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=N("strides",e,t,n),a=N("pad",e,t,n),i=N("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(N("x",e,t,n),N("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Fill":{const s=N("shape",e,t,n),a=N("dtype",e,t,n),i=N("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=N("start",e,t,n),a=N("stop",e,t,n),i=N("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=N("logits",e,t,n),a=N("numSamples",e,t,n),i=N("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=N("indices",e,t,n),a=N("depth",e,t,n),i=N("onValue",e,t,n),o=N("offValue",e,t,n),l=N("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(N("shape",e,t,n),N("dtype",e,t,n))];case"OnesLike":return[r.onesLike(N("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(N("shape",e,t,n),N("dtype",e,t,n),N("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(N("shape",e,t,n),N("minval",e,t,n),N("maxval",e,t,n),N("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(N("shape",e,t,n),N("minval",e,t,n),N("maxval",e,t,n),N("seed",e,t,n))];case"Range":{const s=N("start",e,t,n),a=N("stop",e,t,n),i=N("step",e,t,n);return[r.range(s,a,i,N("dtype",e,t,n))]}case"TruncatedNormal":{const s=N("shape",e,t,n),a=N("mean",e,t,n),i=N("stdDev",e,t,n),o=N("seed",e,t,n);return[r.truncatedNormal(s,a,i,N("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(N("shape",e,t,n),N("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(N("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n,r,s=_)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=Ee(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=Ee(e,t,n),u=N("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=Ee(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,l)]}case"Where":{const r=s.cast(N("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(N("x",e,t,n),N("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"LowerBound":{const s=N("sortedSequence",e,t,n),a=N("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=N("x",e,t,n),a=N("k",e,t,n),i=N("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=N("sortedSequence",e,t,n),a=N("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=N("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=N("x",e,t,n),a=N("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"ResizeBilinear":{const s=N("images",e,t,n),a=N("size",e,t,n),i=N("alignCorners",e,t,n),o=N("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=N("images",e,t,n),a=N("size",e,t,n),i=N("alignCorners",e,t,n),o=N("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=N("image",e,t,n),a=N("boxes",e,t,n),i=N("boxInd",e,t,n),o=N("cropSize",e,t,n),l=N("method",e,t,n),u=N("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=N("images",e,t,n),a=N("transforms",e,t,n),i=N("outputShape",e,t,n),o=N("fillValue",e,t,n),l=N("interpolation",e,t,n),u=N("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=N("default",e,t,n);return[$(e.name,t,n)||s];case"Placeholder":return[$(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[L(N("x",e,t,n))];case"IdentityN":return N("x",e,t,n).map((e=>L(e)));case"Shape":return[r.tensor1d(N("x",e,t,n).shape,"int32")];case"ShapeN":return N("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(N("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(N("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=N("x",e,t,n),i=N("data",e,t,n),o=N("message",e,t,n),l=N("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Equal":return[r.equal(N("a",e,t,n),N("b",e,t,n))];case"NotEqual":return[r.notEqual(N("a",e,t,n),N("b",e,t,n))];case"Greater":return[r.greater(N("a",e,t,n),N("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(N("a",e,t,n),N("b",e,t,n))];case"Less":return[r.less(N("a",e,t,n),N("b",e,t,n))];case"LessEqual":return[r.lessEqual(N("a",e,t,n),N("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(N("a",e,t,n),N("b",e,t,n))];case"LogicalNot":return[r.logicalNot(N("a",e,t,n))];case"LogicalOr":return[r.logicalOr(N("a",e,t,n),N("b",e,t,n))];case"Select":case"SelectV2":return[r.where(N("condition",e,t,n),N("a",e,t,n),N("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(N("a",e,t,n),N("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(N("a",e,t,n),N("b",e,t,n),N("transposeA",e,t,n),N("transposeB",e,t,n))];case"Einsum":return[r.einsum(N("equation",e,t,n),...N("tensors",e,t,n))];case"Transpose":return[r.transpose(N("x",e,t,n),N("perm",e,t,n))];case"_FusedMatMul":const[s,a]=N("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,l=N("numArgs",e,t,n),u=N("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=N("args",e,t,n);return[r.fused.matMul({a:N("a",e,t,n),b:N("b",e,t,n),transposeA:N("transposeA",e,t,n),transposeB:N("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(N("a",e,t,n),N("numLower",e,t,n),N("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(N("x",e,t,n),N("axis",e,t,n),N("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(N("x",e,t,n),N("mean",e,t,n),N("variance",e,t,n),N("offset",e,t,n),N("scale",e,t,n),N("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(N("x",e,t,n),N("radius",e,t,n),N("bias",e,t,n),N("alpha",e,t,n),N("beta",e,t,n))];case"Softmax":return[r.softmax(N("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(N("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"ragged":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(N("paramsNestedSplits",e,t,n),N("paramsDenseValues",e,t,n),N("indices",e,t,n),N("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(N("starts",e,t,n),N("limits",e,t,n),N("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(N("shape",e,t,n),N("values",e,t,n),N("defaultValue",e,t,n),N("rowPartitionTensors",e,t,n),N("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Max":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.max(N("x",e,t,n),s,a)]}case"Mean":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.mean(N("x",e,t,n),s,a)]}case"Min":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.min(N("x",e,t,n),s,a)]}case"Sum":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.sum(N("x",e,t,n),s,a)]}case"All":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.all(N("x",e,t,n),s,a)]}case"Any":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.any(N("x",e,t,n),s,a)]}case"ArgMax":{const s=N("axis",e,t,n);return[r.argMax(N("x",e,t,n),s)]}case"ArgMin":{const s=N("axis",e,t,n);return[r.argMin(N("x",e,t,n),s)]}case"Prod":{const s=N("axis",e,t,n),a=N("keepDims",e,t,n);return[r.prod(N("x",e,t,n),s,a)]}case"Cumprod":{const s=N("axis",e,t,n),a=N("exclusive",e,t,n),i=N("reverse",e,t,n);return[r.cumprod(N("x",e,t,n),s,a,i)]}case"Cumsum":{const s=N("axis",e,t,n),a=N("exclusive",e,t,n),i=N("reverse",e,t,n);return[r.cumsum(N("x",e,t,n),s,a,i)]}case"Bincount":const s=N("x",e,t,n),a=N("weights",e,t,n),i=N("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=N("x",e,t,n),a=N("weights",e,t,n),i=N("size",e,t,n),o=N("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=N("n",e,t,n),a=N("axis",e,t,n);let i=N("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=N("x",e,t,n),a=N("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=N("axis",e,t,n),a=N("batchDims",e,t,n),i=N("x",e,t,n),o=N("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=N("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=N("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=N("axis",e,t,n),a=N("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=N("begin",e,t,n),a=N("size",e,t,n);return[r.slice(N("x",e,t,n),s,a)]}case"StridedSlice":{const s=N("begin",e,t,n),a=N("end",e,t,n),i=N("strides",e,t,n),o=N("beginMask",e,t,n),l=N("endMask",e,t,n),u=N("ellipsisMask",e,t,n),c=N("newAxisMask",e,t,n),d=N("shrinkAxisMask",e,t,n),h=N("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return(0,T.DZQ)((()=>{const s=N("axis",e,t,n),a=N("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map((e=>{const t=T.ZSL.arraysEqual(e.shape,i);if(!t&&!T.ZSL.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,s)]}));case"Unpack":{const s=N("axis",e,t,n),a=N("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=N("reps",e,t,n);return[r.tile(N("x",e,t,n),s)]}case"Split":case"SplitV":{const s=N("axis",e,t,n),a=N("numOrSizeSplits",e,t,n),i=N("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=N("indices",e,t,n),a=N("values",e,t,n),i=N("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=N("x",e,t,n),a=N("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=N("sparseIndices",e,t,n),a=N("outputShape",e,t,n),i=N("sparseValues",e,t,n),o=N("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=N("indices",e,t,n),a=N("values",e,t,n),i=N("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(N("indices",e,t,n),N("values",e,t,n),N("denseShape",e,t,n),N("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(N("inputIndices",e,t,n),N("inputShape",e,t,n),N("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(N("data",e,t,n),N("indices",e,t,n),N("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(N("data",e,t,n),N("indices",e,t,n),N("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"FFT":return[r.fft(N("x",e,t,n))];case"IFFT":return[r.ifft(N("x",e,t,n))];case"RFFT":return[r.rfft(N("x",e,t,n))];case"IRFFT":return[r.irfft(N("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(N("input",e,t,n),N("pattern",e,t,n),N("rewrite",e,t,n),N("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(N("data",e,t,n),N("dataSplits",e,t,n),N("separator",e,t,n),N("nGramWidths",e,t,n),N("leftPad",e,t,n),N("rightPad",e,t,n),N("padWidth",e,t,n),N("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(N("input",e,t,n),N("delimiter",e,t,n),N("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(N("input",e,t,n),N("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return s((()=>((e,t,n,r=_)=>{switch(e.op){case"Cast":return[r.cast(N("x",e,t,n),N("dtype",e,t,n))];case"ExpandDims":{const s=N("axis",e,t,n);return[r.expandDims(N("x",e,t,n),s)]}case"Squeeze":{const s=N("axis",e,t,n);return[r.squeeze(N("x",e,t,n),s)]}case"Reshape":return[r.reshape(N("x",e,t,n),N("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(N("x",e,t,n),N("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(N("x",e,t,n),N("padding",e,t,n),N("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(N("x",e,t,n),N("padding",e,t,n),N("constantValue",e,t,n))];case"SpaceToBatchND":{const s=N("blockShape",e,t,n),a=N("paddings",e,t,n);return[r.spaceToBatchND(N("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=N("blockShape",e,t,n),a=N("crops",e,t,n);return[r.batchToSpaceND(N("x",e,t,n),s,a)]}case"DepthToSpace":{const s=N("blockSize",e,t,n),a=N("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(N("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(N("x",e,t,n),N("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(N("s0",e,t,n),N("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=N("keyDType",e,t,n),a=N("valueDType",e,t,n),i=new Ce(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=N("tableHandle",e,t,n,r),a=N("keys",e,t,n),i=N("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=N("tableHandle",e,t,n,r),a=N("keys",e,t,n),i=N("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=N("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=A(e.op);if(a&&a.customExecutor)return a.customExecutor(new ye(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return T.ZSL.isPromise(a)?a.then((e=>[].concat(e))):[].concat(a)}class $e{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Oe(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>R(e)[0])));r=r||[];const c=new Set(r.map((e=>R(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(Le(e)||Pe(e)||ze(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}class De extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const Fe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Re=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Me=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Le(e){return Fe.has(e.op)}function Pe(e){return Re.has(e.op)}function ze(e){return Me.has(e.op)}class Be{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new Be(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=Oe(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=function(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>R(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(const e of u){d[e.name]=d[e.name]||0;for(const t of e.children)i(t)||(d[t.name]=Number.POSITIVE_INFINITY),d[t.name]=(d[t.name]||0)+1}const h=Object.entries(d).filter((([,e])=>0===e)).map((([e])=>e)),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const e of t.children.filter(i))0==--d[e.name]&&(p.push(e.name),h.push(e.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const e of t.children)n.has(e.name)&&!s.has(e.name)&&(s.add(e.name),r.push(e.name))}return e.filter((e=>s.has(e.name)))}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"==typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"==typeof e?e:e.name);for(const t of e){for(const e of t.children.filter(i)){if(!n.has(e.name))throw new De(`Child ${e.name} of node ${t.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new De(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!s(t))for(const e of t.inputs){if(!n.has(e.name))throw new De(`Input ${e.name} of node ${t.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new De(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>Le(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let t=0;t<e.length;++t){const r=a[t];if(r===n)continue;const s=e[t],o=e[r];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(s)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return(0,T.aCs)(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,this.cloneTensorList(t)])))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[R(e)[0]])),s=t.map((e=>R(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=(0,T._K2)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}const u={},c={};return(0,T.DZQ)((()=>{const n=new $e(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=R(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=Ne(e,r,n,this._resourceManager);if(T.ZSL.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>$(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!Le(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(Le(e))continue;const t=O(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return Le(e)||s.has(e.name)}if(!Le(e)&&null!=a)for(const e of a){if(i(e))continue;const s=O(e.name,t,n);for(const e of s)!e||e.kept||r.has(e.id)||e.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=(0,T._K2)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}const a=new $e(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>$(e,i,a))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[R(e)[0]])),i=n.map((e=>R(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=Oe(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=R(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),b={};for(;p.length>0;){const e=this.processStack(a,p,t,f,b,g,o,m,u);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=l.filter((e=>!Le(e)&&!$(e.name,f,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&N("isConstant",e.node,r,n)&&([c]=D(e.node.name,n)),null==r[e.node.name]){const d=Ne(e.node,r,n,this._resourceManager);c||([c]=D(e.node.name,n));const h=n.currentContext;T.ZSL.isPromise(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=D(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!$(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!$(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=R(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));T.ZSL.assert(t,(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&T.ZSL.assert(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=R(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=R(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class Ve{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}var Ue=n(5270);const je="?tfjs-format=file",We="model.json";class Ge{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=T.io){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new Ve}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return T.ZSL.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await(0,Ue.s5)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new Be(re.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=re.Instance.transformGraph(e.modelInitializer);this.initializer=new Be(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof T.qYS?[e]:e,n={};return t.forEach(((e,t)=>n[this.structuredOutputKeys[t]]=e)),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof T.qYS||Array.isArray(e))){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,T.ASo)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function He(e,t={},n=T.io){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${We}${je}`}(e));const r=new Ge(e,t,n);return await r.load(),r}function qe(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){const[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!(r&&r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");const s=T.io.getWeightSpecs(n.weightsManifest),a=T.io.getModelArtifactsForJSONSync(n,s,r);t=T.io.fromMemorySync(a)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=T.io.fromMemorySync(e)}const n=new Ge(t);return n.load(),n}const Ze="4.18.0"},5791:(e,t,n)=>{"use strict";n.d(t,{GJ:()=>r,uI:()=>s});class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class s{refCount(e){return a("refCount")}incRef(e){return a("incRef")}timerAvailable(){return!0}time(e){return a("time")}read(e){return a("read")}readSync(e){return a("readSync")}readToGPU(e,t){return a("readToGPU")}numDataIds(){return a("numDataIds")}disposeData(e,t){return a("disposeData")}write(e,t,n){return a("write")}move(e,t,n,r,s){return a("move")}createTensorFromGPUData(e,t,n){return a("createTensorFromGPUData")}memory(){return a("memory")}floatPrecision(){return a("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return a("dispose")}}function a(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},7169:(e,t,n)=>{"use strict";function r(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||s)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function s(e,t){return e>t?1:e<t?-1:0}function a(e,t,n,r,s){return l(e,t,n,r,s,0)}function i(e,t,n,r,s,a){return l(e,t,n,r,s,0,!1,a,!0)}function o(e,t,n,r,s,a){return l(e,t,n,r,s,a,!0)}function l(e,t,n,s,a,i,o=!1,l=!1,h=!1){const p=[];for(let e=0;e<t.length;e++)t[e]>a&&p.push({score:t[e],boxIndex:e,suppressBeginIndex:0});p.sort(d);const f=i>0?-.5/i:0,m=[],g=[];for(;m.length<n&&p.length>0;){const t=p.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=t;if(n<a)break;let l=!1;for(let n=m.length-1;n>=o;--n){const r=u(e,i,m[n]);if(r>=s){l=!0;break}if(t.score=t.score*c(s,f,r),t.score<=a)break}t.suppressBeginIndex=m.length,l||(t.score===n?(m.push(i),g.push(t.score)):t.score>a&&r(p,t,d))}const b=m.length,y=n-b;l&&y>0&&(m.push(...new Array(y).fill(0)),g.push(...new Array(y).fill(0)));const w={selectedIndices:m};return o&&(w.selectedScores=g),h&&(w.validOutputs=b),w}function u(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),b=Math.min(o,d),y=Math.min(l,h),w=Math.max(b-m,0)*Math.max(y-g,0);return w/(p+f-w)}function c(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function d(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,{c7:()=>a,ZS:()=>i,ut:()=>o})},197:(e,t,n)=>{"use strict";n.d(t,{Y:()=>s});var r=n(1950);function s(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const s=(0,r.r)(e,"int32"),a=(0,r.r)([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const r=s.indexToLoc(n[t]),i=t*e.length;a.values.set(r,i)}return a.toTensor()}},9936:(e,t,n)=>{"use strict";n.d(t,{T2:()=>v,Ye:()=>w});var r=n(5791),s=n(3772),a=n(9245),i=n(2787),o=n(1112),l=n(8391),u=n(7343),c=n(6689);class d{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new p)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let i;const o=u.now();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();i=Promise.resolve({kernelMs:u.now()-o})}if((0,s._K)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{h(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then((e=>e.kernelMs)),extraInfo:i.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function h(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class p{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?c.av(`${r}ms`,9):r.error,o=c.av(e,25),l=t.rank,u=t.size,d=c.av(t.shape.toString(),14);let h="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;h+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${d}\t%c${u}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var f=n(1794),m=n(3031);function g(e){return null!=e.kernelName}class b{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class y{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new b}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(l.i(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new d(this.backendInstance),!0}setupRegisteredKernels(){(0,o.Op)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){(0,o.Op)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r.uI||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,l.i(`Initialization of backend ${e} failed`),l.i(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return l.i(`Initialization of backend ${e} failed`),l.i(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return y.nextTensorId++}nextVariableId(){return y.nextVariableId++}clone(e){const t=v.runKernel(i.lzr,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return v.runKernel(i.KXH,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==(0,o._5)(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=g(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(g(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const u=(0,o._5)(t,this.backendName);c.vA(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();l=u.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const o=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,o);n=this.saveTensorsForBackwardMode(e)}return o}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();l=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:d,attrs:h}=e,p=g(e)?null:e.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(u,d,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs):t=i()})),r&&this.addTapeNode(u,d,t,p,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map((e=>null!=d[e]?d[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=(0,o.vQ)(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(c.vA(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&c.Kg(e[0])&&(s=e.map((e=>u.encodeString(e))));const a=r.write(s,t,n),i=new f.qY(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=(0,c.SL)(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new f.qY(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new f.rT(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*c.jv(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof f.rT||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*c.jv(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},l=(0,o.vQ)(e);null!=l&&(r=l.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=c.Ty(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=(0,m.getTensorsInContainer)(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(c.vA(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));c.vA(s instanceof f.qY,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=(0,c.FZ)((0,c.Ze)(e),"float32");return v.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!c.r1(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),x);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return c.vA(c.Tn(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;c.vA(t.every((e=>e instanceof f.qY)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),c.vA(n.value instanceof f.qY,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),c.vA(c.Tn(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];c.vA(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),c.vA(a.every((e=>e instanceof f.qY)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=(0,u.now)(),n=await this.backend.time(e);return n.wallMs=(0,u.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new b;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function w(){const e=(0,a.L)();if(null==e._tfengine){const t=new s.OH(e);e._tfengine=new y(t)}return(0,s.tj)(e._tfengine.ENV),(0,f.qP)((()=>e._tfengine)),e._tfengine}y.nextTensorId=0,y.nextVariableId=0;const v=w();function x(e,t){const n={a:e,b:t};return v.runKernel(i.OMN,n)}},3772:(e,t,n)=>{"use strict";n.d(t,{Km:()=>l,OH:()=>a,_K:()=>o,tj:()=>u});var r=n(6689);const s="tfjsflags";class a{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=i,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(o().getBool("IS_TEST")||o().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];o().getBool("IS_TEST")||o().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if((0,r.yL)(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);s in e&&e[s].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}function i(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function o(){return l}let l=null;function u(e){l=e}},9245:(e,t,n)=>{"use strict";let r;function s(){if(null==r){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}r=e}return r}function a(e,t){const n=function(){const e=s();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}n.d(t,{L:()=>s,m:()=>a})},4917:(e,t,n)=>{"use strict";n.d(t,{AS:()=>g,DZ:()=>m,Gc:()=>v,Hi:()=>h,Hs:()=>I,IS:()=>u,ME:()=>f,Ok:()=>E,Sm:()=>o,W4:()=>S,aC:()=>b,fL:()=>c,gJ:()=>T,gY:()=>l,go:()=>k,jh:()=>w,jz:()=>x,kB:()=>y,m1:()=>p,rE:()=>_,rm:()=>d});var r=n(9936),s=n(3772),a=n(1794),i=n(3031);function o(){(0,s._K)().set("PROD",!0)}function l(){(0,s._K)().set("DEBUG",!0)}function u(){(0,s._K)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function c(e){(0,s._K)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function d(){r.T2.disposeVariables()}function h(){return r.T2}function p(){return r.T2.memory()}function f(e){return r.T2.profile(e)}function m(e,t){return r.T2.tidy(e,t)}function g(e){(0,i.getTensorsInContainer)(e).forEach((e=>e.dispose()))}function b(e){return r.T2.keep(e)}function y(e){return r.T2.time(e)}function w(e){return r.T2.setBackend(e)}function v(){return r.T2.ready()}function x(){return r.T2.backendName}function _(e){r.T2.removeBackend(e)}function k(e){return r.T2.findBackend(e)}function S(e){return r.T2.findBackendFactory(e)}function T(e,t,n=1){return r.T2.registerBackend(e,t,n)}function I(){return r.T2.backend}function E(e,t){(0,s._K)().setPlatform(e,t)}(0,a.B4)(c)},5836:(e,t,n)=>{"use strict";n.d(t,{Dv:()=>o,_X:()=>h,jY:()=>u,mu:()=>c,ok:()=>l,y7:()=>d});var r=n(9936),s=n(1794),a=n(7243),i=n(6689);function o(e){return i.vA(i.Tn(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const s=(0,a.YT)(t,"x","tf.grad","string_or_numeric"),o=null!=n?(0,a.YT)(n,"dy","tf.grad"):null;return r.T2.tidy((()=>{const{value:t,grads:n}=r.T2.gradients((()=>e(s)),[s],o);return null!=o&&i.O3(t.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),p(n),n[0]}))}}function l(e){return i.vA(i.Tn(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{i.vA(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const s=(0,a.j1)(t,"args","tf.grads","string_or_numeric"),o=null!=n?(0,a.YT)(n,"dy","tf.grads"):null;return r.T2.tidy((()=>{const{value:t,grads:n}=r.T2.gradients((()=>e(...s)),s,o);return null!=o&&i.O3(t.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(n),n}))}}function u(e){return i.vA(i.Tn(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{i.vA(t instanceof s.qY,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),i.vA(null==n||n instanceof s.qY,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:a,value:o}=r.T2.gradients((()=>e(t)),[t],n);return p(a),{grad:a[0],value:o}}}function c(e){return i.vA(i.Tn(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{i.vA(Array.isArray(t)&&t.every((e=>e instanceof s.qY)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),i.vA(null==n||n instanceof s.qY,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const a=r.T2.gradients((()=>e(...t)),t,n);return null!=n&&i.O3(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(a.grads),a}}function d(e,t){i.vA(i.Tn(e),(()=>"The f passed in variableGrads(f) must be a function")),i.vA(null==t||Array.isArray(t)&&t.every((e=>e instanceof s.rT)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in r.T2.registeredVariables)t.push(r.T2.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,o=t.length;t=t.filter((e=>e.trainable)),i.vA(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`));const{value:l,grads:u}=r.T2.gradients(e,t,null,!0);i.vA(u.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),i.vA(0===l.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`));const c={};return t.forEach(((e,t)=>{null!=u[t]&&(c[e.name]=u[t])})),null!=a&&a.forEach((e=>c[e.name]=null)),{value:l,grads:c}}function h(e){return r.T2.customGrad(e)}function p(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},1592:(e,t,n)=>{"use strict";n.d(t,{ljI:()=>mt.ljI,Vvy:()=>mt.Vvy,PH8:()=>mt.PH8,K$F:()=>Ae,ah4:()=>Ne,FYc:()=>De,oC7:()=>Me,OMN:()=>mt.OMN,EkD:()=>mt.EkD,u8Z:()=>mt.u8Z,FSt:()=>mt.FSt,Jp_:()=>mt.Jp_,p_m:()=>mt.p_m,QKF:()=>mt.QKF,epO:()=>mt.epO,TyE:()=>mt.TyE,lxb:()=>mt.lxb,zP9:()=>mt.zP9,ho8:()=>mt.ho8,cS:()=>mt.cS,wwC:()=>mt.wwC,VCH:()=>mt.VCH,jAQ:()=>mt.jAQ,Ik2:()=>mt.Ik2,N4F:()=>mt.N4F,HNs:()=>mt.HNs,vj7:()=>mt.vj7,LB5:()=>mt.LB5,KXH:()=>mt.KXH,QDP:()=>mt.QDP,vaV:()=>mt.vaV,pr3:()=>mt.pr3,$zE:()=>mt.$zE,$dB:()=>mt.$dB,p2J:()=>mt.p2J,rFm:()=>mt.rFm,jfg:()=>mt.jfg,A1h:()=>mt.A1h,iGz:()=>mt.iGz,gC7:()=>mt.gC7,Mn0:()=>mt.Mn0,MnK:()=>mt.MnK,MRQ:()=>mt.MRQ,jj_:()=>mt.jj_,nY8:()=>mt.nY8,GJx:()=>cr.GJ,wNW:()=>mt.wNW,TMz:()=>mt.TMz,tGH:()=>mt.tGH,X$8:()=>mt.X$8,nVu:()=>mt.nVu,ORI:()=>mt.ORI,jxD:()=>mt.jxD,pk0:()=>mt.pk0,bP9:()=>mt.bP9,XmO:()=>mt.XmO,Kmu:()=>y.Km,Qgm:()=>mt.Qgm,Pah:()=>mt.Pah,rsH:()=>mt.rsH,OH$:()=>y.OH,BRl:()=>mt.BRl,_s9:()=>mt._s9,ox3:()=>mt.ox3,ybN:()=>mt.ybN,ybj:()=>mt.ybj,rGP:()=>mt.rGP,SQl:()=>mt.SQl,BxF:()=>mt.BxF,ZgB:()=>mt.ZgB,ElG:()=>mt.ElG,awo:()=>mt.awo,i5R:()=>mt.i5R,aAr:()=>mt.aAr,T7M:()=>mt.T7M,O4G:()=>mt.O4G,mxL:()=>mt.mxL,XhZ:()=>mt.XhZ,lLS:()=>mt.lLS,OAQ:()=>mt.OAQ,lzr:()=>mt.lzr,dv8:()=>mt.dv8,gIW:()=>mt.gIW,E3$:()=>mt.E3$,iPs:()=>mt.iPs,uI_:()=>cr.uI,jM4:()=>mt.jM4,ToN:()=>mt.ToN,X0$:()=>mt.X0$,mIA:()=>mt.mIA,CwD:()=>mt.CwD,mnI:()=>mt.mnI,tG8:()=>mt.tG8,Cg$:()=>mt.Cg$,zfU:()=>mt.zfU,RUm:()=>mt.RUm,nZd:()=>mt.nZd,LXA:()=>mt.LXA,RW8:()=>mt.RW8,yPW:()=>mt.yPW,WRv:()=>mt.WRv,VAI:()=>mt.VAI,t3d:()=>mt.t3d,ySp:()=>mt.ySp,cHb:()=>mt.cHb,RXX:()=>mt.RXX,TL8:()=>mt.TL8,LDN:()=>mt.LDN,g5A:()=>mt.g5A,lNG:()=>mt.lNG,LG0:()=>mt.LG0,x7F:()=>mt.x7F,BLA:()=>mt.BLA,Qu_:()=>Pe,WT3:()=>mt.WT3,xu7:()=>mt.xu7,l0G:()=>mt.l0G,SDM:()=>mt.SDM,Zl4:()=>mt.Zl4,e0f:()=>mt.e0f,ylV:()=>mt.ylV,BTT:()=>Zt.BTT,urI:()=>mt.urI,LWX:()=>mt.LWX,ELo:()=>Ee,L5p:()=>Ht,mM$:()=>mt.mM$,ODT:()=>mt.ODT,bCz:()=>mt.bCz,pyJ:()=>mt.pyJ,Ncv:()=>mt.Ncv,kdj:()=>mt.kdj,PS5:()=>ze,oJ2:()=>mt.oJ2,CQC:()=>mt.CQC,mH5:()=>mt.mH5,Q6t:()=>mt.Q6t,rgM:()=>qt.rg,LRy:()=>mt.LRy,sDr:()=>mt.sDr,huO:()=>mt.huO,iDl:()=>Kt.i,fUj:()=>mt.fUj,P_L:()=>mt.P_L,R23:()=>mt.R23,hgw:()=>mt.hgw,FCQ:()=>mt.FCQ,jOE:()=>mt.jOE,XQy:()=>mt.XQy,D7i:()=>mt.D7i,BK4:()=>mt.BK4,hVg:()=>mt.hVg,TOR:()=>mt.TOR,SYI:()=>Le,pJc:()=>mt.pJc,uWl:()=>mt.uWl,l6P:()=>mt.l6P,u$b:()=>mt.u$b,vI1:()=>mt.vI1,YVe:()=>mt.YVe,hql:()=>mt.hql,J3C:()=>mt.J3C,JiE:()=>mt.JiE,rFG:()=>mt.rFG,Fin:()=>mt.Fin,A8B:()=>mt.A8B,C8s:()=>mt.C8s,BoJ:()=>mt.BoJ,L6G:()=>mt.L6G,DvZ:()=>mt.DvZ,jgd:()=>mt.jgd,Blb:()=>mt.Blb,dFH:()=>mt.dFH,M6A:()=>mt.M6A,Ddj:()=>mt.Ddj,GZp:()=>mt.GZp,pnw:()=>mt.pnw,UcO:()=>mt.UcO,YAb:()=>mt.YAb,iW0:()=>mt.iW0,$jE:()=>mt.$jE,PbM:()=>mt.PbM,WuN:()=>mt.WuN,oFs:()=>mt.oFs,iuW:()=>mt.iuW,qYS:()=>ce.qY,ylz:()=>ce.yl,X4r:()=>mt.X4r,FAs:()=>mt.FAs,TBb:()=>mt.TBb,dLy:()=>mt.dLy,wx0:()=>mt.wx0,EwU:()=>mt.EwU,dXR:()=>mt.dXR,pPe:()=>mt.pPe,RMm:()=>mt.RMm,rTt:()=>ce.rT,xJ3:()=>mt.xJ3,Dr:()=>mt.Dr,tnl:()=>Zt.tnl,HQu:()=>Zt.HQu,FqL:()=>Zt.FqL,WQq:()=>Zt.WQq,QiD:()=>Zt.QiD,Q7R:()=>Zt.Q7R,bzn:()=>Zt.bzn,FLi:()=>Zt.FLi,XRg:()=>Zt.XRg,qRo:()=>Zt.qRo,yHs:()=>Zt.yHs,rYl:()=>Zt.rYl,FPz:()=>Zt.FPz,rfv:()=>Zt.rfv,$jT:()=>Zt.$jT,sub:()=>Zt.sub,Hs:()=>he.Hs,backend_util:()=>d,lZX:()=>Zt.lZX,$v7:()=>Zt.$v7,BFc:()=>Zt.BFc,kSi:()=>Zt.kSi,T5N:()=>Zt.T5N,GTe:()=>Zt.GTe,HbZ:()=>Zt.HbZ,vjT:()=>Zt.vjT,ftb:()=>Zt.ftb,ROE:()=>Zt.ROE,hOW:()=>Zt.hOW,ZEY:()=>ft,TaL:()=>o,ra8:()=>Zt.ra8,wgE:()=>Zt.wgE,mkO:()=>Zt.mkO,zQh:()=>Zt.zQh,o8B:()=>Zt.o8B,faB:()=>Zt.faB,xWs:()=>Zt.xWs,I1m:()=>Zt.I1m,RPU:()=>Zt.RPU,O5O:()=>Zt.O5O,P1l:()=>Zt.P1l,kA9:()=>Zt.kA9,Xtf:()=>Zt.Xtf,wX9:()=>Zt.wX9,IPL:()=>Zt.IPL,jIJ:()=>Zt.jIJ,Cfv:()=>gt.Cf,gnS:()=>Zt.gnS,yIG:()=>Zt.yIG,_jP:()=>Zt._jP,Lp0:()=>Zt.Lp0,rCv:()=>Zt.rCv,_Xg:()=>we._X,aOp:()=>Zt.aOp,fLc:()=>he.fL,Rj8:()=>Zt.Rj8,Gl3:()=>Zt.Gl3,eMq:()=>r,smy:()=>Zt.smy,X7t:()=>Zt.X7t,ISJ:()=>he.IS,ASo:()=>he.AS,rm6:()=>he.rm,y4m:()=>Zt.y4m,ek5:()=>Zt.ek5,Omf:()=>Zt.Omf,EZY:()=>Zt.EZY,_3C:()=>Zt._3C,Pqc:()=>Zt.Pqc,gYU:()=>he.gY,SmG:()=>he.Sm,FJY:()=>Zt.FJY,Hi9:()=>he.Hi,QP2:()=>Zt.QP2,_K2:()=>y._K,LCg:()=>Zt.LCg,Y12:()=>Zt.Y12,p4S:()=>Zt.p4S,oNF:()=>Zt.oNF,UG6:()=>Zt.UG6,IYd:()=>Zt.IYd,y5U:()=>Zt.y5U,hVP:()=>Zt.hVP,GSj:()=>Zt.GSj,goy:()=>he.go,W4C:()=>he.W4,RIf:()=>Zt.RIf,wh_:()=>Zt.wh_,cZk:()=>Zt.cZk,kgh:()=>Zt.kgh,SY9:()=>Zt.SY9,FJy:()=>l,jz4:()=>he.jz,vQR:()=>gt.vQ,_5H:()=>gt._5,OpK:()=>gt.Op,Dvk:()=>we.Dv,ok9:()=>we.ok,rhj:()=>Zt.rhj,DQN:()=>Zt.DQN,KGM:()=>Zt.KGM,ngS:()=>Zt.ngS,image:()=>Zt.Slp,U4u:()=>Zt.U4u,io:()=>a,ggX:()=>Zt.ggX,MIs:()=>Zt.MIs,EN4:()=>Zt.EN4,yrW:()=>Zt.yrW,aCs:()=>he.aC,kpo:()=>h,H8d:()=>Zt.H8d,M7h:()=>Zt.M7h,InN:()=>Zt.InN,mPL:()=>Zt.mPL,mT8:()=>Zt.mT8,Kgs:()=>Zt.Kgs,Rm2:()=>Zt.Rm2,Kko:()=>Zt.Kko,nqI:()=>Zt.nqI,HPB:()=>Zt.HPB,VZ:()=>Zt.VZ,n76:()=>Zt.n76,NSZ:()=>Zt.NSZ,ztW:()=>Zt.ztW,rxB:()=>Zt.rxB,YYh:()=>Zt.YYh,yzS:()=>Zt.yzS,NoW:()=>Zt.NoW,DyF:()=>i,T9B:()=>Zt.T9B,jgi:()=>Zt.jgi,NYV:()=>Zt.NYV,RO:()=>Zt.RO,PhQ:()=>Zt.PhQ,i2o:()=>Zt.i2o,m1Z:()=>he.m1,OYQ:()=>Zt.OYQ,jkA:()=>Zt.jkA,BpO:()=>Zt.BpO,FFZ:()=>Zt.FFZ,ziu:()=>Zt.ziu,Clk:()=>Zt.Clk,CRk:()=>Zt.CRk,lKK:()=>Zt.lKK,YDF:()=>Zt.YDF,OjQ:()=>Zt.OjQ,HZy:()=>Zt.HZy,dA1:()=>Qt,xbf:()=>Zt.xbf,Ec:()=>Zt.Ec,Mw0:()=>Zt.Mw0,SaS:()=>Zt.SaS,P61:()=>Zt.P61,op:()=>Zt.op,X4o:()=>Zt.X4o,eVF:()=>Zt.eVF,BZs:()=>Zt.BZs,grY:()=>Zt.grY,XHu:()=>Zt.XHu,WLX:()=>Zt.WLX,dzn:()=>Zt.dzn,n7C:()=>Zt.n7C,NsG:()=>Zt.NsG,yyV:()=>Zt.yyV,_eU:()=>Zt._eU,MEE:()=>he.ME,whe:()=>Zt.whe,iyU:()=>Zt.iyU,Q0_:()=>Zt.Q0_,_9M:()=>Zt._9M,pR9:()=>Zt.pR9,FE$:()=>Zt.FE$,m0H:()=>Zt.m0H,YeY:()=>Zt.YeY,HYA:()=>Zt.HYA,y17:()=>Zt.y17,Gc4:()=>he.Gc,xav:()=>Zt.xav,VOZ:()=>Zt.VOZ,gJX:()=>he.gJ,krJ:()=>gt.kr,tAK:()=>gt.tA,VVh:()=>Zt.VVh,j__:()=>Zt.j__,rEj:()=>he.rE,tQQ:()=>Zt.tQQ,BEg:()=>Zt.BEg,QD2:()=>Zt.QD2,LMr:()=>Zt.LMr,I2l:()=>Zt.I2l,JYU:()=>Zt.JYU,z8$:()=>Zt.z8$,LIG:()=>Zt.LIG,Z$r:()=>Zt.Z$r,d_2:()=>Zt.d_2,NFr:()=>Zt.NFr,g23:()=>Et,sZg:()=>Zt.sZg,WfX:()=>Zt.WfX,wdz:()=>Zt.wdz,JFn:()=>s,jh6:()=>he.jh,OkC:()=>he.Ok,F12:()=>Zt.F12,ry7:()=>Zt.ry7,_SZ:()=>Zt._SZ,vPA:()=>Zt.vPA,F8e:()=>Zt.F8e,L0l:()=>Zt.L0l,dik:()=>Zt.dik,Q$M:()=>Zt.Q$M,zAd:()=>Zt.zAd,wck:()=>Zt.wck,R0O:()=>Zt.R0O,Kro:()=>At,Vs9:()=>Zt.Vs9,lw0:()=>Zt.lw0,eDJ:()=>Zt.eDJ,lMo:()=>Zt.lMo,Zhr:()=>Zt.Zhr,lOn:()=>Zt.lOn,lDo:()=>Zt.lDo,RZD:()=>Zt.RZD,EwI:()=>Zt.EwI,Pbu:()=>Zt.Pbu,r2V:()=>Zt.r2V,t$z:()=>Zt.t$z,PMw:()=>Zt.PMw,Ym9:()=>Zt.Ym9,YjP:()=>Zt.YjP,jbE:()=>Zt.jbE,czq:()=>Zt.czq,chL:()=>qt.ch,Mlm:()=>Zt.Mlm,ymU:()=>Zt.ymU,OEK:()=>Zt.OEK,tGX:()=>Zt.tGX,KtR:()=>Zt.KtR,$_$:()=>Zt.$_$,g9W:()=>Zt.g9W,Lpo:()=>Zt.Lpo,yxw:()=>Zt.yxw,NNh:()=>Zt.NNh,d_S:()=>Ct,Obs:()=>u,DZQ:()=>he.DZ,Vsq:()=>Zt.Vsq,kBw:()=>he.kB,rfw:()=>Zt.rfw,BaG:()=>Yt,mgz:()=>Zt.mgz,efE:()=>Zt.efE,AmM:()=>Zt.AmM,rYx:()=>gt.rY,iPt:()=>gt.iP,zAU:()=>Zt.zAU,K$i:()=>Zt.K$i,TuY:()=>qt.Tu,rni:()=>Zt.rni,ZSL:()=>Nt,jYt:()=>we.jY,muS:()=>we.mu,bvq:()=>Zt.bvq,y7e:()=>we.y7,bgA:()=>Gt,_M9:()=>Zt._M9,YJN:()=>Zt.YJN,Ul9:()=>Zt.Ul9,POl:()=>Zt.POl});var r={};n.r(r),n.d(r,{isBrowser:()=>b,isMobile:()=>g,mockIsMobile:()=>m});var s={};n.r(s),n.d(s,{Serializable:()=>ke,SerializationMap:()=>Se,getRegisteredName:()=>Ie,registerClass:()=>Te});var a={};n.r(a),n.d(a,{CompositeArrayBuffer:()=>I.D,browserFiles:()=>We,browserHTTPRequest:()=>et,concatenateArrayBuffers:()=>v.AQ,copyModel:()=>te,decodeWeights:()=>v.CY,decodeWeightsStream:()=>v.s5,encodeWeights:()=>v.aG,fromMemory:()=>st,fromMemorySync:()=>at,getLoadHandlers:()=>T,getModelArtifactsForJSON:()=>v.Ej,getModelArtifactsForJSONSync:()=>v.Rl,getModelArtifactsInfoForJSON:()=>v.oR,getSaveHandlers:()=>S,getWeightSpecs:()=>v.Xf,http:()=>Je,isHTTPScheme:()=>Xe,listModels:()=>J,loadWeights:()=>Ze,moveModel:()=>ne,registerLoadRouter:()=>k,registerSaveRouter:()=>_,removeModel:()=>ee,weightsLoaderFactory:()=>Ke,withSaveHandler:()=>it,withSaveHandlerSync:()=>ot});var i={};n.r(i),n.d(i,{confusionMatrix:()=>pt});var o={};n.r(o),n.d(o,{draw:()=>St,fromPixels:()=>Tt,fromPixelsAsync:()=>xt,toPixels:()=>kt});var l={};n.r(l),n.d(l,{prepareAndValidate:()=>It});var u={};n.r(u),n.d(u,{TEST_EPSILON_FLOAT16:()=>Ot,createVideoElement:()=>jt,encodeStrings:()=>Ut,expectArrayBuffersEqual:()=>Vt,expectArraysClose:()=>Dt,expectArraysEqual:()=>Lt,expectNumbersClose:()=>Pt,expectPromiseToFail:()=>Mt,expectValuesInRange:()=>Bt,play:()=>Wt,testEpsilon:()=>Ft});var c={};n.r(c),n.d(c,{collectGatherOpShapeInfo:()=>ar,computeOutShape:()=>sr,segOpComputeOptimalWindowSize:()=>rr});var d={};n.r(d),n.d(d,{ERF_A1:()=>vn,ERF_A2:()=>xn,ERF_A3:()=>_n,ERF_A4:()=>kn,ERF_A5:()=>Sn,ERF_P:()=>wn,PARALLELIZE_THRESHOLD:()=>cn,RowPartitionType:()=>nn,SELU_SCALE:()=>yn.X,SELU_SCALEALPHA:()=>yn.j,applyActivation:()=>sn.f2,assertAndGetBroadcastShape:()=>ft.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>Jt.WC,assertParamsConsistent:()=>en,assignToTypedArray:()=>$n,axesAreInnerMostDims:()=>Jt.WH,calculateShapes:()=>Et.calculateShapes,checkEinsumDimSizes:()=>Bn,checkPadOnDimRoundingMode:()=>rn.s_,combineLocations:()=>Jt.aF,combineRaggedTensorToTensorShapes:()=>an,complexWithEvenIndex:()=>An,complexWithOddIndex:()=>Cn,computeConv2DInfo:()=>rn.uf,computeConv3DInfo:()=>rn.p$,computeDefaultPad:()=>rn.G8,computeDilation2DInfo:()=>rn.YQ,computeOptimalWindowSize:()=>dn,computeOutAndReduceShapes:()=>Jt.lb,computeOutShape:()=>tn,computePool2DInfo:()=>rn.E6,computePool3DInfo:()=>rn.l5,convertConv2DDataFormat:()=>rn.$Q,decodeEinsumEquation:()=>Pn,eitherStridesOrDilationsAreOne:()=>rn.G0,expandShapeToKeepDim:()=>Jt.SM,exponent:()=>Dn,exponents:()=>On,fromStringArrayToUint8:()=>or,fromUint8ToStringArray:()=>ir,getAxesPermutation:()=>Jt.Em,getBroadcastDims:()=>ft.getBroadcastDims,getComplexWithIndex:()=>Nn,getEinsumComputePath:()=>Vn,getEinsumPermutation:()=>zn,getFusedBiasGradient:()=>sn.Do,getFusedDyActivation:()=>sn.XB,getImageCenter:()=>hn,getInnerMostAxes:()=>Jt.fK,getPermuted:()=>fn,getRaggedRank:()=>ln,getReductionAxes:()=>ft.getReductionAxes,getReshaped:()=>pn,getReshapedPermuted:()=>mn,getRowPartitionTypesHelper:()=>on,getSliceBeginCoords:()=>gn,getSliceSize:()=>bn,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Gn,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Hn,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>qn,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Yn,getSparseReshapeInputOutputMismatchErrorMessage:()=>Qn,getSparseReshapeInputOutputMultipleErrorMessage:()=>Xn,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Zn,getSparseReshapeNegativeOutputDimErrorMessage:()=>Kn,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>nr,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Jn,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>er,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>tr,getUndoAxesPermutation:()=>Jt.gx,isIdentityPermutation:()=>Un,log:()=>Tn.R,mergeRealAndImagArrays:()=>In,prepareAndValidate:()=>It,prepareSplitSize:()=>Wn,segment_util:()=>c,shouldFuse:()=>sn.zE,slice_util:()=>At,splitRealAndImagArrays:()=>En,stridesOrDilationsArePositive:()=>rn.qk,tupleValuesAreOne:()=>rn.Dh,upcastType:()=>qt.Tu,validateDefaultValueShape:()=>un,validateInput:()=>Et.validateInput,validateUpdateShape:()=>Et.validateUpdateShape,warn:()=>Tn.i});var h={};n.r(h),n.d(h,{nonMaxSuppressionV3Impl:()=>lr.c7,nonMaxSuppressionV4Impl:()=>lr.ZS,nonMaxSuppressionV5Impl:()=>lr.ut,whereImpl:()=>ur.Y});var p=n(9936);let f;function m(e){f=e}function g(e){if(void 0!==f)return f;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function b(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var y=n(3772);const w=(0,y._K)();w.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),w.registerFlag("IS_BROWSER",(()=>b())),w.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),w.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),w.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),w.registerFlag("PROD",(()=>!1)),w.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>w.getBool("DEBUG"))),w.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),w.registerFlag("IS_TEST",(()=>!1)),w.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>w.getBool("DEBUG"))),w.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),w.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),w.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var v=n(5270);class x{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==x.instance&&(x.instance=new x),x.instance}static registerSaveRouter(e){x.getInstance().saveRouters.push(e)}static registerLoadRouter(e){x.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return x.getHandlers(e,"save")}static getLoadHandlers(e,t){return x.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?x.getInstance().loadRouters:x.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const _=e=>x.registerSaveRouter(e),k=e=>x.registerLoadRouter(e),S=e=>x.getSaveHandlers(e),T=(e,t)=>x.getLoadHandlers(e,t);var I=n(7508);const E="tensorflowjs",A="models_store",C="model_info_store";function N(){if(!(0,y._K)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function $(e){const t=e.result;t.createObjectStore(A,{keyPath:"modelPath"}),t.createObjectStore(C,{keyPath:"modelPath"})}class O{constructor(e){if(this.indexedDB=N(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(E,1);r.onupgradeneeded=()=>$(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(A,"readonly"),r=t.objectStore(A).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=I.D.join(t.weightData);const r=(0,v.oR)(t),a=s.transaction(C,"readwrite");let i,o,l=a.objectStore(C);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}i.onsuccess=()=>{o=s.transaction(A,"readwrite");const i=o.objectStore(A);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}u.onsuccess=()=>e({modelArtifactsInfo:r}),u.onerror=e=>{l=a.objectStore(C);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(u.error)),t.onerror=e=>(s.close(),n(u.error))}},i.onerror=e=>(s.close(),n(i.error)),a.oncomplete=()=>{null==o?s.close():o.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}O.URL_SCHEME="indexeddb://";const D=e=>{return(0,y._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(O.URL_SCHEME)?(t=e.slice(O.URL_SCHEME.length),new O(t)):null;var t};x.registerSaveRouter(D),x.registerLoadRouter(D);class F{constructor(){this.indexedDB=N()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(E,1);n.onupgradeneeded=()=>$(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(C,"readonly"),a=s.objectStore(C).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(O.URL_SCHEME)?t.slice(O.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(E,1);r.onupgradeneeded=()=>$(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(C,"readwrite"),i=a.objectStore(C),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(A,"readwrite");const r=l.objectStore(A).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}var R=n(6689);const M="/",L="tensorflowjs_models",P="info",z="model_topology",B="weight_specs",V="weight_data",U="model_metadata";function j(e){return{info:[L,e,P].join(M),topology:[L,e,z].join(M),weightSpecs:[L,e,B].join(M),weightData:[L,e,V].join(M),modelMetadata:[L,e,U].join(M)}}function W(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function G(e){const t=e.split(M);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(M)}class H{constructor(e){if(!(0,y._K)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=j(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=(0,v.oR)(e),s=I.D.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(0,v.l3)(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw W(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=(0,v.jf)(a),t}}H.URL_SCHEME="localstorage://";const q=e=>{return(0,y._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(H.URL_SCHEME)?(t=e.slice(H.URL_SCHEME.length),new H(t)):null;var t};x.registerSaveRouter(q),x.registerLoadRouter(q);class Z{constructor(){(0,R.vA)((0,y._K)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,R.vA)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=L+M,n=M+P;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(t)&&s.endsWith(n)&&(e[G(s)]=JSON.parse(this.LS.getItem(s)))}return e}async removeModel(e){var t;const n=j(e=(t=e).startsWith(H.URL_SCHEME)?t.slice(H.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return W(n),r}}const K="://";class Y{constructor(){this.managers={}}static getInstance(){return null==Y.instance&&(Y.instance=new Y),Y.instance}static registerManager(e,t){(0,R.vA)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(K)&&(e=e.slice(0,e.indexOf(K))),(0,R.vA)(e.length>0,(()=>"scheme must not be an empty string."));const n=Y.getInstance();(0,R.vA)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Y.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Y.getInstance().managers)}}function X(e){if(-1===e.indexOf(K))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Y.getSchemes().join(",")}`);return{scheme:e.split(K)[0],path:e.split(K)[1]}}async function Q(e,t,n=!1){(0,R.vA)(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=x.getLoadHandlers(e);(0,R.vA)(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),(0,R.vA)(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=x.getSaveHandlers(t);(0,R.vA)(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),(0,R.vA)(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=X(e).scheme,l=X(e).path,u=o===X(e).scheme,c=await s.load();n&&u&&await Y.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await Y.getManager(o).removeModel(l),d.modelArtifactsInfo}async function J(){const e=Y.getSchemes(),t={};for(const n of e){const e=await Y.getManager(n).listModels();for(const r in e)t[n+K+r]=e[r]}return t}async function ee(e){const t=X(e);return Y.getManager(t.scheme).removeModel(t.path)}async function te(e,t){return Q(e,t,!1)}async function ne(e,t){return Q(e,t,!0)}var re=n(9094);class se{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&(0,y._K)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return(0,re.Y)(e)}}if((0,y._K)().get("IS_BROWSER")){(0,y._K)().setPlatform("browser",new se);try{Y.registerManager(H.URL_SCHEME,new Z)}catch(e){}try{Y.registerManager(O.URL_SCHEME,new F)}catch(e){}}let ae;(0,y._K)().get("IS_NODE")&&!(0,y._K)().get("IS_BROWSER")&&(0,y._K)().setPlatform("node",new class{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,y._K)().global.fetch?(0,y._K)().global.fetch(e,t):(null==ae&&(ae=n(5817)),ae(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var ie=n(1950),oe=n(3583),le=n(99),ue=n(7905),ce=n(1794);(0,p.Ye)();const de={buffer:ie.r,cast:oe.w,clone:le.o,print:ue.y};(0,ce.Q5)(de);var he=n(4917),pe=n(9389),fe=n(4493),me=n(6596),ge=n(178),be=n(5935),ye=n(7591),we=n(5836),ve=n(9e3);const xe=new Map,_e=new Map;class ke{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Se{constructor(){this.classNameMap={}}static getMap(){return null==Se.instance&&(Se.instance=new Se),Se.instance}static register(e){Se.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Te(e,t,n){(0,R.vA)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),(0,R.vA)("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),(0,R.vA)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return Se.register(e),xe.set(r,e),_e.set(e,r),e}function Ie(e){return _e.has(e)?_e.get(e):e.className}class Ee extends ke{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return(0,he.AS)(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,we.y7)(e,t)}dispose(){null!=this.iterations_&&(0,he.AS)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,ve.d)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ee,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Ae extends Ee{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,he.DZ)((()=>(0,ye.P)(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,he.DZ)((()=>(0,ye.P)(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;(0,he.DZ)((()=>{const e=(0,pe.W)((0,me.l)(i,this.rho),(0,me.l)((0,be.E)(a),1-this.rho)),t=(0,me.l)((0,fe.y)((0,ge.R)((0,pe.W)(o,this.epsilon)),(0,ge.R)((0,pe.W)(i,this.epsilon))),a),n=(0,pe.W)((0,me.l)(o,this.rho),(0,me.l)((0,be.E)(t),1-this.rho));i.assign(e),o.assign(n);const s=(0,pe.W)((0,me.l)(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,he.AS)(this.accumulatedGrads.map((e=>e.variable))),(0,he.AS)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}var Ce=n(6673);class Ne extends Ee{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,he.DZ)((()=>(0,Ce.G)(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;(0,he.DZ)((()=>{const e=(0,pe.W)(a,(0,be.E)(s));a.assign(e);const t=(0,pe.W)((0,me.l)((0,fe.y)(s,(0,ge.R)((0,pe.W)(e,p.T2.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,he.AS)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}var $e=n(6712),Oe=n(3136);class De extends Ee{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,he.DZ)((()=>{this.accBeta1=(0,ve.d)(t).variable(),this.accBeta2=(0,ve.d)(n).variable()})),null==r&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,he.DZ)((()=>{const n=(0,Oe.j)(1,this.accBeta1),r=(0,Oe.j)(1,this.accBeta2);t.forEach(((t,s)=>{const a=p.T2.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:(0,he.DZ)((()=>(0,ye.P)(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:(0,he.DZ)((()=>(0,ye.P)(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=(0,pe.W)((0,me.l)(l,this.beta1),(0,me.l)(o,1-this.beta1)),d=(0,pe.W)((0,me.l)(u,this.beta2),(0,me.l)((0,be.E)(o),1-this.beta2)),h=(0,fe.y)(c,n),f=(0,fe.y)(d,r);l.assign(c),u.assign(d);const m=(0,pe.W)((0,me.l)((0,fe.y)(h,(0,pe.W)((0,ge.R)(f),this.epsilon)),-this.learningRate),a);a.assign(m)})),this.accBeta1.assign((0,me.l)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,me.l)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,he.AS)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&(0,he.AS)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),(0,he.DZ)((()=>{this.accBeta1.assign((0,$e.n)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,$e.n)(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}var Fe=n(6762),Re=n(1460);class Me extends Ee{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,he.DZ)((()=>{this.iteration=(0,ve.d)(0).variable(),this.accBeta1=(0,ve.d)(t).variable()})),null==r&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,he.DZ)((()=>{const n=(0,Oe.j)(1,this.accBeta1),r=(0,fe.y)(-this.learningRate,(0,pe.W)((0,me.l)(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=p.T2.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:(0,ye.P)(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:(0,ye.P)(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=(0,pe.W)((0,me.l)(l,this.beta1),(0,me.l)(o,1-this.beta1)),d=(0,me.l)(u,this.beta2),h=(0,Fe.t)(o),f=(0,Re.P)(d,h);l.assign(c),u.assign(f);const m=(0,pe.W)((0,me.l)((0,fe.y)(r,n),(0,fe.y)(c,(0,pe.W)(f,this.epsilon))),a);a.assign(m)})),this.iteration.assign((0,pe.W)(this.iteration,1)),this.accBeta1.assign((0,me.l)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,he.AS)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&(0,he.AS)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Le extends Ee{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=p.T2.registeredVariables[t];(0,he.DZ)((()=>{const e=(0,pe.W)((0,me.l)(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,he.aC)((0,ve.d)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Pe extends Le{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,ve.d)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,he.DZ)((()=>(0,ye.P)(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&(0,he.DZ)((()=>{let e;const t=(0,pe.W)((0,me.l)(this.m,s),a);e=this.useNesterov?(0,pe.W)((0,me.l)(this.c,(0,pe.W)(a,(0,me.l)(t,this.m))),r):(0,pe.W)((0,me.l)(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,he.AS)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class ze extends Ee{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=p.T2.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,he.DZ)((()=>(0,ye.P)(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,he.DZ)((()=>(0,ye.P)(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,he.DZ)((()=>(0,ye.P)(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;(0,he.DZ)((()=>{const e=(0,pe.W)((0,me.l)(i,this.decay),(0,me.l)((0,be.E)(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=(0,pe.W)((0,me.l)(t,this.decay),(0,me.l)(a,1-this.decay)),l=(0,fe.y)((0,me.l)(a,this.learningRate),(0,ge.R)((0,Oe.j)(e,(0,pe.W)((0,be.E)(s),this.epsilon)))),u=(0,pe.W)((0,me.l)(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=(0,Oe.j)(r,u);r.assign(c)}else{const e=(0,pe.W)((0,me.l)(i,this.decay),(0,me.l)((0,be.E)(a),1-this.decay)),t=(0,pe.W)((0,me.l)(o,this.momentum),(0,fe.y)((0,me.l)(a,this.learningRate),(0,ge.R)((0,pe.W)(e,this.epsilon))));i.assign(e),o.assign(t);const n=(0,Oe.j)(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,he.AS)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,he.AS)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&(0,he.AS)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Be=[Ae,Ne,De,Me,Pe,ze,Le];function Ve(e){return new Promise((e=>setTimeout(e))).then(e)}class Ue{constructor(e){if(!(0,y._K)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ue.URL_SCHEME)&&(e=e.slice(Ue.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=I.D.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=(0,v.zV)(e,t),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await Ve((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Ve((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:(0,v.oR)(e)}}}}Ue.URL_SCHEME="downloads://";class je{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=(0,v.Ej)(r,(e=>this.loadWeights(e)));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>(0,v.P8)(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=(0,v.P8)(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function We(e){return new je(e)}function Ge(e,t,n,r){!function(e){(0,R.vA)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){(0,R.vA)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),(0,R.vA)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),(0,R.vA)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}x.registerSaveRouter((e=>(0,y._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ue.URL_SCHEME)?function(e="model"){return new Ue(e)}(e.slice(Ue.URL_SCHEME.length)):null));var He=n(755);async function qe(e,t){null==t&&(t={});const n=null==t.fetchFunc?(0,y._K)().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Ge(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Ge(s,t.onProgress,.5,1)}async function Ze(e,t="",n,r){return Ke((e=>qe(e,{requestInit:r})))(e,t,n)}function Ke(e){return async(t,n="",r)=>{const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=He.i[l]*R.Ze(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length,r=new I.D(c.slice(h,h+n));a[e].forEach((e=>{const t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=(0,v.CY)(t,[e.manifestEntry]);for(const e in n)d[e]=n[e]})),h+=n})),d}}class Ye{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,R.vA)("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=(0,y._K)().platform.fetch,(0,R.vA)(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&(0,R.vA)(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=(0,v.zV)(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=I.D.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:(0,v.oR)(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return(0,v.Ej)(e,(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=(0,v.Xf)(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?(0,y._K)().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[(0,v.Xf)(e),await qe(t,this.loadOptions)]}}function Xe(e){return null!=e.match(Ye.URL_SCHEME_REGEX)}Ye.URL_SCHEME_REGEX=/^https?:\/\//;const Qe=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Xe(e))):Xe(e),n)return Je(e,t)}return null};function Je(e,t){return new Ye(e,t)}function et(e,t){return Je(e,t)}x.registerSaveRouter(Qe),x.registerLoadRouter(Qe);class tt{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class nt{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class rt{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function st(e,t,n,r){return new rt(at(...arguments))}function at(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new tt(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new tt({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new tt({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function it(e){return new nt(e)}function ot(e){return new nt(e)}var lt=n(7243),ut=n(4293),ct=n(7690),dt=n(779),ht=n(7365);const pt=(0,dt.op)({confusionMatrix_:function(e,t,n){const r=(0,lt.YT)(e,"labels","confusionMatrix"),s=(0,lt.YT)(t,"predictions","confusionMatrix");R.vA(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),R.vA(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),R.vA(1===s.rank,(()=>`Expected the rank of predictions to be 1, but got ${s.rank}`)),R.vA(r.shape[0]===s.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`)),R.vA(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const a=(0,ct.M)((0,oe.w)(r,"int32"),n),i=(0,ct.M)((0,oe.w)(s,"int32"),n),o=(0,ht.m)(a),l=(0,ut.N)(o,i);return(0,oe.w)(l,"int32")}});var ft=n(548),mt=n(2787),gt=n(1112),bt=n(1066);let yt,wt=!1;function vt(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=(0,gt._5)(mt.awo,p.T2.backendName)){const n={pixels:e},r={numChannels:t};return p.T2.runKernel(mt.awo,n,r)}const[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(null==yt)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");yt=new OffscreenCanvas(1,1).getContext("2d")}else yt=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});yt.canvas.width=l,yt.canvas.height=u,yt.drawImage(e,0,0,l,u),c=yt.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}const h=[u,l,t];return(0,bt.$)(d,h,"int32")}async function xt(e,t=3){let n=null;if((0,y._K)().getBool("WRAP_TO_IMAGEBITMAP")&&function(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return vt(n,t)}function _t(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function kt(e,t){let n=(0,lt.YT)(e,"img","toPixels");if(!(e instanceof ce.qY)){const e=n;n=(0,oe.w)(e,"int32"),e.dispose()}_t(n);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let e=0;e<r*s;++e){const t=[0,0,0,255];for(let r=0;r<a;r++){const s=i[e*a+r];if("float32"===n.dtype){if(s<0||s>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${s}.`)}else if("int32"===n.dtype&&(s<0||s>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${s}.`);1===a?(t[0]=s*o,t[1]=s*o,t[2]=s*o):t[r]=s*o}const r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){wt||null!=(0,gt._5)(mt.XmO,p.T2.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),wt=!0),t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function St(e,t,n){let r=(0,lt.YT)(e,"img","draw");if(!(e instanceof ce.qY)){const e=r;r=(0,oe.w)(e,"int32"),e.dispose()}_t(r),function(e){const t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);const s={image:r},a={canvas:t,options:n};p.T2.runKernel(mt.XmO,s,a)}const Tt=(0,dt.op)({fromPixels_:vt});function It(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===(0,R.Ze)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let e=0;e<s.length-1;++e)i*=s[e];const o=e.shape,l=s.slice();l.pop();let u=1;for(let e=a;e<n;++e)u*=o[e],l.push(o[e]);const c=[...(0,R.Ur)(e.shape).map((e=>e/u)),1].slice(0,a);return[l,i,u,c]}var Et=n(9684),At=n(2955),Ct=n(3031),Nt=n(7343);const $t=.001,Ot=.1;function Dt(e,t,n){return null==n&&(n=Ft()),Rt(e,t,((e,t)=>zt(e,t,n)))}function Ft(){return 32===p.T2.backend.floatPrecision()?$t:Ot}function Rt(e,t,n){let r=!0;if(((0,Nt.isTypedArray)(e)||(0,Nt.isTypedArray)(t))&&(r=!1),(0,Nt.isTypedArray)(e)&&(0,Nt.isTypedArray)(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=(0,lt.MZ)(e),r=(0,lt.MZ)(t);if(!(0,R.r1)(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=(0,Nt.isTypedArray)(e)?e:(0,Nt.flatten)(e),a=(0,Nt.isTypedArray)(t)?t:(0,Nt.flatten)(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.\nActual:   ${s}.\nExpected: ${a}.`);for(let e=0;e<a.length;++e){const t=s[e],r=a[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${s}.\nExpected: ${a}.`)}"undefined"!=typeof expect&&expect().nothing()}function Mt(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function Lt(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return(0,R.Kg)(e)||(0,R.Kg)(e[0])||(0,R.Kg)(t)||(0,R.Kg)(t[0])?Rt(e,n,((e,t)=>e==t)):Rt(e,t,((e,t)=>zt(e,t,0)))}function Pt(e,t,n){if(null==n&&(n=Ft()),!zt(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function zt(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Bt(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Vt(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw new Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function Ut(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Ut(n):e[t]=(0,Nt.encodeString)(n)}return e}function jt(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function Wt(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}const Gt="4.18.0";class Ht{static sgd(e){return new Le(e)}static momentum(e,t,n=!1){return new Pe(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new ze(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new De(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Ae(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Me(e,t,n,r,s)}static adagrad(e,t=.1){return new Ne(e,t)}}var qt=n(3056),Zt=n(2740),Kt=n(7506);const Yt=Ht,Xt="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Qt(){return new Promise((e=>Xt((()=>e()))))}var Jt=n(4640);function en(e,t){const n=e[0].length;e.forEach(((e,t)=>{R.vA(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),R.vA(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)R.vA(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function tn(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var nn,rn=n(8785),sn=n(9192);function an(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function on(e){const t={FIRST_DIM_SIZE:nn.FIRST_DIM_SIZE,VALUE_ROWIDS:nn.VALUE_ROWIDS,ROW_LENGTHS:nn.ROW_LENGTHS,ROW_SPLITS:nn.ROW_SPLITS,ROW_LIMITS:nn.ROW_LIMITS,ROW_STARTS:nn.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function ln(e){return 0===e.length?0:e[0]===nn.FIRST_DIM_SIZE?e.length-1:e.length}function un(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(nn||(nn={}));const cn=30;function dn(e){return e<=cn?e:(0,R.lK)(e,Math.floor(Math.sqrt(e)))}function hn(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function pn(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function fn(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function mn(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function gn(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function bn(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var yn=n(3130);const wn=.3275911,vn=.254829592,xn=-.284496736,_n=1.421413741,kn=-1.453152027,Sn=1.061405429;var Tn=n(8391);function In(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function En(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function An(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Cn(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Nn(e,t){return{real:e[2*t],imag:e[2*t+1]}}function $n(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function On(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Dn(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Fn="->",Rn=/->/g,Mn=",",Ln="...";function Pn(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Rn,"").length)/Fn.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Fn}").`);const[r,s]=e.split(Fn);(0,R.vA)(-1===r.indexOf(Ln),(()=>`The ellipsis notation ("${Ln}") is not supported yet.`));const a=r.split(Mn),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let e=0;e<s.length;++e){const t=s[e];if(!a.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===o.indexOf(t)&&t!==Mn&&o.push(t)}const l=new Array(a.length);for(let e=0;e<i;++e){if(new Set(a[e].split("")).size!==a[e].length)throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<a[e].length;++t)l[e].push(o.indexOf(a[e][t]))}const u=o.length,c=[];for(let e=s.length;e<u;++e)c.push(e);return{allDims:o,summedDims:c,idDims:l}}function zn(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Bn(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const s=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=s[n]:(0,R.vA)(r[t[e][n]]===s[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`))}}function Vn(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let e=0;e<s;++e)r.push([]);const a=[];for(let e=0;e<n.length;++e){const s=jn(t,n[e]);for(const t of s)-1===a.indexOf(t)&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function Un(e){return e.every(((e,t)=>e===t))}function jn(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Wn(e,t,n=0){let r=[];if("number"==typeof t)(0,R.vA)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,R.vA)(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}(0,R.vA)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Gn(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Hn(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function qn(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Zn(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Kn(e,t){return`size ${e} must be non-negative, not ${t}`}function Yn(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Xn(e,t){return`Input to reshape is a SparseTensor with ${(0,R.Ze)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,R.Ze)(t)}. inputShape=${e} outputShape= ${t}`}function Qn(e,t){return`Input to reshape is a tensor with ${(0,R.Ze)(e)} dense values, but the requested shape has ${(0,R.Ze)(t)}. inputShape=${e} outputShape=${t}`}function Jn(){return"segment ids must be >= 0"}function er(){return"segment ids are not increasing"}function tr(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function nr(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function rr(e,t){let n,r=!1;for(e<=cn?(n=e,r=!0):n=(0,R.lK)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=(0,R.lK)(e,n+1);return n}function sr(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function ar(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function ir(e){try{return e.map((e=>(0,Nt.decodeString)(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function or(e){return e.map((e=>(0,Nt.encodeString)(e)))}var lr=n(7169),ur=n(197),cr=n(5791);!function(){for(const e of Be)Te(e)}()},7508:(e,t,n)=>{"use strict";n.d(t,{D:()=>s});var r=n(7343);class s{static join(e){return new s(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>r.isTypedArray(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],i=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,i,l-i);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}},5270:(e,t,n)=>{"use strict";n.d(t,{AQ:()=>k,CY:()=>h,Ej:()=>E,P8:()=>S,Rl:()=>I,Xf:()=>C,aG:()=>d,jf:()=>_,l3:()=>x,oR:()=>A,s5:()=>b,zV:()=>T});var r=n(1030),s=n(4233),a=n(6689),i=n(755),o=n(7508),l=n(4917),u=n(3772);const c=4;async function d(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+c*t.length,r=new Uint8Array(n);let s=0;for(let e=0;e<t.length;e++){const n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,s),s+=c,r.set(n,s),s+=n.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:y(await Promise.all(r)),specs:n}}function h(e,t){const n=new o.D(e),r={};let s=0;for(const e of t){const t=p(e,((e,t)=>n.slice(s+e,s+t)));r[e.name]=m(e,n.slice(s,s+t)),s+=t}return r}function p(e,t){const n=(0,a.Ze)(e.shape);let r;if("quantization"in e){const t=e.quantization;r=i.i[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=c+new Uint32Array(t(e,e+c))[0];return e}r=i.i[e.dtype]}return n*r}async function f(e,t){const n=(0,a.Ze)(e.shape);let r;if("quantization"in e){const t=e.quantization;r=i.i[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=c+new Uint32Array(await t(e,e+c))[0];return e}r=i.i[e.dtype]}return n*r}function m(e,t){const n=e.name,o=e.dtype,l=e.shape,u=(0,a.Ze)(l);let d,h=0;if("quantization"in e){const r=e.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error(`Weight ${e.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==r.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${e.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${o}.`)}const s=i.i[r.dtype],a="uint8"===r.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===o)if("uint8"===r.dtype||"uint16"===r.dtype){d=new Float32Array(a.length);for(let e=0;e<a.length;e++){const t=a[e];d[e]=t*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let s=0;s<r.length;s++){const i=r[s],o=e[n[i>>10]+(1023&i)]+t[i>>10];a[s]=o}return new Float32Array(s)}}();d=e(a)}}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${n}': ${o}`);if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);d=new Int32Array(a.length);for(let e=0;e<a.length;e++){const t=a[e];d[e]=Math.round(t*r.scale+r.min)}}h+=u*s}else if("string"===o){const n=(0,a.Ze)(e.shape);d=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(h,h+c))[0];h+=c;const n=new Uint8Array(t.slice(h,h+e));d.push(n),h+=e}}else{const e=i.i[o];if("float32"===o)d=new Float32Array(t);else if("int32"===o)d=new Int32Array(t);else{if("bool"!==o){if("complex64"===o){d=new Float32Array(t);const e=new Float32Array(d.length/2),n=new Float32Array(d.length/2);for(let t=0;t<e.length;t++)e[t]=d[2*t],n[t]=d[2*t+1];const a=(0,s.O)(e,l,"float32"),i=(0,s.O)(n,l,"float32"),o=(0,r.f)(a,i);return a.dispose(),i.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${o}`)}d=new Uint8Array(t)}h+=u*e}return(0,s.O)(d,l,o)}async function g(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function b(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const e of t){const t=await f(e,(async(e,t)=>(s=await g(r,s,t),s.slice(e,t))));s=await g(r,s,t);const i=s.slice(0,t);s=s.slice(t);const o=m(e,i);if(n[e.name]=o,"webgpu"===(0,l.jz)()){const e=(0,l.Hs)();"uploadToGPU"in e&&(0,a.Ze)(o.shape)>=(0,u._K)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(o.dataId)}}return n}function y(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const w="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function v(e){return w?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function x(e){if(w)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}function _(e){if(w){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}function k(e){return o.D.join(e)}function S(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function T(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function I(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function E(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),I(e,n,r)}function A(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:v(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:v(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new o.D(e.weightData).byteLength}}function C(e){const t=[];for(const n of e)t.push(...n.weights);return t}},755:(e,t,n)=>{"use strict";n.d(t,{i:()=>r});const r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},2787:(e,t,n)=>{"use strict";n.d(t,{$dB:()=>O,$jE:()=>nn,$zE:()=>$,A1h:()=>M,A8B:()=>Ut,BK4:()=>yn,BLA:()=>Xe,BRl:()=>ae,Blb:()=>jt,BoJ:()=>Ht,BxF:()=>de,C8s:()=>Gt,CQC:()=>ft,Cg$:()=>Ne,CwD:()=>Ee,D7i:()=>It,Ddj:()=>Yt,Dr:()=>wn,DvZ:()=>Zt,E3$:()=>ke,EkD:()=>o,ElG:()=>pe,EwU:()=>dn,FAs:()=>on,FCQ:()=>St,FSt:()=>u,Fin:()=>zt,GZp:()=>Qt,HNs:()=>S,Ik2:()=>_,J3C:()=>Mt,JiE:()=>Ft,Jp_:()=>c,KXH:()=>E,L6G:()=>qt,LB5:()=>T,LDN:()=>Ve,LG0:()=>Ke,LRy:()=>bt,LWX:()=>at,LXA:()=>De,M6A:()=>Xt,MRQ:()=>j,Mn0:()=>z,MnK:()=>B,N4F:()=>k,Ncv:()=>dt,O4G:()=>ge,OAQ:()=>ve,ODT:()=>lt,OMN:()=>i,ORI:()=>K,PH8:()=>a,P_L:()=>Tt,Pah:()=>ne,PbM:()=>rn,Q6t:()=>gt,QDP:()=>A,QKF:()=>h,Qgm:()=>te,R23:()=>vt,RMm:()=>fn,RUm:()=>$e,RW8:()=>Fe,RXX:()=>je,SDM:()=>nt,SQl:()=>ce,T7M:()=>xn,TBb:()=>ln,TL8:()=>He,TMz:()=>G,TOR:()=>At,ToN:()=>Pe,TyE:()=>f,UcO:()=>Jt,VAI:()=>Be,VCH:()=>y,Vvy:()=>s,WRv:()=>ze,WT3:()=>Qe,WuN:()=>Vt,X$8:()=>q,X0$:()=>Te,X4r:()=>Nt,XQy:()=>_t,XhZ:()=>be,XmO:()=>J,YAb:()=>en,YVe:()=>Lt,ZgB:()=>he,Zl4:()=>rt,_s9:()=>se,aAr:()=>vn,awo:()=>bn,bCz:()=>ut,bP9:()=>X,cHb:()=>Ge,cS:()=>w,dFH:()=>Bt,dLy:()=>un,dXR:()=>hn,dv8:()=>xe,e0f:()=>st,epO:()=>p,fUj:()=>wt,g5A:()=>qe,gC7:()=>P,gIW:()=>_e,hVg:()=>Et,hgw:()=>kt,ho8:()=>b,hql:()=>Rt,huO:()=>yt,i5R:()=>fe,iGz:()=>L,iPs:()=>Se,iW0:()=>tn,iuW:()=>an,jAQ:()=>x,jM4:()=>Le,jOE:()=>xt,jfg:()=>R,jgd:()=>Kt,jj_:()=>V,jxD:()=>Y,kdj:()=>ht,l0G:()=>et,l6P:()=>Ot,lLS:()=>ye,lNG:()=>Ze,ljI:()=>r,lxb:()=>g,lzr:()=>we,mH5:()=>mt,mIA:()=>Ie,mM$:()=>ot,mnI:()=>Ae,mxL:()=>me,nVu:()=>Z,nY8:()=>U,nZd:()=>Oe,oFs:()=>sn,oJ2:()=>pt,ox3:()=>ie,p2J:()=>D,pJc:()=>Ct,pPe:()=>pn,p_m:()=>d,pk0:()=>Q,pnw:()=>gn,pr3:()=>N,pyJ:()=>ct,rFG:()=>Wt,rFm:()=>F,rGP:()=>ue,rsH:()=>re,sDr:()=>ee,t3d:()=>Ue,tG8:()=>Ce,tGH:()=>H,u$b:()=>Dt,u8Z:()=>l,uWl:()=>$t,urI:()=>it,vI1:()=>Pt,vaV:()=>C,vj7:()=>I,wNW:()=>W,wwC:()=>v,wx0:()=>cn,x7F:()=>Ye,xJ3:()=>mn,xu7:()=>Je,yPW:()=>Me,ySp:()=>We,ybN:()=>oe,ybj:()=>le,ylV:()=>tt,zP9:()=>m,zfU:()=>Re});const r="Abs",s="Acos",a="Acosh",i="Add",o="AddN",l="All",u="Any",c="ArgMax",d="ArgMin",h="Asin",p="Asinh",f="Atan",m="Atanh",g="Atan2",b="AvgPool",y="AvgPoolGrad",w="AvgPool3D",v="AvgPool3DGrad",x="BatchMatMul",_="BatchToSpaceND",k="Bincount",S="BitwiseAnd",T="BroadcastTo",I="BroadcastArgs",E="Cast",A="Ceil",C="ClipByValue",N="Complex",$="ComplexAbs",O="Concat",D="Conv2D",F="Conv2DBackpropFilter",R="Conv2DBackpropInput",M="Conv3D",L="Conv3DBackpropFilterV2",P="Conv3DBackpropInputV2",z="Cos",B="Cosh",V="Cumprod",U="Cumsum",j="CropAndResize",W="DenseBincount",G="DepthToSpace",H="DepthwiseConv2dNative",q="DepthwiseConv2dNativeBackpropFilter",Z="DepthwiseConv2dNativeBackpropInput",K="Diag",Y="Dilation2D",X="Dilation2DBackpropInput",Q="Dilation2DBackpropFilter",J="Draw",ee="RealDiv",te="Einsum",ne="Elu",re="EluGrad",se="Erf",ae="Equal",ie="Exp",oe="ExpandDims",le="Expm1",ue="FFT",ce="Fill",de="FlipLeftRight",he="Floor",pe="FloorDiv",fe="FusedBatchNorm",me="GatherV2",ge="GatherNd",be="Greater",ye="GreaterEqual",we="Identity",ve="IFFT",xe="Imag",_e="IsFinite",ke="IsInf",Se="IsNan",Te="LeakyRelu",Ie="Less",Ee="LessEqual",Ae="LinSpace",Ce="Log",Ne="Log1p",$e="LogicalAnd",Oe="LogicalNot",De="LogicalOr",Fe="LogicalXor",Re="LogSoftmax",Me="LowerBound",Le="LRN",Pe="LRNGrad",ze="MatrixBandPart",Be="Max",Ve="Maximum",Ue="MaxPool",je="MaxPoolGrad",We="MaxPool3D",Ge="MaxPool3DGrad",He="MaxPoolWithArgmax",qe="Mean",Ze="Min",Ke="Minimum",Ye="MirrorPad",Xe="Mod",Qe="Multinomial",Je="Multiply",et="Neg",tt="NotEqual",nt="NonMaxSuppressionV3",rt="NonMaxSuppressionV4",st="NonMaxSuppressionV5",at="OnesLike",it="OneHot",ot="Pack",lt="PadV2",ut="Pool",ct="Pow",dt="Prelu",ht="Prod",pt="RaggedGather",ft="RaggedRange",mt="RaggedTensorToTensor",gt="Range",bt="Real",yt="Reciprocal",wt="Relu",vt="Reshape",xt="ResizeNearestNeighbor",_t="ResizeNearestNeighborGrad",kt="ResizeBilinear",St="ResizeBilinearGrad",Tt="Relu6",It="Reverse",Et="Round",At="Rsqrt",Ct="ScatterNd",Nt="TensorScatterUpdate",$t="SearchSorted",Ot="Select",Dt="Selu",Ft="Slice",Rt="Sin",Mt="Sinh",Lt="Sign",Pt="Sigmoid",zt="Softplus",Bt="Sqrt",Vt="Sum",Ut="SpaceToBatchND",jt="SplitV",Wt="Softmax",Gt="SparseFillEmptyRows",Ht="SparseReshape",qt="SparseSegmentMean",Zt="SparseSegmentSum",Kt="SparseToDense",Yt="SquaredDifference",Xt="Square",Qt="StaticRegexReplace",Jt="StridedSlice",en="StringNGrams",tn="StringSplit",nn="StringToHashBucketFast",rn="Sub",sn="Tan",an="Tanh",on="Tile",ln="TopK",un="Transform",cn="Transpose",dn="Unique",hn="Unpack",pn="UnsortedSegmentSum",fn="UpperBound",mn="ZerosLike",gn="Step",bn="FromPixels",yn="RotateWithOffset",wn="_FusedMatMul",vn="FusedConv2D",xn="FusedDepthwiseConv2D"},1112:(e,t,n)=>{"use strict";n.d(t,{Cf:()=>m,Op:()=>c,_5:()=>l,iP:()=>p,kr:()=>h,rY:()=>f,tA:()=>d,vQ:()=>u});var r=n(3772),s=n(9245),a=n(8391);const i=(0,s.m)("kernelRegistry",(()=>new Map)),o=(0,s.m)("gradRegistry",(()=>new Map));function l(e,t){const n=g(e,t);return i.get(n)}function u(e){return o.get(e)}function c(e){const t=i.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function d(e){const{kernelName:t,backendName:n}=e,r=g(t,n);i.has(r)&&a.i(`The kernel '${t}' for backend '${n}' is already registered`),i.set(r,e)}function h(e){const{kernelName:t}=e;o.has(t)&&(0,r._K)().getBool("DEBUG")&&a.i(`Overriding the gradient for '${t}'`),o.set(t,e)}function p(e,t){const n=g(e,t);if(!i.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);i.delete(n)}function f(e){if(!o.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);o.delete(e)}function m(e,t){c(e).forEach((e=>{d(Object.assign({},e,{backendName:t}))}))}function g(e,t){return`${t}_${e}`}},8391:(e,t,n)=>{"use strict";n.d(t,{R:()=>a,i:()=>s});var r=n(3772);function s(...e){(0,r._K)().getBool("IS_TEST")||(0,r._K)().getBool("PROD")||console.warn(...e)}function a(...e){(0,r._K)().getBool("IS_TEST")||(0,r._K)().getBool("PROD")||console.log(...e)}},6762:(e,t,n)=>{"use strict";n.d(t,{t:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({abs_:function(e){const t=(0,a.YT)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return r.T2.runKernel(s.$zE,e)}{const e={x:t};return r.T2.runKernel(s.ljI,e)}}})},4702:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({acos_:function(e){const t={x:(0,a.YT)(e,"x","acos")};return r.T2.runKernel(s.Vvy,t)}})},3876:(e,t,n)=>{"use strict";n.d(t,{F:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({acosh_:function(e){const t={x:(0,a.YT)(e,"x","acosh")};return r.T2.runKernel(s.PH8,t)}})},9389:(e,t,n)=>{"use strict";n.d(t,{W:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({add_:function(e,t){let n=(0,i.YT)(e,"a","add"),o=(0,i.YT)(t,"b","add");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.OMN,l)}})},6733:(e,t,n)=>{"use strict";n.d(t,{Q:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({all_:function(e,t=null,n=!1){const i={x:(0,a.YT)(e,"x","all","bool")},o={axis:t,keepDims:n};return r.T2.runKernel(s.u8Z,i,o)}})},3047:(e,t,n)=>{"use strict";n.d(t,{b:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({any_:function(e,t=null,n=!1){const i={x:(0,a.YT)(e,"x","any","bool")},o={axis:t,keepDims:n};return r.T2.runKernel(s.FSt,i,o)}})},5455:(e,t,n)=>{"use strict";n.d(t,{F:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({argMax_:function(e,t=0){const n={x:(0,a.YT)(e,"x","argMax")},i={axis:t};return r.T2.runKernel(s.Jp_,n,i)}})},2421:(e,t,n)=>{"use strict";n.d(t,{X:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({argMin_:function(e,t=0){const n={x:(0,a.YT)(e,"x","argMin")},i={axis:t};return r.T2.runKernel(s.p_m,n,i)}})},8807:(e,t,n)=>{"use strict";n.d(t,{q:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({asin_:function(e){const t={x:(0,a.YT)(e,"x","asin")};return r.T2.runKernel(s.QKF,t)}})},2615:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({asinh_:function(e){const t={x:(0,a.YT)(e,"x","asinh")};return r.T2.runKernel(s.epO,t)}})},2774:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({atan_:function(e){const t={x:(0,a.YT)(e,"x","atan")};return r.T2.runKernel(s.TyE,t)}})},9374:(e,t,n)=>{"use strict";n.d(t,{F:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({atan2_:function(e,t){let n=(0,i.YT)(e,"a","atan2"),o=(0,i.YT)(t,"b","atan2");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.lxb,l)}})},7004:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({atanh_:function(e){const t={x:(0,a.YT)(e,"x","atanh")};return r.T2.runKernel(s.zP9,t)}})},9303:(e,t,n)=>{"use strict";n.d(t,{$:()=>d});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(3583),l=n(8785),u=n(779),c=n(6584);const d=(0,u.op)({avgPool_:function(e,t,n,u,d){const h=(0,a.YT)(e,"x","avgPool","float32");i.vA(l.G0(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let p=h,f=!1;3===h.rank&&(f=!0,p=(0,c.t)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),i.vA(4===p.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${p.rank}.`)),l.s_("avgPool",u,d);const m={x:p},g={filterSize:t,strides:n,pad:u,dimRoundingMode:d};let b=r.T2.runKernel(s.ho8,m,g);return b=(0,o.w)(b,h.dtype),f?(0,c.t)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},4640:(e,t,n)=>{"use strict";n.d(t,{Em:()=>u,SM:()=>o,WC:()=>l,WH:()=>s,aF:()=>a,fK:()=>d,gx:()=>c,lb:()=>i});var r=n(6689);function s(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function a(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function i(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function o(e,t){return a(e,t.map((e=>1)),t)}function l(e,t,n){r.vA(s(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function u(e,t){if(s(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function c(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function d(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}},610:(e,t,n)=>{"use strict";n.d(t,{G:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({batchToSpaceND_:function(e,t,n){const o=(0,a.YT)(e,"x","batchToSpaceND"),l=t.reduce(((e,t)=>e*t));i.vA(o.rank>=1+t.length,(()=>`input rank is ${o.rank} but should be > than blockShape.length ${t.length}`)),i.vA(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),i.vA(o.shape[0]%l==0,(()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${l}`));const u={x:o},c={blockShape:t,crops:n};return r.T2.runKernel(s.Ik2,u,c)}})},6363:(e,t,n)=>{"use strict";n.d(t,{$:()=>l});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(6584);const l=(0,n(779).op)({batchNorm_:function(e,t,n,l,u,c){null==c&&(c=.001);const d=(0,a.YT)(e,"x","batchNorm"),h=(0,a.YT)(t,"mean","batchNorm"),p=(0,a.YT)(n,"variance","batchNorm");let f,m;null!=u&&(f=(0,a.YT)(u,"scale","batchNorm")),null!=l&&(m=(0,a.YT)(l,"offset","batchNorm")),i.vA(h.rank===p.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),i.vA(null==m||h.rank===m.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),i.vA(null==f||h.rank===f.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const g={x:function(e){let t;return t=0===e.rank||1===e.rank?(0,o.t)(e,[1,1,1,e.size]):2===e.rank?(0,o.t)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,o.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(d),scale:f,offset:m,mean:h,variance:p},b={varianceEpsilon:c},y=r.T2.runKernel(s.i5R,g,b);return(0,o.t)(y,d.shape)}})},209:(e,t,n)=>{"use strict";n.d(t,{h:()=>c});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(99),l=n(779),u=n(6584);const c=(0,l.op)({broadcastTo_:function(e,t){let n=(0,a.YT)(e,"broadcastTo","x");const l=n.shape;if((0,i.SA)(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=(0,u.t)(n,e)}const c=n.shape,d=Array.from(t);for(let e=t.length-1;e>=0;e--)if(c[e]===t[e])d[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${l}] cannot be broadcast to [${t}].`);if(0===d.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return(0,o.o)(n);const h={x:n},p={reps:d};return r.T2.runKernel(s.FAs,h,p)}})},548:(e,t,n)=>{"use strict";function r(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function s(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function a(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-s-1]=a}}return r}n.r(t),n.d(t,{assertAndGetBroadcastShape:()=>a,getBroadcastDims:()=>r,getReductionAxes:()=>s})},1950:(e,t,n)=>{"use strict";n.d(t,{r:()=>a});var r=n(1794),s=n(6689);function a(e,t="float32",n){return t=t||"float32",s.SA(e),new r.yl(e,t,n)}},3583:(e,t,n)=>{"use strict";n.d(t,{w:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({cast_:function(e,t){const n=(0,a.YT)(e,"x","cast");if(!i.xn(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const o={x:n},l={dtype:t};return r.T2.runKernel(s.KXH,o,l)}})},8665:(e,t,n)=>{"use strict";n.d(t,{m:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({ceil_:function(e){const t={x:(0,a.YT)(e,"x","ceil","float32")};return r.T2.runKernel(s.QDP,t)}})},3406:(e,t,n)=>{"use strict";n.d(t,{z:()=>l});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(6673);const l=(0,n(779).op)({clipByValue_:function(e,t,n){const l=(0,a.YT)(e,"x","clipByValue");if(i.vA(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return(0,o.G)(l.shape,t,l.dtype);const u={x:l},c={clipValueMin:t,clipValueMax:n};return r.T2.runKernel(s.vaV,u,c)}})},99:(e,t,n)=>{"use strict";n.d(t,{o:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({clone_:function(e){const t={x:(0,a.YT)(e,"x","clone","string_or_numeric")};return r.T2.runKernel(s.lzr,t)}})},1030:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({complex_:function(e,t){const n=(0,a.YT)(e,"real","complex"),o=(0,a.YT)(t,"imag","complex");i.O3(n.shape,o.shape,`real and imag shapes, ${n.shape} and ${o.shape}, must match in call to tf.complex().`);const l={real:n,imag:o};return r.T2.runKernel(s.pr3,l)}})},4636:(e,t,n)=>{"use strict";n.d(t,{x:()=>l});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(99);const l=(0,n(779).op)({concat_:function(e,t=0){(0,i.vA)(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=(0,a.j1)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return(0,o.o)(n[0]);const l=n,u={axis:t};return r.T2.runKernel(s.$dB,l,u)}})},4347:(e,t,n)=>{"use strict";n.d(t,{k:()=>u});var r=n(7243),s=n(6689),a=n(4300),i=n(8785),o=n(779),l=n(6584);const u=(0,o.op)({conv1d_:function(e,t,n,o,u="NWC",c=1,d){const h=(0,r.YT)(e,"x","conv1d"),p=(0,r.YT)(t,"filter","conv1d");let f=h,m=!1;2===h.rank&&(m=!0,f=(0,l.t)(h,[1,h.shape[0],h.shape[1]])),s.vA(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),s.vA(3===p.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`)),i.s_("conv1d",o,d),s.vA(f.shape[2]===p.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${p.shape[1]}.`)),s.vA(i.G0(n,c),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${c}'`)),s.vA(i.qk(c),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),s.vA(i.qk(n),(()=>"Error in conv1D: Stride should be larger than 0.")),s.vA("NWC"===u,(()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`));const g=(0,l.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),b=(0,l.t)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),y=[1,n],w=[1,c],v=(0,a.X)(b,g,y,o,"NHWC",w,d);return m?(0,l.t)(v,[v.shape[2],v.shape[3]]):(0,l.t)(v,[v.shape[0],v.shape[2],v.shape[3]])}})},4300:(e,t,n)=>{"use strict";n.d(t,{X:()=>c});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(8785),l=n(779),u=n(6584);const c=(0,l.op)({conv2d_:function(e,t,n,l,c="NHWC",d=[1,1],h){const p=(0,a.YT)(e,"x","conv2d","float32"),f=(0,a.YT)(t,"filter","conv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,u.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),i.vA(4===m.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`)),i.vA(4===f.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`)),o.s_("conv2d",l,h);const b="NHWC"===c?m.shape[3]:m.shape[1];i.vA(b===f.shape[2],(()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${f.shape[2]}.`)),i.vA(o.G0(n,d),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${d}'`)),i.vA(o.qk(d),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),i.vA(o.qk(n),(()=>"Error in conv2D: Strides should be larger than 0."));const y={x:m,filter:f},w={strides:n,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h},v=r.T2.runKernel(s.p2J,y,w);return g?(0,u.t)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},4958:(e,t,n)=>{"use strict";n.d(t,{H:()=>u});var r=n(9936),s=n(2787),a=n(6689),i=n(8785),o=n(779),l=n(6584);const u=(0,o.op)({conv2DBackpropFilter_:function(e,t,n,o,u,c="NHWC",d){let h=e;3===e.rank&&(h=(0,l.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let p=t;3===p.rank&&(p=(0,l.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),a.vA(4===h.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`)),a.vA(4===p.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${p.shape}.`)),a.vA(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const f="NHWC"===c?h.shape[3]:h.shape[1],m="NHWC"===c?p.shape[3]:p.shape[1];a.vA(f===n[2],(()=>`Error in conv2dDerFilter: depth of input ${f}) must match input depth in filter (${n[2]}.`)),a.vA(m===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${n[3]}).`)),i.s_("conv2dDerFilter",u,d);const g={x:h,dy:p},b={strides:o,pad:u,dataFormat:c,dimRoundingMode:d,filterShape:n};return r.T2.runKernel(s.rFm,g,b)}})},4314:(e,t,n)=>{"use strict";n.d(t,{v:()=>u});var r=n(9936),s=n(2787),a=n(6689),i=n(8785),o=n(779),l=n(6584);const u=(0,o.op)({conv2DBackpropInput_:function(e,t,n,o,u,c="NHWC",d){a.vA(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let h=e,p=t,f=!1;3===t.rank&&(f=!0,p=(0,l.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,e[0],e[1],e[2]]),a.vA(4===h.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`)),a.vA(4===p.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${p.rank}`)),a.vA(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const m="NHWC"===c?h[3]:h[1],g="NHWC"===c?p.shape[3]:p.shape[1];a.vA(m===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${n.shape[2]}.`)),a.vA(g===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${n.shape[3]}.`)),i.s_("conv2dDerInput",u,d);const b={dy:p,filter:n},y={strides:o,pad:u,dataFormat:c,dimRoundingMode:d,inputShape:h},w=r.T2.runKernel(s.jfg,b,y);return f?(0,l.t)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},5380:(e,t,n)=>{"use strict";n.d(t,{w:()=>a});var r=n(7243),s=n(4314);const a=(0,n(779).op)({conv2dTranspose_:function(e,t,n,a,i,o){const l=(0,r.YT)(e,"x","conv2dTranspose"),u=(0,r.YT)(t,"filter","conv2dTranspose");return(0,s.v)(n,l,u,a,i,"NHWC",o)}})},8413:(e,t,n)=>{"use strict";n.d(t,{c:()=>l});var r=n(9936),s=n(2787),a=n(6689),i=n(779),o=n(6584);const l=(0,i.op)({conv3DBackpropInput_:function(e,t,n,i,l){a.vA(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let u=e,c=t,d=!1;4===t.rank&&(d=!0,c=(0,o.t)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),u=[1,e[0],e[1],e[2],e[3]]);const h=u[4],p=c.shape[4];a.vA(5===u.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`)),a.vA(5===c.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${c.rank}`)),a.vA(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),a.vA(h===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[3]}.`)),a.vA(p===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`));const f={dy:c,filter:n},m={pad:l,strides:i,inputShape:u},g=r.T2.runKernel(s.gC7,f,m);return d?(0,o.t)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}})},8785:(e,t,n)=>{"use strict";n.d(t,{$Q:()=>b,Dh:()=>f,E6:()=>a,G0:()=>m,G8:()=>u,YQ:()=>s,l5:()=>i,p$:()=>l,qk:()=>g,s_:()=>y,uf:()=>o});var r=n(6689);function s(e,t,n,r,s="NHWC",a){return o(e,[...t,e[3]],n,a,r,null,null,b(s))}function a(e,t,n,r,s,a,i="channelsLast"){const[l,u]=c(t);let d;if("channelsLast"===i)d=[l,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);d=[l,u,e[1],e[1]]}return o(e,d,n,r,s,a,!1,i)}function i(e,t,n,r,s,a,i="NDHWC"){const[o,u,c]=d(t);let h,p;if("NDHWC"===i)p="channelsLast",h=[o,u,c,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);p="channelsFirst",h=[o,u,c,e[1],e[1]]}return l(e,h,n,r,s,!1,p,a)}function o(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,d,f,m]=[-1,-1,-1,-1];if("channelsLast"===o)[l,d,f,m]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,m,d,f]=e}const[g,b,,y]=t,[w,v]=c(n),[x,_]=c(r),k=h(g,x),S=h(b,_),{padInfo:T,outHeight:I,outWidth:E}=function(e,t,n,r,s,a,i,o,l){let c,d,h;if("number"==typeof e){c={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=u(e,t,n));const a=e[1];return[p((e[0]-t+2*r)/n+1,s),p((a-t+2*r)/n+1,s)]}([t,n],a,r,e,o);d=s[0],h=s[1]}else if("same"===e){d=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(d-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),l=Math.floor(e/2),u=e-l,p=Math.floor(o/2);c={top:l,bottom:u,left:p,right:o-p,type:"SAME"}}else if("valid"===e)c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const u="channelsLast"===l?e[1][0]:e[2][0],f="channelsLast"===l?e[1][1]:e[2][1],m="channelsLast"===l?e[2][0]:e[3][0],g="channelsLast"===l?e[2][1]:e[3][1];c={top:u,bottom:f,left:m,right:g,type:0===u&&0===f&&0===m&&0===g?"VALID":"EXPLICIT"},d=p((t-a+u+f)/r+1,o),h=p((n-i+m+g)/s+1,o)}}return{padInfo:c,outHeight:d,outWidth:h}}(s,d,f,w,v,k,S,a,o),A=i?y*m:y;let C;return"channelsFirst"===o?C=[l,A,I,E]:"channelsLast"===o&&(C=[l,I,E,A]),{batchSize:l,dataFormat:o,inHeight:d,inWidth:f,inChannels:m,outHeight:I,outWidth:E,outChannels:A,padInfo:T,strideHeight:w,strideWidth:v,filterHeight:g,filterWidth:b,effectiveFilterHeight:k,effectiveFilterWidth:S,dilationHeight:x,dilationWidth:_,inShape:e,outShape:C,filterShape:t}}function l(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,c,f,m,g]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,c,f,m,g]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,g,c,f,m]=e}const[b,y,w,,v]=t,[x,_,k]=d(n),[S,T,I]=d(r),E=h(b,S),A=h(y,T),C=h(w,I),{padInfo:N,outDepth:$,outHeight:O,outWidth:D}=function(e,t,n,r,s,a,i,o,l,c,d){let h,f,m,g;if("valid"===e&&(e=0),"number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const b=function(e,t,n,r,s,a){null==s&&(s=u(e,t[0],r[0]));const i=[0,0,0,1];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=p((e[n]-t[n]+2*s)/r[n]+1,a));return i}([t,n,r,1],[o,l,c],0,[s,a,i],e,d);f=b[0],m=b[1],g=b[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{f=Math.ceil(t/s),m=Math.ceil(n/a),g=Math.ceil(r/i);const e=(f-1)*s+o-t,u=(m-1)*a+l-n,d=(g-1)*i+c-r,p=Math.floor(e/2),b=e-p,y=Math.floor(u/2),w=u-y,v=Math.floor(d/2);h={top:y,bottom:w,left:v,right:d-v,front:p,back:b,type:"SAME"}}}return{padInfo:h,outDepth:f,outHeight:m,outWidth:g}}(s,c,f,m,x,_,k,E,A,C,o),F=a?v*g:v;let R;return"channelsFirst"===i?R=[l,F,$,O,D]:"channelsLast"===i&&(R=[l,$,O,D,F]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:f,inWidth:m,inChannels:g,outDepth:$,outHeight:O,outWidth:D,outChannels:F,padInfo:N,strideDepth:x,strideHeight:_,strideWidth:k,filterDepth:b,filterHeight:y,filterWidth:w,effectiveFilterDepth:E,effectiveFilterHeight:A,effectiveFilterWidth:C,dilationDepth:S,dilationHeight:T,dilationWidth:I,inShape:e,outShape:R,filterShape:t}}function u(e,t,n,r=1){const s=h(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function c(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function d(e){return"number"==typeof e?[e,e,e]:e}function h(e,t){return t<=1?e:e+(e-1)*(t-1)}function p(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function f(e){const[t,n,r]=c(e);return 1===t&&1===n&&1===r}function m(e,t){return f(e)||f(t)}function g(e){return c(e).every((e=>e>0))}function b(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function y(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)r.vA(r.E6(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{r.vA(r.E6(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}},579:(e,t,n)=>{"use strict";n.d(t,{g:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({cos_:function(e){const t={x:(0,a.YT)(e,"x","cos","float32")};return r.T2.runKernel(s.Mn0,t)}})},765:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({cosh_:function(e){const t={x:(0,a.YT)(e,"x","cosh","float32")};return r.T2.runKernel(s.MnK,t)}})},2268:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({cumprod_:function(e,t=0,n=!1,i=!1){const o={x:(0,a.YT)(e,"x","cumprod")},l={axis:t,exclusive:n,reverse:i};return r.T2.runKernel(s.jj_,o,l)}})},8062:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({cumsum_:function(e,t=0,n=!1,i=!1){const o={x:(0,a.YT)(e,"x","cumsum")},l={axis:t,exclusive:n,reverse:i};return r.T2.runKernel(s.nY8,o,l)}})},3682:(e,t,n)=>{"use strict";n.d(t,{R:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({depthToSpace_:function(e,t,n="NHWC"){const o=(0,a.YT)(e,"x","depthToSpace","float32"),l="NHWC"===n?o.shape[1]:o.shape[2],u="NHWC"===n?o.shape[2]:o.shape[3],c="NHWC"===n?o.shape[3]:o.shape[1];i.vA(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),i.vA(l*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${l} and ${t}  for depthToSpace with input shape\n    ${o.shape}`)),i.vA(u*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${t} for depthToSpace with input shape\n        ${o.shape}`)),i.vA(c%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${c} for depthToSpace with input shape ${o.shape}`));const d={x:o},h={blockSize:t,dataFormat:n};return r.T2.runKernel(s.TMz,d,h)}})},1490:(e,t,n)=>{"use strict";n.d(t,{G:()=>c});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(8785),l=n(779),u=n(6584);const c=(0,l.op)({depthwiseConv2d_:function(e,t,n,l,c="NHWC",d=[1,1],h){const p=(0,a.YT)(e,"x","depthwiseConv2d","float32"),f=(0,a.YT)(t,"filter","depthwiseConv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,u.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),i.vA(4===m.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),i.vA(4===f.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`));const b="NHWC"===c?m.shape[3]:m.shape[1];i.vA(b===f.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${b}) must match the inChannels dimension in filter ${f.shape[2]}.`)),o.s_("depthwiseConv2d",l,h);const y={x:m,filter:f},w={strides:n,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h},v=r.T2.runKernel(s.tGH,y,w);return g?(0,u.t)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},1020:(e,t,n)=>{"use strict";n.d(t,{x:()=>o});var r=n(9936),s=n(2787),a=n(779),i=n(6584);const o=(0,a.op)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,o,l=[1,1],u){let c=e;3===e.rank&&(c=(0,i.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let d=t;3===d.rank&&(d=(0,i.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:c,dy:d},p={strides:a,pad:o,dimRoundingMode:u,dilations:l,filterShape:n};return r.T2.runKernel(s.X$8,h,p)}})},2392:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(9936),s=n(2787),a=n(779),i=n(6584);const o=(0,a.op)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,o,l=[1,1],u){let c=t,d=!1;3===t.rank&&(d=!0,c=(0,i.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:c,filter:n},p={strides:a,pad:o,dimRoundingMode:u,dilations:l,inputShape:e},f=r.T2.runKernel(s.nVu,h,p);return d?(0,i.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},7268:(e,t,n)=>{"use strict";n.d(t,{X:()=>u});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(779),l=n(6584);const u=(0,o.op)({dilation2d_:function(e,t,n,o,u=[1,1],c="NHWC"){const d=(0,a.YT)(e,"x","dilation2d"),h=(0,a.YT)(t,"filter","dilation2d");i.vA(3===d.rank||4===d.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${d.rank}.`)),i.vA(3===h.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`)),i.vA("NHWC"===c,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${c}`));let p=d,f=!1;3===d.rank&&(p=(0,l.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),f=!0),i.vA(p.shape[3]===h.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${p.shape[3]} vs ${h.shape[2]}`));const m={x:p,filter:h},g={strides:n,pad:o,dilations:u},b=r.T2.runKernel(s.jxD,m,g);return f?(0,l.t)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},4493:(e,t,n)=>{"use strict";n.d(t,{y:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(905);const l=(0,n(779).op)({div_:function(e,t){let n=(0,i.YT)(e,"a","div"),l=(0,i.YT)(t,"b","div");if([n,l]=(0,a.makeTypesMatch)(n,l),"int32"===n.dtype&&"int32"===l.dtype)return(0,o.w)(n,l);const u={a:n,b:l};return r.T2.runKernel(s.sDr,u,{})}})},8209:(e,t,n)=>{"use strict";n.d(t,{e:()=>c});var r=n(3031),s=n(7243),a=n(4493),i=n(6414),o=n(779),l=n(6073),u=n(7591);const c=(0,o.op)({divNoNan_:function(e,t){let n=(0,s.YT)(e,"a","div"),o=(0,s.YT)(t,"b","div");[n,o]=(0,r.makeTypesMatch)(n,o);const c=(0,a.y)(n,o),d=(0,u.P)(c),h=(0,i.L)(o,d);return(0,l._)(h,d,c)}})},9426:(e,t,n)=>{"use strict";n.d(t,{O:()=>l});var r=n(7243),s=n(6689),a=n(4293),i=n(779),o=n(6584);const l=(0,i.op)({dot_:function(e,t){const n=(0,r.YT)(e,"t1","dot"),i=(0,r.YT)(t,"t2","dot");s.vA(!(1!==n.rank&&2!==n.rank||1!==i.rank&&2!==i.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${i.rank}.`));const l=1===n.rank?n.size:n.shape[1],u=1===i.rank?i.size:i.shape[0];if(s.vA(l===u,(()=>`Error in dot: inner dimensions of inputs must match, but got ${l} and ${u}.`)),1===n.rank&&1===i.rank){const e=(0,o.t)(n,[1,-1]),t=(0,o.t)(i,[-1,1]),r=(0,a.N)(e,t);return(0,o.t)(r,[])}if(1===n.rank&&2===i.rank){const e=(0,o.t)(n,[1,-1]),t=(0,o.t)(i,[i.shape[0],i.shape[1]]),r=(0,a.N)(e,t);return(0,o.t)(r,[r.size])}if(2===n.rank&&1===i.rank){const e=(0,o.t)(i,[-1,1]),t=(0,a.N)(n,e);return(0,o.t)(t,[t.size])}{const e=(0,o.t)(i,[i.shape[0],i.shape[1]]);return(0,a.N)(n,e)}}})},2810:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({elu_:function(e){const t={x:(0,a.YT)(e,"x","elu","float32")};return r.T2.runKernel(s.Pah,t)}})},6414:(e,t,n)=>{"use strict";n.d(t,{L:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({equal_:function(e,t){let n=(0,i.YT)(e,"a","equal","string_or_numeric"),l=(0,i.YT)(t,"b","equal","string_or_numeric");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.BRl,u)}})},9665:(e,t,n)=>{"use strict";n.d(t,{Y:()=>l});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(3583);const l=(0,n(779).op)({erf_:function(e){let t=(0,a.YT)(e,"x","erf");i.vA("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=(0,o.w)(t,"float32"));const n={x:t};return r.T2.runKernel(s._s9,n)}})},983:(e,t,n)=>{"use strict";n.d(t,{p:()=>s});var r=n(9134);const s=(0,n(779).op)({euclideanNorm_:function(e,t=null,n=!1){return(0,r.x)(e,"euclidean",t,n)}})},7145:(e,t,n)=>{"use strict";n.d(t,{o:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({exp_:function(e){const t={x:(0,a.YT)(e,"x","exp")};return r.T2.runKernel(s.ox3,t)}})},3420:(e,t,n)=>{"use strict";n.d(t,{U:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({expandDims_:function(e,t=0){const n=(0,a.YT)(e,"x","expandDims","string_or_numeric");i.vA(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const o={input:n},l={dim:t};return r.T2.runKernel(s.ybN,o,l)}})},8172:(e,t,n)=>{"use strict";n.d(t,{I:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({expm1_:function(e){const t={x:(0,a.YT)(e,"x","expm1")};return r.T2.runKernel(s.ybj,t)}})},6673:(e,t,n)=>{"use strict";n.d(t,{G:()=>i});var r=n(9936),s=n(2787),a=n(6689);function i(e,t,n){(0,a.SA)(e);const i={shape:e,value:t,dtype:n=n||(0,a.X$)(t)};return r.T2.runKernel(s.SQl,{},i)}},7160:(e,t,n)=>{"use strict";n.d(t,{R:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({floor_:function(e){const t={x:(0,a.YT)(e,"x","floor","float32")};return r.T2.runKernel(s.ZgB,t)}})},905:(e,t,n)=>{"use strict";n.d(t,{w:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({floorDiv_:function(e,t){let n=(0,i.YT)(e,"a","floorDiv"),o=(0,i.YT)(t,"b","floorDiv");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.ElG,l)}})},9192:(e,t,n)=>{"use strict";n.d(t,{Do:()=>m,XB:()=>f,f2:()=>g,zE:()=>b});var r=n(548),s=n(2810),a=n(1809),i=n(6596),o=n(5368),l=n(5738),u=n(1958),c=n(6584),d=n(6118),h=n(5366),p=n(7917);function f(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return(0,i.l)(e,(0,h.P)(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function m(e,t){let n=t;const s=r.getReductionAxes(e.shape,t.shape);return s.length>0&&(n=(0,p.c)(n,s)),(0,c.t)(n,e.shape)}function g(e,t,n,r){if("linear"===t)return e;if("relu"===t)return(0,l.V)(e);if("elu"===t)return(0,s.P)(e);if("relu6"===t)return(0,u.j)(e);if("prelu"===t)return(0,o.N)(e,n);if("leakyrelu"===t)return(0,a.H)(e,r);if("sigmoid"===t)return(0,d.r)(e);throw new Error(`Unknown fused activation ${t}.`)}const b=(e,t)=>!(e>0)||"linear"===t},7755:(e,t,n)=>{"use strict";n.d(t,{k:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({gather_:function(e,t,n=0,i=0){const o={x:(0,a.YT)(e,"x","gather"),indices:(0,a.YT)(t,"indices","gather","int32")},l={axis:n,batchDims:i};return r.T2.runKernel(s.mxL,o,l)}})},560:(e,t,n)=>{"use strict";n.d(t,{r:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({greater_:function(e,t){let n=(0,i.YT)(e,"a","greater","string_or_numeric"),l=(0,i.YT)(t,"b","greater","string_or_numeric");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.XhZ,u)}})},8395:(e,t,n)=>{"use strict";n.d(t,{D:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({greaterEqual_:function(e,t){let n=(0,i.YT)(e,"a","greaterEqual","string_or_numeric"),l=(0,i.YT)(t,"b","greaterEqual","string_or_numeric");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.lLS,u)}})},6490:(e,t,n)=>{"use strict";n.d(t,{n:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({imag_:function(e){const t={input:(0,a.YT)(e,"input","imag")};return r.T2.runKernel(s.dv8,t)}})},3541:(e,t,n)=>{"use strict";n.d(t,{v:()=>u});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(779),l=n(6584);const u=(0,o.op)({resizeBilinear_:function(e,t,n=!1,o=!1){const u=(0,a.YT)(e,"images","resizeBilinear");i.vA(3===u.rank||4===u.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${u.rank}.`)),i.vA(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),i.vA(!1===o||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let c=u,d=!1;3===u.rank&&(d=!0,c=(0,l.t)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const[]=t,h={images:c},p={alignCorners:n,halfPixelCenters:o,size:t},f=r.T2.runKernel(s.hgw,h,p);return d?(0,l.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},6728:(e,t,n)=>{"use strict";n.d(t,{b:()=>u});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(779),l=n(6584);const u=(0,o.op)({resizeNearestNeighbor_:function(e,t,n=!1,o=!1){const u=(0,a.YT)(e,"images","resizeNearestNeighbor");i.vA(3===u.rank||4===u.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${u.rank}.`)),i.vA(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),i.vA("float32"===u.dtype||"int32"===u.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),i.vA(!1===o||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let c=u,d=!1;3===u.rank&&(d=!0,c=(0,l.t)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const[]=t,h={images:c},p={alignCorners:n,halfPixelCenters:o,size:t},f=r.T2.runKernel(s.jOE,h,p);return d?(0,l.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},488:(e,t,n)=>{"use strict";n.d(t,{M:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({isFinite_:function(e){const t={x:(0,a.YT)(e,"x","isFinite")};return r.T2.runKernel(s.gIW,t)}})},9508:(e,t,n)=>{"use strict";n.d(t,{E:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({isInf_:function(e){const t={x:(0,a.YT)(e,"x","isInf")};return r.T2.runKernel(s.E3$,t)}})},8226:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({isNaN_:function(e){const t={x:(0,a.YT)(e,"x","isNaN")};return r.T2.runKernel(s.iPs,t)}})},1809:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({leakyRelu_:function(e,t=.2){const n={x:(0,a.YT)(e,"x","leakyRelu")},i={alpha:t};return r.T2.runKernel(s.X0$,n,i)}})},349:(e,t,n)=>{"use strict";n.d(t,{M:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({less_:function(e,t){let n=(0,i.YT)(e,"a","less","string_or_numeric"),l=(0,i.YT)(t,"b","less","string_or_numeric");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.mIA,u)}})},2566:(e,t,n)=>{"use strict";n.d(t,{I:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({lessEqual_:function(e,t){let n=(0,i.YT)(e,"a","lessEqual","string_or_numeric"),l=(0,i.YT)(t,"b","lessEqual","string_or_numeric");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.CwD,u)}})},8557:(e,t,n)=>{"use strict";n.d(t,{K:()=>u});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(779),l=n(6584);const u=(0,o.op)({localResponseNormalization_:function(e,t=5,n=1,o=1,u=.5){const c=(0,a.YT)(e,"x","localResponseNormalization");i.vA(4===c.rank||3===c.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${c.rank}.`)),i.vA(i.E6(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let d=c,h=!1;3===c.rank&&(h=!0,d=(0,l.t)(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const p={x:d},f={depthRadius:t,bias:n,alpha:o,beta:u},m=r.T2.runKernel(s.jM4,p,f);return h?(0,l.t)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},8148:(e,t,n)=>{"use strict";n.d(t,{R:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({log_:function(e){const t={x:(0,a.YT)(e,"x","log","float32")};return r.T2.runKernel(s.tG8,t)}})},7441:(e,t,n)=>{"use strict";n.d(t,{K:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({log1p_:function(e){const t={x:(0,a.YT)(e,"x","log1p")};return r.T2.runKernel(s.Cg$,t)}})},7023:(e,t,n)=>{"use strict";n.d(t,{n:()=>c});var r=n(5836),s=n(7243),a=n(6596),i=n(5428),o=n(779),l=n(6118),u=n(788);const c=(0,o.op)({logSigmoid_:function(e){const t=(0,s.YT)(e,"x","logSigmoid");return(0,r._X)((e=>({value:(0,i.H)((0,u.l)((0,i.H)(e))),gradFunc:t=>(0,a.l)(t,(0,l.r)((0,i.H)(e)))})))(t)}})},6417:(e,t,n)=>{"use strict";n.d(t,{H:()=>p});var r=n(5836),s=n(7243),a=n(3583),i=n(7145),o=n(8148),l=n(7516),u=n(6596),c=n(779),d=n(3136),h=n(7917);const p=(0,c.op)({logSoftmax_:function(e,t=-1){const n=(0,s.YT)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return(0,r._X)(((e,n)=>{const r=(0,l.T)(e,t,!0),s=(0,d.j)(e,r),c=(0,d.j)((0,a.w)(s,"float32"),(0,o.R)((0,h.c)((0,i.o)(s),t,!0)));return n([c]),{value:c,gradFunc:(e,n)=>{const[r]=n,s=(0,i.o)(r);return(0,d.j)(e,(0,u.l)((0,h.c)(e,t,!0),s))}}}))(n)}})},8160:(e,t,n)=>{"use strict";n.d(t,{V:()=>f});var r=n(7243),s=n(6689),a=n(9389),i=n(4640),o=n(7145),l=n(8148),u=n(7516),c=n(779),d=n(6584),h=n(3136),p=n(7917);const f=(0,c.op)({logSumExp_:function(e,t=null,n=!1){const c=(0,r.YT)(e,"x","logSumExp"),f=(0,s.Y6)(t,c.shape),m=(0,u.T)(c,f,!0),g=(0,h.j)(c,m),b=(0,o.o)(g),y=(0,p.c)(b,f),w=(0,l.R)(y),v=(0,a.W)((0,d.t)(m,w.shape),w);if(n){const e=(0,i.SM)(v.shape,f);return(0,d.t)(v,e)}return v}})},1795:(e,t,n)=>{"use strict";n.d(t,{n:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(548);const o=(0,n(779).op)({logicalAnd_:function(e,t){const n=(0,a.YT)(e,"a","logicalAnd","bool"),o=(0,a.YT)(t,"b","logicalAnd","bool");(0,i.assertAndGetBroadcastShape)(n.shape,o.shape);const l={a:n,b:o};return r.T2.runKernel(s.RUm,l)}})},6443:(e,t,n)=>{"use strict";n.d(t,{N:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({logicalNot_:function(e){const t={x:(0,a.YT)(e,"x","logicalNot","bool")};return r.T2.runKernel(s.nZd,t)}})},6045:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(548);const o=(0,n(779).op)({logicalOr_:function(e,t){const n=(0,a.YT)(e,"a","logicalOr","bool"),o=(0,a.YT)(t,"b","logicalOr","bool");(0,i.assertAndGetBroadcastShape)(n.shape,o.shape);const l={a:n,b:o};return r.T2.runKernel(s.LXA,l)}})},1927:(e,t,n)=>{"use strict";n.d(t,{r:()=>l});var r=n(7243),s=n(548),a=n(1795),i=n(6443),o=n(6045);const l=(0,n(779).op)({logicalXor_:function(e,t){const n=(0,r.YT)(e,"a","logicalXor","bool"),l=(0,r.YT)(t,"b","logicalXor","bool");return(0,s.assertAndGetBroadcastShape)(n.shape,l.shape),(0,a.n)((0,o.z)(e,t),(0,i.N)((0,a.n)(e,t)))}})},7506:(e,t,n)=>{"use strict";var r;n.d(t,{i:()=>r}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},4293:(e,t,n)=>{"use strict";n.d(t,{N:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({matMul_:function(e,t,n=!1,o=!1){let l=(0,i.YT)(e,"a","matMul"),u=(0,i.YT)(t,"b","matMul");[l,u]=(0,a.makeTypesMatch)(l,u);const c={a:l,b:u},d={transposeA:n,transposeB:o};return r.T2.runKernel(s.jAQ,c,d)}})},7516:(e,t,n)=>{"use strict";n.d(t,{T:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({max_:function(e,t=null,n=!1){const i={x:(0,a.YT)(e,"x","max")},o={reductionIndices:t,keepDims:n};return r.T2.runKernel(s.VAI,i,o)}})},689:(e,t,n)=>{"use strict";n.d(t,{j:()=>c});var r=n(9936),s=n(2787),a=n(7243),i=n(6689),o=n(8785),l=n(779),u=n(6584);const c=(0,l.op)({maxPool_:function(e,t,n,l,c){const d=(0,a.YT)(e,"x","maxPool");let h=d,p=!1;3===d.rank&&(p=!0,h=(0,u.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),i.vA(4===h.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`)),i.vA(o.G0(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),o.s_("maxPool",l,c);const f={x:h},m={filterSize:t,strides:n,pad:l,dimRoundingMode:c},g=r.T2.runKernel(s.t3d,f,m);return p?(0,u.t)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},1460:(e,t,n)=>{"use strict";n.d(t,{P:()=>u});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548),l=n(3583);const u=(0,n(779).op)({maximum_:function(e,t){let n=(0,i.YT)(e,"a","maximum"),u=(0,i.YT)(t,"b","maximum");[n,u]=(0,a.makeTypesMatch)(n,u),"bool"===n.dtype&&(n=(0,l.w)(n,"int32"),u=(0,l.w)(u,"int32")),(0,o.assertAndGetBroadcastShape)(n.shape,u.shape);const c={a:n,b:u};return r.T2.runKernel(s.LDN,c)}})},597:(e,t,n)=>{"use strict";n.d(t,{i:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({mean_:function(e,t=null,n=!1){const i={x:(0,a.YT)(e,"x","mean")},o={axis:t,keepDims:n};return r.T2.runKernel(s.g5A,i,o)}})},7858:(e,t,n)=>{"use strict";n.d(t,{j:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({min_:function(e,t=null,n=!1){const i={x:(0,a.YT)(e,"x","min")},o={axis:t,keepDims:n};return r.T2.runKernel(s.lNG,i,o)}})},9858:(e,t,n)=>{"use strict";n.d(t,{B:()=>u});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548),l=n(3583);const u=(0,n(779).op)({minimum_:function(e,t){let n=(0,i.YT)(e,"a","minimum"),u=(0,i.YT)(t,"b","minimum");[n,u]=(0,a.makeTypesMatch)(n,u),"bool"===n.dtype&&(n=(0,l.w)(n,"int32"),u=(0,l.w)(u,"int32")),(0,o.assertAndGetBroadcastShape)(n.shape,u.shape);const c={a:n,b:u};return r.T2.runKernel(s.LG0,c)}})},1985:(e,t,n)=>{"use strict";n.d(t,{F:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({mirrorPad_:function(e,t,n){i.vA("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const o=(0,a.YT)(e,"x","mirrorPad");if(0===o.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");i.vA(t.length===o.rank,(()=>`Padding doesn't match input. Must be ${o.rank}. Got ${t.length}.`));const l="reflect"===n?1:0;for(let e=0;e<o.rank;e++)i.vA(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),i.vA(t[e][0]>=0&&t[e][0]<=o.shape[e]-l&&t[e][1]>=0&&t[e][1]<=o.shape[e]-l,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${o.shape[e]-l} or less than 0 for input of shape ${o.shape}`));const u={paddings:t,mode:n},c={x:o};return r.T2.runKernel(s.x7F,c,u)}})},9302:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({mod_:function(e,t){let n=(0,i.YT)(e,"a","mod"),o=(0,i.YT)(t,"b","mod");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.BLA,l)}})},6596:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({mul_:function(e,t){let n=(0,i.YT)(e,"a","mul"),o=(0,i.YT)(t,"b","mul");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.xu7,l)}})},5428:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({neg_:function(e){const t={x:(0,a.YT)(e,"x","neg")};return r.T2.runKernel(s.l0G,t)}})},9134:(e,t,n)=>{"use strict";n.d(t,{x:()=>b});var r=n(7243),s=n(6689),a=n(6762),i=n(4640),o=n(7516),l=n(7858),u=n(779),c=n(6712),d=n(6584),h=n(9e3),p=n(178),f=n(5935),m=n(7917);function g(e,t,n=null){if(0===e.rank)return(0,a.t)(e);if(1!==e.rank&&null===n)return g((0,d.t)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,m.c)((0,a.t)(e),n);if(t===1/0)return(0,o.T)((0,a.t)(e),n);if(t===-1/0)return(0,l.j)((0,a.t)(e),n);if("euclidean"===t||2===t)return(0,p.R)((0,m.c)((0,c.n)((0,a.t)(e),(0,h.d)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,o.T)((0,m.c)((0,a.t)(e),n[0]),n[1]-1);if(t===1/0)return(0,o.T)((0,m.c)((0,a.t)(e),n[1]),n[0]);if(t===-1/0)return(0,l.j)((0,m.c)((0,a.t)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,p.R)((0,m.c)((0,f.E)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const b=(0,u.op)({norm_:function(e,t="euclidean",n=null,a=!1){const o=g(e=(0,r.YT)(e,"x","norm"),t,n);let l=o.shape;if(a){const t=(0,s.Y6)(n,e.shape);l=i.SM(o.shape,t)}return(0,d.t)(o,l)}})},5708:(e,t,n)=>{"use strict";n.d(t,{E:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({notEqual_:function(e,t){let n=(0,i.YT)(e,"a","notEqual","string_or_numeric"),l=(0,i.YT)(t,"b","notEqual","string_or_numeric");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.ylV,u)}})},7690:(e,t,n)=>{"use strict";n.d(t,{M:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({oneHot_:function(e,t,n=1,i=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const l={indices:(0,a.YT)(e,"indices","oneHot","int32")},u={dtype:o,depth:t,onValue:n,offValue:i};return r.T2.runKernel(s.urI,l,u)}})},5101:(e,t,n)=>{"use strict";n.d(t,{S:()=>o});var r=n(9936),s=n(6689),a=n(1030),i=n(8529);function o(e,t="float32"){if((0,s.SA)(e),"complex64"===t){const t=o(e,"float32"),n=(0,i.U)(e,"float32");return(0,a.f)(t,n)}const n=(0,s.FZ)((0,s.Ze)(e),t);return r.T2.makeTensor(n,e,t)}},1619:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({onesLike_:function(e){const t={x:(0,a.YT)(e,"x","onesLike")};return r.T2.runKernel(s.LWX,t)}})},779:(e,t,n)=>{"use strict";n.d(t,{B:()=>a,op:()=>i});var r=n(9936),s=n(6689);const a="__op";function i(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const i=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=a;const o=(...e)=>{r.T2.startScope(n);try{const t=i(...e);return(0,s.yL)(t)&&console.error("Cannot return a Promise inside of tidy."),r.T2.endScope(t),t}catch(e){throw r.T2.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},2740:(e,t,n)=>{"use strict";n.d(t,{BTT:()=>h.B,tnl:()=>s.t,HQu:()=>a.H,FqL:()=>i.F,WQq:()=>o.W,QiD:()=>p,Q7R:()=>f.Q,bzn:()=>m.b,FLi:()=>g.F,XRg:()=>b.X,qRo:()=>y.q,yHs:()=>w.y,rYl:()=>v.r,FPz:()=>x.F,rfv:()=>_.r,$jT:()=>k.$,sub:()=>E,lZX:()=>F,$v7:()=>M.$,BFc:()=>L,kSi:()=>P,T5N:()=>z,GTe:()=>R.G,HbZ:()=>B,vjT:()=>V,ftb:()=>nr,ROE:()=>U,hOW:()=>j.h,ra8:()=>W.r,wgE:()=>S.w,mkO:()=>G.m,zQh:()=>H.z,o8B:()=>q.o,faB:()=>Z.f,xWs:()=>A.x,I1m:()=>K,RPU:()=>Y,O5O:()=>X,P1l:()=>Q,kA9:()=>J.k,Xtf:()=>ee.X,wX9:()=>te.w,IPL:()=>ne,jIJ:()=>se,gnS:()=>ae.g,yIG:()=>ie.y,_jP:()=>hr,Lp0:()=>oe.L,rCv:()=>le.r,aOp:()=>ue,Rj8:()=>ce.R,Gl3:()=>de.G,smy:()=>he,X7t:()=>pe.X,y4m:()=>fe.y,ek5:()=>me.e,Omf:()=>ge.O,EZY:()=>cr,_3C:()=>be,Pqc:()=>ye.P,FJY:()=>dr,QP2:()=>we,LCg:()=>ve.L,Y12:()=>xe.Y,p4S:()=>_e.p,oNF:()=>ke.o,UG6:()=>Se.U,IYd:()=>Te.I,y5U:()=>Ee,hVP:()=>xn.h,GSj:()=>Ae.G,RIf:()=>Ce.R,wh_:()=>Ne.w,cZk:()=>r,kgh:()=>$e.k,SY9:()=>ur,rhj:()=>Oe.r,DQN:()=>De.D,KGM:()=>_n.K,ngS:()=>Fe.n,Slp:()=>ps,U4u:()=>pr,ggX:()=>kn.g,MIs:()=>Re.M,EN4:()=>Me.E,yrW:()=>Le.y,H8d:()=>Pe.H,M7h:()=>ze.M,InN:()=>Be.I,mPL:()=>fs,mT8:()=>Ve,Kgs:()=>Ue.K,Rm2:()=>je.R,Kko:()=>We.K,nqI:()=>Ge.n,HPB:()=>He.H,VZ:()=>qe.V,n76:()=>Ze.n,NSZ:()=>Ke.N,ztW:()=>Ye.z,rxB:()=>Xe.r,YYh:()=>ms,yzS:()=>et,NoW:()=>C.N,T9B:()=>tt.T,jgi:()=>nt.j,NYV:()=>rt,RO:()=>st,PhQ:()=>at.P,i2o:()=>it.i,OYQ:()=>ut,jkA:()=>ct.j,BpO:()=>dt.B,FFZ:()=>ht.F,ziu:()=>pt.z,Clk:()=>bt,CRk:()=>ir,lKK:()=>N.l,YDF:()=>yt,OjQ:()=>wt,HZy:()=>vt.H,xbf:()=>sr.x,Ec:()=>xt.E,Mw0:()=>_t.M,SaS:()=>ot.S,P61:()=>kt.P,op:()=>h.op,X4o:()=>St,eVF:()=>Tt.e,BZs:()=>It,grY:()=>Et,XHu:()=>At,WLX:()=>Ct,dzn:()=>Nt.d,n7C:()=>$t.n,NsG:()=>Ot.N,yyV:()=>Dt.y,_eU:()=>Ft._,whe:()=>Rt,iyU:()=>Mt,Q0_:()=>Lt,_9M:()=>Pt,pR9:()=>jt,FE$:()=>Wt,m0H:()=>Gt,YeY:()=>Ht,HYA:()=>qt,y17:()=>Zt,xav:()=>Kt.x,VOZ:()=>Yt.V,VVh:()=>Xt.V,j__:()=>Qt.j,tQQ:()=>I.t,BEg:()=>Jt.B,QD2:()=>en,LMr:()=>tn,I2l:()=>nn,JYU:()=>rn,z8$:()=>Sn.z,LIG:()=>sn.L,Z$r:()=>an.Z,d_2:()=>on.d,NFr:()=>or,sZg:()=>Je,WfX:()=>ln.W,wdz:()=>un.w,F12:()=>cn,ry7:()=>$.r,_SZ:()=>dn._,vPA:()=>hs,F8e:()=>hn.F,L0l:()=>pn.L,dik:()=>O.d,Q$M:()=>fn,zAd:()=>mn,wck:()=>gn,R0O:()=>bn,Vs9:()=>yn.V,lw0:()=>wn.l,eDJ:()=>vn.e,lMo:()=>gs,Zhr:()=>lr,lOn:()=>ds,lDo:()=>Tn.l,RZD:()=>In.R,EwI:()=>mt.E,Pbu:()=>En.P,r2V:()=>An.r,t$z:()=>Cn.t,PMw:()=>Nn.P,Ym9:()=>$n.Y,YjP:()=>bs,jbE:()=>gt.j,czq:()=>On.c,Mlm:()=>Dn.M,ymU:()=>D.y,OEK:()=>Fn.O,tGX:()=>Mn,KtR:()=>Ln,$_$:()=>Pn.$,g9W:()=>zn,Lpo:()=>Bn,yxw:()=>Vn,NNh:()=>jn,Vsq:()=>Ie.V,rfw:()=>Wn.r,mgz:()=>rr.m,efE:()=>Gn,AmM:()=>Hn.A,zAU:()=>qn.z,K$i:()=>Zn.K,rni:()=>Kn,bvq:()=>Yn,_M9:()=>Xn._,YJN:()=>Jn,Ul9:()=>er.U,POl:()=>tr.P});var r={};n.r(r),n.d(r,{conv2d:()=>wr,depthwiseConv2d:()=>_r,matMul:()=>kr});var s=n(6762),a=n(4702),i=n(3876),o=n(9389),l=n(9936),u=n(2787),c=n(7243),d=n(6689),h=n(779);const p=(0,h.op)({addN_:function(e){d.vA(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),d.vA(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!d.r1(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return l.T2.runKernel(u.EkD,r)}});var f=n(6733),m=n(3047),g=n(5455),b=n(2421),y=n(8807),w=n(2615),v=n(2774),x=n(9374),_=n(7004),k=n(9303),S=n(3583),T=n(8785),I=n(6584);const E=(0,h.op)({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=(0,c.YT)(e,"x","avgPool3d","float32");let o=i,h=!1;4===i.rank&&(h=!0,o=(0,I.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.vA(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),d.vA("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),d.vA("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),(0,T.s_)("avgPool3d",r,s);const p={x:o},f={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let m=l.T2.runKernel(u.cS,p,f);return m=(0,S.w)(m,o.dtype),h?(0,I.t)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}});var A=n(4636),C=n(4293),N=n(6596),$=n(6118),O=n(9340),D=n(8198);const F=(0,h.op)({basicLSTMCell_:function(e,t,n,r,s,a){const i=(0,c.YT)(e,"forgetBias","basicLSTMCell"),l=(0,c.YT)(t,"lstmKernel","basicLSTMCell"),u=(0,c.YT)(n,"lstmBias","basicLSTMCell"),d=(0,c.YT)(r,"data","basicLSTMCell"),h=(0,c.YT)(s,"c","basicLSTMCell"),p=(0,c.YT)(a,"h","basicLSTMCell"),f=(0,A.x)([d,p],1),m=(0,C.N)(f,l),g=(0,o.W)(m,u),b=g.shape[0],y=g.shape[1]/4,w=[b,y],v=(0,O.d)(g,[0,0],w),x=(0,O.d)(g,[0,y],w),_=(0,O.d)(g,[0,2*y],w),k=(0,O.d)(g,[0,3*y],w),S=(0,o.W)((0,N.l)((0,$.r)(v),(0,D.y)(x)),(0,N.l)(h,(0,$.r)((0,o.W)(i,_))));return[S,(0,N.l)((0,D.y)(S),(0,$.r)(k))]}});var R=n(610),M=n(6363);const L=(0,h.op)({batchNorm2d_:function(e,t,n,r,s,a){const i=(0,c.YT)(e,"x","batchNorm"),o=(0,c.YT)(t,"mean","batchNorm"),l=(0,c.YT)(n,"variance","batchNorm");let u,h;return null!=s&&(u=(0,c.YT)(s,"scale","batchNorm")),null!=r&&(h=(0,c.YT)(r,"offset","batchNorm")),d.vA(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),d.vA(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),d.vA(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&d.vA(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=h&&d.vA(2===h.rank||1===h.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`)),(0,M.$)(i,o,l,h,u,a)}}),P=(0,h.op)({batchNorm3d_:function(e,t,n,r,s,a){const i=(0,c.YT)(e,"x","batchNorm"),o=(0,c.YT)(t,"mean","batchNorm"),l=(0,c.YT)(n,"variance","batchNorm");let u,h;return null!=s&&(u=(0,c.YT)(s,"scale","batchNorm")),null!=r&&(h=(0,c.YT)(r,"offset","batchNorm")),d.vA(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),d.vA(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),d.vA(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&d.vA(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=h&&d.vA(3===h.rank||1===h.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`)),(0,M.$)(i,o,l,h,u,a)}}),z=(0,h.op)({batchNorm4d_:function(e,t,n,r,s,a){const i=(0,c.YT)(e,"x","batchNorm"),o=(0,c.YT)(t,"mean","batchNorm"),l=(0,c.YT)(n,"variance","batchNorm");let u,h;return null!=s&&(u=(0,c.YT)(s,"scale","batchNorm")),null!=r&&(h=(0,c.YT)(r,"offset","batchNorm")),d.vA(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),d.vA(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),d.vA(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&d.vA(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=h&&d.vA(4===h.rank||1===h.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`)),(0,M.$)(i,o,l,h,u,a)}}),B=(0,h.op)({bincount_:function(e,t,n){const r=(0,c.YT)(e,"x","bincount"),s=(0,c.YT)(t,"weights","bincount");d.vA("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),d.vA(n>=0,(()=>`size must be non-negative, but got ${n}.`)),d.vA(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return l.T2.runKernel(u.N4F,a,i)}}),V=(0,h.op)({bitwiseAnd_:function(e,t){const n=(0,c.YT)(e,"x","bitwiseAnd"),r=(0,c.YT)(t,"y","bitwiseAnd");if(!(0,d.r1)(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return l.T2.runKernel(u.HNs,s)}}),U=(0,h.op)({broadcastArgs_:function(e,t){const n=(0,c.YT)(e,"s0","broadcastArgs","int32"),r=(0,c.YT)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return l.T2.runKernel(u.vj7,s)}});var j=n(209),W=n(1950),G=n(8665),H=n(3406),q=n(99),Z=n(1030);const K=(0,h.op)({concat1d_:function(e){return(0,A.x)(e,0)}}),Y=(0,h.op)({concat2d_:function(e,t){return(0,A.x)(e,t)}}),X=(0,h.op)({concat3d_:function(e,t){return(0,A.x)(e,t)}}),Q=(0,h.op)({concat4d_:function(e,t){return(0,A.x)(e,t)}});var J=n(4347),ee=n(4300),te=n(5380);const ne=(0,h.op)({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=(0,c.YT)(e,"x","conv3d"),o=(0,c.YT)(t,"filter","conv3d");let h=i,p=!1;4===i.rank&&(p=!0,h=(0,I.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.vA(5===h.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`)),d.vA(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),d.vA(h.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),d.vA((0,T.G0)(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),d.vA("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),d.vA((0,T.qk)(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),d.vA((0,T.qk)(n),(()=>"Error in conv3D: Strides should be larger than 0."));const f={x:h,filter:o},m={strides:n,pad:r,dataFormat:s,dilations:a},g=l.T2.runKernel(u.A1h,f,m);return p?(0,I.t)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}});var re=n(8413);const se=(0,h.op)({conv3dTranspose_:function(e,t,n,r,s){const a=(0,c.YT)(e,"x","conv3dTranspose"),i=(0,c.YT)(t,"filter","conv3dTranspose");return(0,re.c)(n,a,i,r,s)}});var ae=n(579),ie=n(765),oe=n(2268),le=n(8062);const ue=(0,h.op)({denseBincount_:function(e,t,n,r=!1){const s=(0,c.YT)(e,"x","denseBincount"),a=(0,c.YT)(t,"weights","denseBincount");d.vA("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),d.vA(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),d.vA(n>=0,(()=>`size must be non-negative, but got ${n}.`)),d.vA(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return l.T2.runKernel(u.wNW,i,o)}});var ce=n(3682),de=n(1490);const he=(0,h.op)({diag_:function(e){const t={x:(0,c.YT)(e,"x","diag")};return l.T2.runKernel(u.ORI,t)}});var pe=n(7268),fe=n(4493),me=n(8209),ge=n(9426);const be=(0,h.op)({einsum_:function(e,...t){const n=t.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"einsum"))),r={equation:e};return l.T2.runKernel(u.Qgm,n,r)}});var ye=n(2810);const we=(0,h.op)({ensureShape_:function(e,t){const n=(0,c.YT)(e,"x","ensureShape","string_or_numeric");if(!(0,d.e_)(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var ve=n(6414),xe=n(9665),_e=n(983),ke=n(7145),Se=n(3420),Te=n(8172),Ie=n(4944);const Ee=(0,h.op)({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=(0,W.r)([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)s.set(1,e,e);const i=(0,I.t)(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return(0,Ie.V)((0,Se.U)(i,0),[n[0],1,1]);if(2===n.length)return(0,Ie.V)((0,Se.U)((0,Se.U)(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,Ie.V)((0,Se.U)((0,Se.U)((0,Se.U)(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var Ae=n(6673),Ce=n(7160),Ne=n(905),$e=n(7755),Oe=n(560),De=n(8395),Fe=n(6490),Re=n(488),Me=n(9508),Le=n(8226),Pe=n(1809),ze=n(349),Be=n(2566);function Ve(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return l.T2.runKernel(u.mnI,{},r)}var Ue=n(8557),je=n(8148),We=n(7441),Ge=n(7023),He=n(6417),qe=n(8160),Ze=n(1795),Ke=n(6443),Ye=n(6045),Xe=n(1927);const Qe=2147483648,Je=(0,h.op)({searchSorted_:function(e,t,n="left"){const r=(0,c.YT)(e,"sortedSequence","searchSorted"),s=(0,c.YT)(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=(0,I.t)(r,[-1,a]),h=(0,I.t)(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==h.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,d.Ze)(h.shape)>=Qe)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=Qe)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const p={sortedSequence:o,values:h},f={side:n};return l.T2.runKernel(u.uWl,p,f)}});function et(e,t){return Je(e,t,"left")}var tt=n(7516),nt=n(689);const rt=(0,h.op)({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=(0,c.YT)(e,"x","maxPool3d");let o=i,h=!1;4===i.rank&&(h=!0,o=(0,I.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.vA(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),d.vA("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),(0,T.s_)("maxPool3d",r,s);const p={x:o},f={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},m=l.T2.runKernel(u.ySp,p,f);return h?(0,I.t)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),st=(0,h.op)({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const a={x:(0,c.YT)(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=l.T2.runKernel(u.TL8,a,i);return{result:o[0],indexes:o[1]}}});var at=n(1460),it=n(597),ot=n(5101),lt=n(1794);function ut(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=(0,c.YT)(e,"x","meshgrid",e instanceof lt.qY?e.dtype:"float32");if(void 0===t)return[r];let s=(0,c.YT)(t,"y","meshgrid",t instanceof lt.qY?t.dtype:"float32");const a=(0,d.Ze)(r.shape),i=(0,d.Ze)(s.shape);return"xy"===n?(r=(0,I.t)(r,[1,-1]),s=(0,I.t)(s,[-1,1]),[(0,C.N)((0,ot.S)([i,1],r.dtype),r),(0,C.N)(s,(0,ot.S)([1,a],s.dtype))]):(r=(0,I.t)(r,[-1,1]),s=(0,I.t)(s,[1,-1]),[(0,C.N)(r,(0,ot.S)([1,i],r.dtype)),(0,C.N)((0,ot.S)([a,1],s.dtype),s)])}var ct=n(7858),dt=n(9858),ht=n(1985),pt=n(9302),ft=n(4640),mt=n(5935),gt=n(3136);const bt=(0,h.op)({moments_:function(e,t=null,n=!1){e=(0,c.YT)(e,"x","moments");const r=(0,d.Y6)(t,e.shape),s=(0,it.i)(e,r,n);let a=s.shape;n||(a=(0,ft.SM)(s.shape,r));const i=(0,mt.E)((0,gt.j)((0,S.w)(e,"float32"),(0,I.t)(s,a)));return{mean:s,variance:(0,it.i)(i,r,n)}}}),yt=(0,h.op)({multiRNNCell_:function(e,t,n,r){const s=(0,c.YT)(t,"data","multiRNNCell"),a=(0,c.j1)(n,"c","multiRNNCell"),i=(0,c.j1)(r,"h","multiRNNCell");let o=s;const l=[];for(let t=0;t<e.length;t++){const n=e[t](o,a[t],i[t]);l.push(n[0]),l.push(n[1]),o=n[1]}const u=[],d=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),d.push(l[e+1]);return[u,d]}}),wt=(0,h.op)({multinomial_:function(e,t,n,r=!1){const s=(0,c.YT)(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?(0,I.t)(s,[1,-1]):s},d={numSamples:t,seed:n,normalized:r},h=l.T2.runKernel(u.WT3,o,d);return 1===i?(0,I.t)(h,[h.size]):h}});var vt=n(5428),xt=n(5708),_t=n(7690),kt=n(1619);const St=(0,h.op)({outerProduct_:function(e,t){const n=(0,c.YT)(e,"v1","outerProduct"),r=(0,c.YT)(t,"v2","outerProduct");d.vA(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=(0,I.t)(n,[-1,1]),a=(0,I.t)(r,[1,-1]);return(0,C.N)(s,a)}});var Tt=n(6023);const It=(0,h.op)({pad1d_:function(e,t,n=0){return(0,d.vA)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),(0,Tt.e)(e,[t],n)}}),Et=(0,h.op)({pad2d_:function(e,t,n=0){return(0,d.vA)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,Tt.e)(e,t,n)}}),At=(0,h.op)({pad3d_:function(e,t,n=0){return(0,d.vA)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,Tt.e)(e,t,n)}}),Ct=(0,h.op)({pad4d_:function(e,t,n=0){return(0,d.vA)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,Tt.e)(e,t,n)}});var Nt=n(7606),$t=n(6712),Ot=n(5368),Dt=n(7905),Ft=n(2105);const Rt=(0,h.op)({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:(0,c.YT)(t,"paramsDenseValues","raggedGather"),indices:(0,c.YT)(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=l.T2.runKernel(u.oJ2,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}}),Mt=(0,h.op)({raggedRange_:function(e,t,n){const r=(0,c.YT)(e,"starts","raggedRange"),s={starts:r,limits:(0,c.YT)(t,"limits","raggedRange",r.dtype),deltas:(0,c.YT)(n,"deltas","raggedRange",r.dtype)},a=l.T2.runKernel(u.CQC,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),Lt=(0,h.op)({raggedTensorToTensor_:function(e,t,n,r,s){const a=(0,c.YT)(e,"shape","raggedTensorToTensor","int32"),i=(0,c.YT)(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:(0,c.YT)(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"raggedTensorToTensor","int32")))},d={rowPartitionTypes:s};return l.T2.runKernel(u.mH5,o,d)}}),Pt=(0,h.op)({rand_:function(e,t,n){(0,d.SA)(e);const r=(0,d.Ze)(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return l.T2.makeTensor(s,e,n)}});var zt=n(8273);class Bt{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=zt.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Vt{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=zt.alea(s.toString()),this.randn=new Bt(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class Ut{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=zt.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const jt=(0,h.op)({randomGamma_:function(e,t,n=1,r="float32",s){if((0,d.SA)(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new Vt(t,n,r,s),i=(0,W.r)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Wt=(0,h.op)({randomNormal_:function(e,t=0,n=1,r,s){if((0,d.SA)(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Bt(t,n,r,!1,s),i=(0,W.r)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Gt=(0,h.op)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Wt(e,0,1,t,n)}}),Ht=(0,h.op)({randomUniform_:function(e,t=0,n=1,r="float32",s){(0,d.SA)(e);const a=(0,W.r)(e,r),i=new Ut(t,n,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=i.nextValue();return a.toTensor()}}),qt=(0,h.op)({randomUniformInt_:function(e,t,n,r){return Ht(e,t,n,"int32",r)}});function Zt(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return l.T2.runKernel(u.Q6t,{},s)}var Kt=n(8440),Yt=n(104),Xt=n(5738),Qt=n(1958),Jt=n(4032);const en=(0,h.op)({reverse1d_:function(e){const t=(0,c.YT)(e,"x","reverse");return d.vA(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),(0,Jt.B)(t,0)}}),tn=(0,h.op)({reverse2d_:function(e,t){const n=(0,c.YT)(e,"x","reverse");return d.vA(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),(0,Jt.B)(n,t)}}),nn=(0,h.op)({reverse3d_:function(e,t){const n=(0,c.YT)(e,"x","reverse");return d.vA(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),(0,Jt.B)(n,t)}}),rn=(0,h.op)({reverse4d_:function(e,t){const n=(0,c.YT)(e,"x","reverse");return d.vA(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),(0,Jt.B)(n,t)}});var sn=n(9646),an=n(882),on=n(9e3),ln=n(7703),un=n(9348);const cn=async function(e,t){const n=(0,c.YT)(e,"x","setdiff1d"),r=(0,c.YT)(t,"y","setdiff1d");d.vA(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),d.vA(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),d.vA(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const l=new lt.yl([o],n.dtype),u=new lt.yl([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(l.values[t]=s[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]};var dn=n(5525),hn=n(56),pn=n(2306);const fn=(0,h.op)({slice1d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice1d");return d.vA(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),(0,O.d)(r,[t],[n])}}),mn=(0,h.op)({slice2d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice2d");return d.vA(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),(0,O.d)(r,t,n)}}),gn=(0,h.op)({slice3d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice3d");return d.vA(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),(0,O.d)(r,t,n)}}),bn=(0,h.op)({slice4d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice4d");return d.vA(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),(0,O.d)(r,t,n)}});var yn=n(6288),wn=n(788),vn=n(4926),xn=n(5687),_n=n(3966),kn=n(1718),Sn=n(2237),Tn=n(4782),In=n(178),En=n(225),An=n(6758),Cn=n(1442),Nn=n(5366),$n=n(5684),On=n(7917),Dn=n(845),Fn=n(4233),Rn=n(2061);function Mn(e,t){(0,d.HO)(e);const n=(0,c.MZ)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,Rn.Q)(e,null,n,t)}function Ln(e,t,n){if((0,d.HO)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=(0,c.MZ)(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Rn.Q)(e,t,r,n)}var Pn=n(1066);function zn(e,t,n){if((0,d.HO)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=(0,c.MZ)(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Rn.Q)(e,t,r,n)}function Bn(e,t,n){if((0,d.HO)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=(0,c.MZ)(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Rn.Q)(e,t,r,n)}function Vn(e,t,n){if((0,d.HO)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=(0,c.MZ)(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,(0,Rn.Q)(e,t,r,n)}var Un=n(9684);const jn=(0,h.op)({tensorScatterUpdate_:function(e,t,n){const r=(0,c.YT)(e,"tensor","tensorScatterupdate"),s=(0,c.YT)(t,"indices","tensorScatterupdate","int32"),a=(0,c.YT)(n,"updates","tensorScatterupdate");if(Un.validateInput(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return l.T2.runKernel(u.X4r,i,{})}});var Wn=n(8244);const Gn=(0,h.op)({truncatedNormal_:function(e,t=0,n=1,r,s){if((0,d.SA)(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Bt(t,n,r,!0,s),i=(0,W.r)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});var Hn=n(1211),qn=n(1896),Zn=n(2223);function Kn(e,t){return Je(e,t,"right")}function Yn(e,t=!0,n,r){return l.T2.makeVariable(e,t,n,r)}var Xn=n(6073),Qn=n(197);const Jn=async function(e){const t=(0,c.YT)(e,"condition","whereAsync","bool"),n=await t.data(),r=(0,Qn.Y)(t.shape,n);return e!==t&&t.dispose(),r};var er=n(8529),tr=n(7591);const nr=async function(e,t,n){const r=(0,c.YT)(e,"tensor","boolMask"),s=(0,c.YT)(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;d.vA(i>0,(()=>"mask cannot be scalar")),d.O3(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=a;e<a+i;e++)l*=o[e];const u=o.slice(0,a).concat([l],o.slice(a+i)),h=(0,I.t)(r,u),p=(0,I.t)(s,[-1]),f=await Jn(p),m=(0,An.r)(f,[1]),g=(0,$e.k)(h,m,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),m.dispose(),h.dispose(),p.dispose(),f.dispose(),g};var rr=n(7365),sr=n(9134),ar=n(3031);const ir=(0,h.op)({movingAverage_:function(e,t,n,r,s=!0){const a=(0,c.YT)(e,"v","movingAverage"),i=(0,c.YT)(t,"x","movingAverage"),l=(0,c.YT)(n,"decay","movingAverage");(0,ar.assertTypesMatch)(a,i),d.vA(d.r1(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const u=(0,on.d)(1),h=(0,gt.j)(u,l);let p=(0,N.l)((0,gt.j)(i,a),h);if(s){d.vA(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=(0,c.YT)(r,"step","movingAverage");p=(0,fe.y)(p,(0,gt.j)(u,(0,$t.n)(l,e)))}return(0,o.W)(a,p)}}),or=(0,h.op)({scatterND_:function(e,t,n){(0,d.SA)(n);const r=(0,c.YT)(e,"indices","scatterND","int32"),s=(0,c.YT)(t,"updates","scatterND");Un.validateInput(s,r,n);const a={indices:r,updates:s},i={shape:n};return l.T2.runKernel(u.pJc,a,i)}}),lr=(0,h.op)({sparseToDense_:function(e,t,n,r=0){(0,d.SA)(n);const s=(0,c.YT)(e,"sparseIndices","sparseToDense","int32"),a=(0,c.YT)(t,"sparseValues","sparseToDense","string_or_numeric"),i=(0,c.YT)(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},h={outputShape:n};return l.T2.runKernel(u.jgd,o,h)}}),ur=(0,h.op)({gatherND_:function(e,t){const n=(0,c.YT)(t,"indices","gatherND","int32"),r={params:(0,c.YT)(e,"x","gatherND","string_or_numeric"),indices:n};return l.T2.runKernel(u.O4G,r)}}),cr=(0,h.op)({dropout_:function(e,t,n,r){const s=(0,c.YT)(e,"x","dropout");if(d.vA("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),d.vA(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof lt.qY?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(d.r1(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,l=(0,fe.y)((0,Ce.R)((0,o.W)(Ht(a,0,1,"float32",r),i)),i);return(0,N.l)(s,l)}});function dr(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function hr(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Mn(s,"float32")}const pr=async function(e,t,n=1){const r=(0,c.YT)(e,"predictions","inTopK"),s=(0,c.YT)(t,"targets","inTopK");(0,d.vA)(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),(0,d.vA)(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),(0,d.O3)(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];(0,d.vA)(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],h=(0,d.ce)("bool",l);for(let e=0;e<l;e++){const t=e*u,r=i.subarray(t,t+u),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort(((e,t)=>t.value-e.value)),h[e]=0;for(let t=0;t<n;t++)if(s[t].index===o[e]){h[e]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),(0,Fn.O)(h,s.shape,"bool")};var fr=n(5836),mr=n(548),gr=n(4958),br=n(4314),yr=n(9192);const wr=(0,h.op)({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:h,activation:p="linear",preluActivationWeights:f,leakyreluAlpha:m}){if(p=p||"linear",!1===(0,yr.zE)(l.T2.state.gradientDepth,p)){d.vA("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let l=(0,ee.X)(e,t,n,r,s,a,i);return null!=h&&(l=(0,o.W)(l,h)),(0,yr.f2)(l,p,f,m)}const g=(0,c.YT)(e,"x","conv2d","float32"),b=(0,c.YT)(t,"filter","conv2d","float32");let y=g,w=!1;3===g.rank&&(w=!0,y=(0,I.t)(g,[1,g.shape[0],g.shape[1],g.shape[2]])),d.vA(4===y.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`)),d.vA(4===b.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${b.rank}.`)),T.s_("fused conv2d",r,i);const v="NHWC"===s?y.shape[3]:y.shape[1];d.vA(b.shape[2]===v,(()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${b.shape[2]}.`)),d.vA(T.G0(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const x=T.uf(y.shape,b.shape,n,a,r,i);let _,k;if(null!=h&&(_=(0,c.YT)(h,"bias","fused conv2d"),[_]=(0,ar.makeTypesMatch)(_,g),"NHWC"===s?mr.assertAndGetBroadcastShape(x.outShape,_.shape):(d.vA(_.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${_.shape.length}.`)),d.vA(0===_.shape.length||_.shape[0]===x.outChannels||1===_.shape[0],(()=>`Error in fused conv2d: bias shape (${_.shape}) is not compatible with the number of output channels (${x.outChannels})`)))),null!=f){const e=f.shape;if(d.vA(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)d.vA(1===e[0]||e[0]===x.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${x.outChannels}).`));else if(3===e.length)try{mr.assertAndGetBroadcastShape(e,x.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(n)}k=(0,c.YT)(f,"prelu weights","fused conv2d")}const S=(e,t)=>{d.vA("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[i,o,l,u]=t,c=(0,yr.XB)(e,l,p);d.vA(T.Dh(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const h=[(0,br.v)(o.shape,c,i,n,r),(0,gr.H)(o,c,i.shape,n,r)];if(null!=u){const e=(0,yr.Do)(u,c);h.push(e)}return h},E={x:y,filter:b,bias:_,preluActivationWeights:k},A={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:p,leakyreluAlpha:m};if(null==h){const e=(0,fr._X)(((e,t,n)=>{let r=l.T2.runKernel(u.aAr,E,A);return n([t,e,r]),w&&(r=(0,I.t)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:S}}));return e(y,b)}{const e=(0,fr._X)(((e,t,n,r)=>{let s=l.T2.runKernel(u.aAr,E,A);return r([t,e,s,n]),w&&(s=(0,I.t)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:S}}));return e(y,b,_)}}});var vr=n(1020),xr=n(2392);const _r=(0,h.op)({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:h,activation:p="linear",preluActivationWeights:f,leakyreluAlpha:m}){if(!1===(0,yr.zE)(l.T2.state.gradientDepth,p)){let l=(0,de.G)(e,t,n,r,s,a,i);return null!=h&&(l=(0,o.W)(l,h)),(0,yr.f2)(l,p,f,m)}const g=(0,c.YT)(e,"x","depthwiseConv2d","float32"),b=(0,c.YT)(t,"filter","depthwiseConv2d","float32");let y=g,w=!1;3===g.rank&&(w=!0,y=(0,I.t)(g,[1,g.shape[0],g.shape[1],g.shape[2]])),d.vA(4===y.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`)),d.vA(4===b.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${b.rank}.`)),d.vA(y.shape[3]===b.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${b.shape[2]}.`)),null==a&&(a=[1,1]),d.vA(T.G0(n,a),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),T.s_("fused depthwiseConv2d",r,i);const v=T.uf(y.shape,b.shape,n,a,r,i,!0);let x,_;null!=h&&(x=(0,c.YT)(h,"bias","fused conv2d"),[x]=(0,ar.makeTypesMatch)(x,g),mr.assertAndGetBroadcastShape(v.outShape,x.shape)),null!=f&&(_=(0,c.YT)(f,"prelu weights","fused depthwiseConv2d"));const k=(e,t)=>{d.vA(T.Dh(a),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));const[s,o,l,u]=t,c=(0,yr.XB)(e,l,p),h=(0,xr.l)(o.shape,c,s,n,r,a,i),f=(0,vr.x)(o,c,s.shape,n,r,a,i);return null!=u?[h,f,(0,yr.Do)(x,c)]:[h,f]},S={x:y,filter:b,bias:x,preluActivationWeights:_},E={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:p,leakyreluAlpha:m};if(null==h){const e=(0,fr._X)(((e,t,n)=>{let r=l.T2.runKernel(u.T7M,S,E);return n([t,e,r]),w&&(r=(0,I.t)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:k}}));return e(y,b)}{const e=(0,fr._X)(((e,t,n,r)=>{let s=l.T2.runKernel(u.T7M,S,E);return r([t,e,s,n]),w&&(s=(0,I.t)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:k}}));return e(y,b,x)}}}),kr=(0,h.op)({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:h=.2}){if(!1===(0,yr.zE)(l.T2.state.gradientDepth,a)){let l=(0,C.N)(e,t,n,r);return null!=s&&(l=(0,o.W)(l,s)),(0,yr.f2)(l,a,i,h)}let p=(0,c.YT)(e,"a","fused matMul"),f=(0,c.YT)(t,"b","fused matMul");[p,f]=(0,ar.makeTypesMatch)(p,f);const m=n?p.shape[p.rank-2]:p.shape[p.rank-1],g=r?f.shape[f.rank-1]:f.shape[f.rank-2],b=n?p.shape[p.rank-1]:p.shape[p.rank-2],y=r?f.shape[f.rank-2]:f.shape[f.rank-1],w=p.shape.slice(0,-2),v=f.shape.slice(0,-2),x=d.Ze(w),_=d.Ze(v);d.vA(m===g,(()=>`Error in fused matMul: inner shapes (${m}) and (${g}) of Tensors with shapes ${p.shape} and ${f.shape} and transposeA=${n} and transposeB=${r} must match.`));const k=mr.assertAndGetBroadcastShape(p.shape.slice(0,-2),f.shape.slice(0,-2)).concat([b,y]),S=n?(0,I.t)(p,[x,m,b]):(0,I.t)(p,[x,b,m]),T=r?(0,I.t)(f,[_,y,g]):(0,I.t)(f,[_,g,y]);let E,A;null!=s&&(E=(0,c.YT)(s,"bias","fused matMul"),[E]=(0,ar.makeTypesMatch)(E,p),mr.assertAndGetBroadcastShape(k,E.shape)),null!=i&&(A=(0,c.YT)(i,"prelu weights","fused matMul"));const N=(e,t)=>{const[i,o,l,u]=t,c=(0,yr.XB)((0,I.t)(e,l.shape),l,a);let d,h;return n||r?!n&&r?(d=(0,C.N)(c,o,!1,!1),h=(0,C.N)(c,i,!0,!1)):n&&!r?(d=(0,C.N)(o,c,!1,!0),h=(0,C.N)(i,c,!1,!1)):(d=(0,C.N)(o,c,!0,!0),h=(0,C.N)(c,i,!0,!0)):(d=(0,C.N)(c,o,!1,!0),h=(0,C.N)(i,c,!0,!1)),null!=s?[d,h,(0,yr.Do)(u,c)]:[d,h]},$={a:S,b:T,bias:E,preluActivationWeights:A},O={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:h};if(null==s){const e=(0,fr._X)(((e,t,n)=>{const r=l.T2.runKernel(u.Dr,$,O);return n([e,t,r]),{value:(0,I.t)(r,k),gradFunc:N}}));return e(S,T)}{const e=(0,fr._X)(((e,t,n,r)=>{const s=l.T2.runKernel(u.Dr,$,O);return r([e,t,s,n]),{value:(0,I.t)(s,k),gradFunc:N}}));return e(S,T,E)}}}),Sr=(0,h.op)({hammingWindow_:function(e){return hr(e,.54,.46)}}),Tr=(0,h.op)({hannWindow_:function(e){return hr(e,.5,.5)}}),Ir=(0,h.op)({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push((0,O.d)(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=(0,A.x)([(0,O.d)(e,a,t-r),(0,Ae.G)([r],s)]);i.push(o),a+=n}return 0===i.length?Ln([],[0,t]):(0,I.t)((0,A.x)(i),[i.length,t])}}),Er=(0,h.op)({stft_:function(e,t,n,r,s=Tr){null==r&&(r=dr(t));const a=Ir(e,t,n),i=(0,N.l)(a,s(t));return(0,Sn.z)(i,r)}}),Ar=(0,h.op)({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=(0,c.YT)(e,"image","cropAndResize"),o=(0,c.YT)(t,"boxes","cropAndResize","float32"),h=(0,c.YT)(n,"boxInd","cropAndResize","int32"),p=o.shape[0];d.vA(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),d.vA(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${o.shape}.`)),d.vA(1===h.rank&&h.shape[0]===p,(()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${o.shape}.`)),d.vA(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),d.vA(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),d.vA("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const f={image:i,boxes:o,boxInd:h},m={method:s,extrapolationValue:a,cropSize:r};return l.T2.runKernel(u.MRQ,f,m)}}),Cr=(0,h.op)({flipLeftRight_:function(e){const t=(0,c.YT)(e,"image","flipLeftRight","float32");d.vA(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return l.T2.runKernel(u.BxF,n,{})}}),Nr=(0,h.op)({grayscaleToRGB_:function(e){const t=(0,c.YT)(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];d.vA(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),d.vA(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,(0,Ie.V)(t,s)}}),$r=(0,h.op)({rgbToGrayscale_:function(e){const t=(0,c.YT)(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];d.vA(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),d.vA(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=(0,S.w)(t,"float32"),i=Mn([.2989,.587,.114]);let o;switch(t.rank){case 2:o=be("ij,j->i",a,i);break;case 3:o=be("ijk,k->ij",a,i);break;case 4:o=be("ijkl,l->ijk",a,i);break;case 5:o=be("ijklm,m->ijkl",a,i);break;case 6:o=be("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=(0,Se.U)(o,-1),(0,S.w)(o,s)}}),Or=(0,h.op)({rotateWithOffset_:function(e,t,n=0,r=.5){const s=(0,c.YT)(e,"image","rotateWithOffset","float32");d.vA(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return l.T2.runKernel(u.BK4,a,i)}});function Dr(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),d.vA(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),d.vA(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),d.vA(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),d.vA(1===t.rank,(()=>"scores must be a 1D tensor")),d.vA(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),d.vA(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Fr=(0,h.op)({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=(0,c.YT)(e,"boxes","nonMaxSuppression","float32"),i=(0,c.YT)(t,"scores","nonMaxSuppression","float32"),o=Dr(a,i,n,r,s),d={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return l.T2.runKernel(u.SDM,{boxes:a,scores:i},d)}});var Rr=n(7169);const Mr=(0,h.op)({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=(0,c.YT)(e,"boxes","nonMaxSuppression"),o=(0,c.YT)(t,"scores","nonMaxSuppression"),d=Dr(i,o,n,r,s,a),h={boxes:i,scores:o},p={maxOutputSize:n=d.maxOutputSize,iouThreshold:r=d.iouThreshold,scoreThreshold:s=d.scoreThreshold,softNmsSigma:a=d.softNmsSigma},f=l.T2.runKernel(u.e0f,h,p);return{selectedIndices:f[0],selectedScores:f[1]}}}),Lr=(0,h.op)({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=(0,c.YT)(e,"boxes","nonMaxSuppression"),o=(0,c.YT)(t,"scores","nonMaxSuppression"),d=Dr(i,o,n,r,s,null),h={boxes:i,scores:o},p={maxOutputSize:d.maxOutputSize,iouThreshold:d.iouThreshold,scoreThreshold:d.scoreThreshold,padToMaxOutputSize:a},f=l.T2.runKernel(u.Zl4,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}});var Pr=n(3541),zr=n(6728);const Br=(0,h.op)({threshold_:function(e,t="binary",n=!1,r=.5){const s=(0,c.YT)(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,l,u,h,p=(0,N.l)(Mn([r]),255);if(d.vA(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),d.vA(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),d.vA("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),d.vA("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,l,u]=(0,Tn.l)(s,[1,1,1],-1);const e=(0,N.l)(i,.2989),t=(0,N.l)(l,.587),n=(0,N.l)(u,.114);h=(0,o.W)((0,o.W)(e,t),n)}else h=e;"otsu"===t&&(p=function(e,t){let n,r,s,a,i,l,u=Mn([-1]),c=Mn([0]),d=Mn([0]);for(let h=0;h<e.size-1;h++){n=(0,O.d)(e,0,h+1),r=(0,O.d)(e,h+1),i=(0,fe.y)((0,On.c)(n),t),l=(0,fe.y)((0,On.c)(r),t);const p=(0,On.c)((0,N.l)(n,Zt(0,n.size)));s=(0,fe.y)(p,(0,On.c)(n));const f=(0,Ae.G)(r.shape,n.size),m=(0,o.W)(Zt(0,r.size),f),g=(0,N.l)(r,m);a=(0,fe.y)((0,On.c)(g),(0,On.c)(r));const b=(0,gt.j)(s,a),y=(0,gt.j)(s,a),w=(0,N.l)(i,l);d=(0,N.l)((0,N.l)(w,b),y);const v=(0,Oe.r)(d,c);c=(0,Xn._)(v,d,c),u=(0,Xn._)(v,Mn([h]),u)}return u}(B((0,S.w)((0,sn.L)(h),"int32"),(0,Fn.O)([]),256),a));const f=n?(0,Be.I)(h,p):(0,Oe.r)(h,p);return(0,S.w)((0,N.l)(f,255),"int32")}}),Vr=(0,h.op)({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=(0,c.YT)(e,"image","transform","float32"),o=(0,c.YT)(t,"transforms","transform","float32");d.vA(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),d.vA(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),d.vA(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const h={image:i,transforms:o},p={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return l.T2.runKernel(u.dLy,h,p)}}),Ur=(0,h.op)({bandPart_:function(e,t,n){const r=(0,c.YT)(e,"a","bandPart");(0,d.vA)(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"==typeof t?((0,d.vA)(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),(0,d.vA)(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=(0,c.YT)(t<0?a:t,"numLower","bandPart")):((0,d.vA)("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=(0,Xn._)((0,ze.M)(t,0),a,(0,dt.B)(t,a))),"number"==typeof n?((0,d.vA)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),(0,d.vA)(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=(0,c.YT)(n<0?i:n,"numUpper","bandPart")):((0,d.vA)("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=(0,Xn._)((0,ze.M)(n,0),i,(0,dt.B)(n,i)));const u=(0,I.t)(Zt(0,a,1,"int32"),[-1,1]),h=Zt(0,i,1,"int32"),p=(0,gt.j)(u,h),f=(0,Ze.n)((0,Be.I)(p,o),(0,De.D)(p,(0,vt.H)(l))),m=(0,er.U)([a,i],r.dtype);return(0,I.t)((0,Cn.t)((0,Zn.K)((0,I.t)(r,[-1,a,i])).map((e=>(0,Xn._)(f,e,m)))),s)}}),jr=(0,h.op)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,(0,d.vA)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)(0,d.vA)(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=(0,Tn.l)(e,e.shape[0],0).map((e=>(0,An.r)(e,[0])));(0,d.vA)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(l.T2.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=(0,N.l)((0,On.c)((0,N.l)(n[r],e)),n[r]);e=(0,gt.j)(e,t)}return(0,fe.y)(e,(0,sr.x)(e,"euclidean"))})));return t?(0,Cn.t)(n,0):n}});var Wr=n(4917);function Gr(e,t=!1){return l.T2.tidy((()=>{(0,d.vA)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=Ee(n),a=(0,q.o)(e);const i=Ln([[1]],[1,1]);let o=(0,q.o)(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=a,u=o,c=s;[o,a,s]=l.T2.tidy((()=>{const t=(0,O.d)(a,[e,e],[n-e,1]),l=(0,sr.x)(t),u=(0,O.d)(a,[e,e],[1,1]),c=(0,Xn._)((0,Oe.r)(u,0),Ln([[-1]]),Ln([[1]])),d=(0,gt.j)(u,(0,N.l)(c,l)),h=(0,fe.y)(t,d);o=1===h.shape[0]?(0,q.o)(i):(0,A.x)([i,(0,O.d)(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=(0,vt.H)((0,fe.y)((0,C.N)(c,d),l)),f=(0,O.d)(a,[e,0],[n-e,r]),m=(0,N.l)(p,o),g=(0,rr.m)(o);if(0===e)a=(0,gt.j)(f,(0,C.N)(m,(0,C.N)(g,f)));else{const t=(0,gt.j)(f,(0,C.N)(m,(0,C.N)(g,f)));a=(0,A.x)([(0,O.d)(a,[0,0],[e,r]),t],0)}const b=(0,rr.m)(m),y=(0,O.d)(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=(0,gt.j)(y,(0,C.N)((0,C.N)(y,o),b));else{const t=(0,gt.j)(y,(0,C.N)((0,C.N)(y,o),b));s=(0,A.x)([(0,O.d)(s,[0,0],[n,e]),t],1)}return[o,a,s]})),(0,Wr.AS)([t,u,c])}return!t&&n>r&&(s=(0,O.d)(s,[0,0],[n,r]),a=(0,O.d)(a,[0,0],[r,r])),[s,a]}))}const Hr=(0,h.op)({qr_:function(e,t=!1){if((0,d.vA)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Gr(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=(0,Zn.K)((0,I.t)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];return r.forEach((e=>{const[n,r]=Gr(e,t);s.push(n),a.push(r)})),[(0,I.t)((0,Cn.t)(s,0),e.shape),(0,I.t)((0,Cn.t)(a,0),e.shape)]}}});var qr=n(7506);const Zr=(0,h.op)({computeWeightedLoss_:function(e,t,n=qr.i.SUM_BY_NONZERO_WEIGHTS){const r=(0,c.YT)(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=(0,c.YT)(t,"weights","computeWeightedLoss"));const a=null==s?r:(0,N.l)(r,s);if(n===qr.i.NONE)return a;if(n===qr.i.SUM)return(0,On.c)(a);if(n===qr.i.MEAN){if(null==s)return(0,it.i)(a);{const e=r.size/s.size,t=(0,fe.y)((0,On.c)(a),(0,On.c)(s));return e>1?(0,fe.y)(t,(0,on.d)(e)):t}}if(n===qr.i.SUM_BY_NONZERO_WEIGHTS){if(null==s)return(0,fe.y)((0,On.c)(a),(0,on.d)(r.size));{const e=(0,N.l)(s,(0,ot.S)(r.shape)),t=(0,S.w)((0,On.c)((0,xt.E)(e,(0,on.d)(0))),"float32");return(0,fe.y)((0,On.c)(a),t)}}throw Error(`Unknown reduction: ${n}`)}}),Kr=(0,h.op)({absoluteDifference_:function(e,t,n,r=qr.i.SUM_BY_NONZERO_WEIGHTS){const a=(0,c.YT)(e,"labels","absoluteDifference"),i=(0,c.YT)(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=(0,c.YT)(n,"weights","absoluteDifference")),(0,d.O3)(a.shape,i.shape,"Error in absoluteDifference: ");const l=(0,s.t)((0,gt.j)(a,i));return Zr(l,o,r)}}),Yr=(0,h.op)({cosineDistance_:function(e,t,n,r,s=qr.i.SUM_BY_NONZERO_WEIGHTS){const a=(0,c.YT)(e,"labels","cosineDistance"),i=(0,c.YT)(t,"predictions","cosineDistance");let o=null;null!=r&&(o=(0,c.YT)(r,"weights","cosineDistance")),(0,d.O3)(a.shape,i.shape,"Error in cosineDistance: ");const l=(0,on.d)(1),u=(0,gt.j)(l,(0,On.c)((0,N.l)(a,i),n,!0));return Zr(u,o,s)}}),Xr=(0,h.op)({hingeLoss_:function(e,t,n,r=qr.i.SUM_BY_NONZERO_WEIGHTS){let s=(0,c.YT)(e,"labels","hingeLoss");const a=(0,c.YT)(t,"predictions","hingeLoss");let i=null;null!=n&&(i=(0,c.YT)(n,"weights","hingeLoss")),(0,d.O3)(s.shape,a.shape,"Error in hingeLoss: ");const o=(0,on.d)(1);s=(0,gt.j)((0,N.l)((0,on.d)(2),s),o);const l=(0,Xt.V)((0,gt.j)(o,(0,N.l)(s,a)));return Zr(l,i,r)}}),Qr=(0,h.op)({huberLoss_:function(e,t,n,r=1,a=qr.i.SUM_BY_NONZERO_WEIGHTS){const i=(0,c.YT)(e,"labels","huberLoss"),l=(0,c.YT)(t,"predictions","huberLoss");let u=null;null!=n&&(u=(0,c.YT)(n,"weights","huberLoss")),(0,d.O3)(i.shape,l.shape,"Error in huberLoss: ");const h=(0,on.d)(r),p=(0,s.t)((0,gt.j)(l,i)),f=(0,dt.B)(p,h),m=(0,gt.j)(p,f),g=(0,o.W)((0,N.l)((0,on.d)(.5),(0,mt.E)(f)),(0,N.l)(h,m));return Zr(g,u,a)}}),Jr=(0,h.op)({logLoss_:function(e,t,n,r=1e-7,s=qr.i.SUM_BY_NONZERO_WEIGHTS){const a=(0,c.YT)(e,"labels","logLoss"),i=(0,c.YT)(t,"predictions","logLoss");let l=null;null!=n&&(l=(0,c.YT)(n,"weights","logLoss")),(0,d.O3)(a.shape,i.shape,"Error in logLoss: ");const u=(0,on.d)(1),h=(0,on.d)(r),p=(0,vt.H)((0,N.l)(a,(0,je.R)((0,o.W)(i,h)))),f=(0,N.l)((0,gt.j)(u,a),(0,je.R)((0,o.W)((0,gt.j)(u,i),h))),m=(0,gt.j)(p,f);return Zr(m,l,s)}}),es=(0,h.op)({meanSquaredError_:function(e,t,n,r=qr.i.SUM_BY_NONZERO_WEIGHTS){const s=(0,c.YT)(e,"labels","meanSquaredError"),a=(0,c.YT)(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=(0,c.YT)(n,"weights","meanSquaredError")),(0,d.O3)(s.shape,a.shape,"Error in meanSquaredError: ");const o=(0,En.P)(s,a);return Zr(o,i,r)}}),ts=(0,h.op)({sigmoidCrossEntropy_:function(e,t,n,r=0,a=qr.i.SUM_BY_NONZERO_WEIGHTS){let i=(0,c.YT)(e,"multiClassLabels","sigmoidCrossEntropy");const l=(0,c.YT)(t,"logits","sigmoidCrossEntropy");let u=null;if(null!=n&&(u=(0,c.YT)(n,"weights","sigmoidCrossEntropy")),(0,d.O3)(i.shape,l.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=(0,on.d)(r),t=(0,on.d)(1),n=(0,on.d)(.5);i=(0,o.W)((0,N.l)(i,(0,gt.j)(t,e)),(0,N.l)(n,e))}const h=function(e,t){const n=(0,c.YT)(e,"labels","sigmoidCrossEntropyWithLogits"),r=(0,c.YT)(t,"logits","sigmoidCrossEntropyWithLogits");(0,d.O3)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=(0,Xt.V)(r),i=(0,N.l)(r,n),l=(0,We.K)((0,ke.o)((0,vt.H)((0,s.t)(r))));return(0,o.W)((0,gt.j)(a,i),l)}(i,l);return Zr(h,u,a)}}),ns=(0,h.op)({softmaxCrossEntropy_:function(e,t,n,r=0,s=qr.i.SUM_BY_NONZERO_WEIGHTS){let a=(0,c.YT)(e,"onehotLabels","softmaxCrossEntropy");const i=(0,c.YT)(t,"logits","softmaxCrossEntropy");let l=null;if(null!=n&&(l=(0,c.YT)(n,"weights","softmaxCrossEntropy")),(0,d.O3)(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=(0,on.d)(r),t=(0,on.d)(1),n=(0,on.d)(a.shape[1]);a=(0,o.W)((0,N.l)(a,(0,gt.j)(t,e)),(0,fe.y)(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=(0,fr._X)(((e,t,r)=>{const s=(0,qe.V)(t,[n],!0),a=(0,gt.j)((0,S.w)(t,"float32"),s);r([e,a]);const i=(0,vt.H)((0,N.l)(a,e));return{value:(0,On.c)(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=(0,ft.SM)(e.shape,[n]);return[(0,N.l)((0,I.t)(e,a),(0,gt.j)((0,S.w)(r,"float32"),(0,ke.o)(s))),(0,N.l)((0,I.t)(e,a),(0,gt.j)((0,ke.o)(s),(0,S.w)(r,"float32")))]}}}));return r(e,t)}(a,i);return Zr(u,l,s)}}),rs=(0,h.op)({sparseFillEmptyRows_:function(e,t,n,r){const s=(0,c.YT)(e,"indices","sparseFillEmptyRows","int32"),a=(0,c.YT)(t,"values","sparseFillEmptyRows"),i=(0,c.YT)(n,"denseShape","sparseFillEmptyRows","int32"),o=(0,c.YT)(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const d={indices:s,values:a,denseShape:i,defaultValue:o},h=l.T2.runKernel(u.C8s,d);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}}),ss=(0,h.op)({sparseReshape_:function(e,t,n){const r=(0,c.YT)(e,"inputIndices","sparseReshape","int32"),s=(0,c.YT)(t,"inputShape","sparseReshape","int32"),a=(0,c.YT)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=l.T2.runKernel(u.BoJ,i);return{outputIndices:o[0],outputShape:o[1]}}}),as=(0,h.op)({sparseSegmentMean_:function(e,t,n){const r=(0,c.YT)(e,"data","sparseSegmentMean"),s=(0,c.YT)(t,"indices","sparseSegmentMean","int32"),a=(0,c.YT)(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return l.T2.runKernel(u.L6G,i)}}),is=(0,h.op)({sparseSegmentSum_:function(e,t,n){const r=(0,c.YT)(e,"data","sparseSegmentSum"),s=(0,c.YT)(t,"indices","sparseSegmentSum","int32"),a=(0,c.YT)(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return l.T2.runKernel(u.DvZ,i)}}),os=(0,h.op)({stringNGrams_:function(e,t,n,r,s,a,i,o){const d=(0,c.YT)(e,"data","stringNGrams","string");if("string"!==d.dtype)throw new Error("Data must be of datatype string");if(1!==d.shape.length)throw new Error(`Data must be a vector, saw: ${d.shape}`);const h=(0,c.YT)(t,"dataSplits","stringNGrams");if("int32"!==h.dtype)throw new Error("Data splits must be of datatype int32");const p={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},f={data:d,dataSplits:h},m=l.T2.runKernel(u.YAb,f,p);return{nGrams:m[0],nGramsSplits:m[1]}}}),ls=(0,h.op)({stringSplit_:function(e,t,n=!0){const r=(0,c.YT)(e,"input","stringSplit","string"),s=(0,c.YT)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=l.T2.runKernel(u.iW0,i,a);return{indices:o[0],values:o[1],shape:o[2]}}}),us=(0,h.op)({stringToHashBucketFast_:function(e,t){const n=(0,c.YT)(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return l.T2.runKernel(u.$jE,s,r)}}),cs=(0,h.op)({staticRegexReplace_:function(e,t,n,r=!0){const s=(0,c.YT)(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return l.T2.runKernel(u.GZp,{x:s},a)}}),ds={fft:xn.h,ifft:_n.K,rfft:Sn.z,irfft:kn.g},hs={hammingWindow:Sr,hannWindow:Tr,frame:Ir,stft:Er},ps={flipLeftRight:Cr,grayscaleToRGB:Nr,resizeNearestNeighbor:zr.b,resizeBilinear:Pr.v,rgbToGrayscale:$r,rotateWithOffset:Or,cropAndResize:Ar,nonMaxSuppression:Fr,nonMaxSuppressionAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=(0,c.YT)(e,"boxes","nonMaxSuppressionAsync"),i=(0,c.YT)(t,"scores","nonMaxSuppressionAsync"),o=Dr(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:h}=(0,Rr.c7)(u,d,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Mn(h,"int32")},nonMaxSuppressionWithScore:Mr,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=(0,c.YT)(e,"boxes","nonMaxSuppressionAsync"),o=(0,c.YT)(t,"scores","nonMaxSuppressionAsync"),l=Dr(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),d=u[0],h=u[1],{selectedIndices:p,selectedScores:f}=(0,Rr.ut)(d,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Mn(p,"int32"),selectedScores:Mn(f)}},nonMaxSuppressionPadded:Lr,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=(0,c.YT)(e,"boxes","nonMaxSuppressionAsync"),o=(0,c.YT)(t,"scores","nonMaxSuppressionAsync"),l=Dr(i,o,n,r,s,null),u=l.maxOutputSize,d=l.iouThreshold,h=l.scoreThreshold,[p,f]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:g}=(0,Rr.ZS)(p,f,u,d,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Mn(m,"int32"),validOutputs:(0,on.d)(g,"int32")}},threshold:Br,transform:Vr},fs={bandPart:Ur,gramSchmidt:jr,qr:Hr},ms={absoluteDifference:Kr,computeWeightedLoss:Zr,cosineDistance:Yr,hingeLoss:Xr,huberLoss:Qr,logLoss:Jr,meanSquaredError:es,sigmoidCrossEntropy:ts,softmaxCrossEntropy:ns},gs={sparseFillEmptyRows:rs,sparseReshape:ss,sparseSegmentMean:as,sparseSegmentSum:is},bs={stringNGrams:os,stringSplit:ls,stringToHashBucketFast:us,staticRegexReplace:cs}},6023:(e,t,n)=>{"use strict";n.d(t,{e:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({pad_:function(e,t,n=0){const i=(0,a.YT)(e,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},l={x:i};return r.T2.runKernel(s.ODT,l,o)}})},7606:(e,t,n)=>{"use strict";n.d(t,{d:()=>h});var r=n(7243),s=n(6689),a=n(9303),i=n(610),o=n(8785),l=n(689),u=n(779),c=n(6584),d=n(4926);const h=(0,u.op)({pool_:function(e,t,n,u,h,p,f){null==h&&(h=[1,1]),null==p&&(p=1),0===u&&(u="valid");const m=(0,r.YT)(e,"x","maxPool");let g=m,b=!1;3===m.rank&&(b=!0,g=(0,c.t)(m,[1,m.shape[0],m.shape[1],m.shape[2]])),s.vA(o.G0(p,h),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${p} and dilations '${h}'`));const y=o.E6(g.shape,t,p,h,u),w=[y.dilationHeight,y.dilationWidth];let v;v="same"===u?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),s=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],s[t]]))}([y.filterHeight,y.filterWidth],w):[[0,0],[0,0]];const x=1===w[0]&&1===w[1],[_,k]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t]));return[t.map(((e,t)=>[r[t],o[t]])),t.map(((e,t)=>[0,i[t]]))]}([y.inHeight,y.inWidth],w,v),S=x?u:"valid",T=x?g:(0,d.e)(g,w,_),I=("avg"===n?()=>(0,a.$)(T,t,p,S,f):()=>(0,l.j)(T,t,p,S,f))(),E=x?I:(0,i.G)(I,w,k);return b?(0,c.t)(E,[E.shape[1],E.shape[2],E.shape[3]]):E}})},6712:(e,t,n)=>{"use strict";n.d(t,{n:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({pow_:function(e,t){let n=(0,i.YT)(e,"base","pow"),o=(0,i.YT)(t,"exp","pow");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.pyJ,l)}})},5368:(e,t,n)=>{"use strict";n.d(t,{N:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({prelu_:function(e,t){const n={x:(0,a.YT)(e,"x","prelu"),alpha:(0,a.YT)(t,"alpha","prelu")};return r.T2.runKernel(s.Ncv,n)}})},7905:(e,t,n)=>{"use strict";function r(e,t=!1){console.log(e.toString(t))}n.d(t,{y:()=>r})},2105:(e,t,n)=>{"use strict";n.d(t,{_:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(3583);const o=(0,n(779).op)({prod_:function(e,t=null,n=!1){let o=(0,a.YT)(e,"x","prod");"bool"===o.dtype&&(o=(0,i.w)(o,"int32"));const l={x:o},u={axis:t,keepDims:n};return r.T2.runKernel(s.kdj,l,u)}})},8440:(e,t,n)=>{"use strict";n.d(t,{x:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({real_:function(e){const t={input:(0,a.YT)(e,"input","real")};return r.T2.runKernel(s.LRy,t)}})},104:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({reciprocal_:function(e){const t={x:(0,a.YT)(e,"x","reciprocal")};return r.T2.runKernel(s.huO,t)}})},5738:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({relu_:function(e){const t={x:(0,a.YT)(e,"x","relu")};return r.T2.runKernel(s.fUj,t)}})},1958:(e,t,n)=>{"use strict";n.d(t,{j:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({relu6_:function(e){const t={x:(0,a.YT)(e,"x","relu6")};return r.T2.runKernel(s.P_L,t)}})},6584:(e,t,n)=>{"use strict";n.d(t,{t:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({reshape_:function(e,t){const n={x:(0,a.YT)(e,"x","reshape","string_or_numeric")},i={shape:t};return r.T2.runKernel(s.R23,n,i)}})},4032:(e,t,n)=>{"use strict";n.d(t,{B:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({reverse_:function(e,t){const n={x:(0,a.YT)(e,"x","reverse")},i={dims:t};return r.T2.runKernel(s.D7i,n,i)}})},9646:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({round_:function(e){const t={x:(0,a.YT)(e,"x","round")};return r.T2.runKernel(s.hVg,t)}})},882:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({rsqrt_:function(e){const t={x:(0,a.YT)(e,"x","rsqrt","float32")};return r.T2.runKernel(s.TOR,t)}})},9e3:(e,t,n)=>{"use strict";n.d(t,{d:()=>a});var r=n(7343),s=n(2061);function a(e,t){if(((0,r.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.isTypedArray)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,s.Q)(e,[],[],t)}},9684:(e,t,n)=>{"use strict";n.r(t),n.d(t,{calculateShapes:()=>i,validateInput:()=>a,validateUpdateShape:()=>s});var r=n(6689);function s(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function a(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}s(n,t,e)}function i(e,t,n){const s=t.shape.length,a=s>1?t.shape[s-1]:1,i=n.length;let o=1;for(let e=a;e<i;++e)o*=n[e];const l=a<1?1:a;return{sliceRank:a,numUpdates:(0,r.Ze)(t.shape)/l,sliceSize:o,strides:[...(0,r.Ur)(n.slice(0,a)),1],outputSize:(0,r.Ze)(n)}}},7703:(e,t,n)=>{"use strict";n.d(t,{W:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({selu_:function(e){const t={x:(0,a.YT)(e,"x","selu")};return r.T2.runKernel(s.u$b,t)}})},3130:(e,t,n)=>{"use strict";n.d(t,{X:()=>s,j:()=>r});const r=1.7580993408473768,s=1.0507009873554805},9348:(e,t,n)=>{"use strict";n.d(t,{w:()=>u});var r=n(7243),s=n(6689),a=n(4300),i=n(1490),o=n(779),l=n(6584);const u=(0,o.op)({separableConv2d_:function(e,t,n,o,u,c=[1,1],d="NHWC"){const h=(0,r.YT)(e,"x","separableConv2d"),p=(0,r.YT)(t,"depthwiseFilter","separableConv2d"),f=(0,r.YT)(n,"pointwiseFilter","separableConv2d");let m=h,g=!1;if(3===h.rank&&(g=!0,m=(0,l.t)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===d)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");s.vA(4===m.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${m.rank}.`)),s.vA(4===p.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`)),s.vA(4===f.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`)),s.vA(1===f.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${f.shape[0]}.`)),s.vA(1===f.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${f.shape[1]}.`));const b=p.shape[2],y=p.shape[3];s.vA(f.shape[2]===b*y,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${b*y}, but got ${f.shape[2]}.`));const w=(0,i.G)(m,p,o,u,d,c),v=(0,a.X)(w,f,1,"valid",d);return g?(0,l.t)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},6118:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({sigmoid_:function(e){const t={x:(0,a.YT)(e,"x","sigmoid","float32")};return r.T2.runKernel(s.vI1,t)}})},5525:(e,t,n)=>{"use strict";n.d(t,{_:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({sign_:function(e){const t={x:(0,a.YT)(e,"x","sign")};return r.T2.runKernel(s.YVe,t)}})},56:(e,t,n)=>{"use strict";n.d(t,{F:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({sin_:function(e){const t={x:(0,a.YT)(e,"x","sin","float32")};return r.T2.runKernel(s.hql,t)}})},2306:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({sinh_:function(e){const t={x:(0,a.YT)(e,"x","sinh")};return r.T2.runKernel(s.J3C,t)}})},9340:(e,t,n)=>{"use strict";n.d(t,{d:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({slice_:function(e,t,n){const i=(0,a.YT)(e,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");const o={x:i},l={begin:t,size:n};return r.T2.runKernel(s.JiE,o,l)}})},2955:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertParamsValid:()=>i,computeFlatOffset:()=>w,computeOutShape:()=>l,getNormalizedAxes:()=>h,isSliceContinous:()=>y,maskToAxes:()=>o,parseSliceParams:()=>v,sliceInfo:()=>x,startForAxis:()=>g,startIndicesWithElidedDims:()=>p,stopForAxis:()=>b,stopIndicesWithElidedDims:()=>f,stridesForAxis:()=>m,stridesWithElidedDims:()=>u});var r=n(6689);const s=-2,a=-1;function i(e,t,n){const s=e.shape.length;r.vA(s===t.length,(()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)),r.vA(s===n.length,(()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`));for(let a=0;a<s;++a)r.vA(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${s}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function o(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function l(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function u(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function c(e,t,n){return n<=e?n:n-(t-1)}function d(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function h(e,t,n,r,s,a,i,o,l){const c=e.length;let d=new Array(c),h=new Array(c),y=new Array(c);if(t.length&&n>0){const l=t[0],c=n+1;d=p(i,l,c,r,e),h=f(o,l,c,s,e),y=u(a,l,c,e)}else for(let t=0;t<c;t++)d[t]=g(i,r,a,e,t,l),h[t]=b(o,s,a,e,t,l),y[t]=m(a,t,l);return{begin:d,end:h,strides:y}}function p(e,t,n,r,s){const a=[...s],i=d(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=c(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function f(e,t,n,s,a){const i=[...a],o=d(n,t);for(let r=0;r<i.length;r++)if(o.indexOf(r)>-1)i[r]=Number.MAX_SAFE_INTEGER;else{const a=c(t,n,r);let o=s[a];e&1<<a&&(o=Number.MAX_SAFE_INTEGER),i[r]=o}for(let e=0;e<i.length;e++){const t=a[e];i[e]<0&&(i[e]+=t),i[e]=r.qE(0,i[e],a[e])}return i}function m(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function g(e,t,n,s,a,i){let o=t[a];const l=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=s[a];return o<0&&(o+=u),o=r.qE(0,o,u-1),o}function b(e,t,n,s,a,i){let o=t[a];const l=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[a];return o<0&&(o+=u),o=l>0?r.qE(0,o,u):r.qE(-1,o,u-1),o}function y(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function w(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function v(e,t,n){let s;const a=e.shape.length;let i;return s="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),s.forEach((e=>{r.vA(-1!==e,(()=>"slice() does not support negative begin indexing."))})),i=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,i=i.map(((t,n)=>t>=0?t:(r.vA(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-s[n]))),[s,i]}function x(e,t,n,r,i,o,l,u,c){let d;if(null==r?(d=new Array(t.length),d.fill(1)):d=r,null!=l&&l&l-1)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const p={dims:d.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:d.slice(),beginMask:i,endMask:o,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:c};for(let e=0;e<p.dims;e++)h&&1<<e&u&&p.numAddAxisAfterEllipsis++,1<<e&l&&(h=!0);h||(p.ellipsisMask|=1<<p.dims,p.dims++);const f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(s),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(a),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(p,f);let m=!0,g=!0,b=!0;const y=[],w=[];for(let t=0;t<e.length;++t){if(0===f.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(f.shrinkAxisMask&1<<t),r=e[t];if(-1===r){y.push(n?1:-1);continue}const s=[f.beginMask&1<<t,f.endMask&1<<t],a=[f.strides[t]>0?0:-1,f.strides[t]>0?r:r-1];if(n&&f.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&1===f.strides[t];const i=!!(f.beginMask&1<<t&&f.endMask&1<<t);if(f.beginValid&&f.endValid){if(n){const e=f.begin[t]<0?r+f.begin[t]:f.begin[t];if(f.begin[t]=e,f.end[t]=f.begin[t]+1,e<0||e>=r)throw Error(`slice index ${f.begin[t]} of dimension ${t} out of bounds.`)}else f.begin[t]=_(f.begin[t],0,f.strides[t],r,s,a),f.end[t]=_(f.end[t],1,f.strides[t],r,s,a);const e=1===f.strides[t]&&0===f.begin[t]&&f.end[t]===r;m=m&&e,g=g&&(0===t&&1===f.strides[t]||e)}else m=m&&1===f.strides[t]&&i,g=g&&(0===t&&1===f.strides[t]||i);let o,l=!1;if(f.beginValid&&f.endValid?(o=f.end[t]-f.begin[t],l=!0):n?(o=1,l=!0):i&&r>=0&&(o=f.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=f.strides[t]<0?0:Math.trunc(o/f.strides[t])+(o%f.strides[t]!=0?1:0),y.push(e)}else y.push(-1)}for(let e=0;e<f.finalShapeGatherIndices.length;++e){const t=f.finalShapeGatherIndices[e];t>=0?w.push(y[t]):t===s&&w.push(1)}return{finalShapeSparse:w.filter(((e,t)=>f.finalShapeGatherIndices[t]!==s)),finalShape:w,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:f.begin,end:f.end,strides:f.strides}}function _(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}},6288:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({softmax_:function(e,t=-1){const n=(0,a.YT)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const i={logits:n},o={dim:t};return r.T2.runKernel(s.rFG,i,o)}})},788:(e,t,n)=>{"use strict";n.d(t,{l:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({softplus_:function(e){const t={x:(0,a.YT)(e,"x","softplus")};return r.T2.runKernel(s.Fin,t)}})},4926:(e,t,n)=>{"use strict";n.d(t,{e:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({spaceToBatchND_:function(e,t,n){const o=(0,a.YT)(e,"x","spaceToBatchND");i.vA(o.rank>=1+t.length,(()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`)),i.vA(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),i.vA(o.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const l={x:o},u={blockShape:t,paddings:n};return r.T2.runKernel(s.A8B,l,u)}})},5687:(e,t,n)=>{"use strict";n.d(t,{h:()=>i});var r=n(9936),s=n(2787),a=n(6689);const i=(0,n(779).op)({fft_:function(e){(0,a.vA)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.T2.runKernel(s.rGP,t)}})},3966:(e,t,n)=>{"use strict";n.d(t,{K:()=>i});var r=n(9936),s=n(2787),a=n(6689);const i=(0,n(779).op)({ifft_:function(e){(0,a.vA)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.T2.runKernel(s.OAQ,t)}})},1718:(e,t,n)=>{"use strict";n.d(t,{g:()=>f});var r=n(1030),s=n(4636),a=n(6490),i=n(6596),o=n(779),l=n(8440),u=n(6584),c=n(4032),d=n(9e3),h=n(9340),p=n(3966);const f=(0,o.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let o;if(t<=2){const r=(0,u.t)(e,[n,t]);o=(0,p.K)(r)}else{const f=[n,2*(t-1)],m=(0,u.t)((0,l.x)(e),[n,t]),g=(0,u.t)((0,a.n)(e),[n,t]),b=(0,c.B)((0,h.d)(m,[0,1],[n,t-2]),1),y=(0,i.l)((0,c.B)((0,h.d)(g,[0,1],[n,t-2]),1),(0,d.d)(-1)),w=(0,s.x)([m,b],1),v=(0,s.x)([g,y],1),x=(0,u.t)((0,r.f)(w,v),[f[0],f[1]]);o=(0,p.K)(x)}if(o=(0,l.x)(o),3===e.rank&&0!==e.shape[0]){const t=o,n=e.shape[0];o=(0,u.t)(o,[n,o.shape[0]/n,o.shape[1]]),t.dispose()}return o}})},2237:(e,t,n)=>{"use strict";n.d(t,{z:()=>m});var r=n(6689),s=n(1030),a=n(4636),i=n(6490),o=n(779),l=n(8440),u=n(6584),c=n(9340),d=n(4782),h=n(8529),p=n(7591),f=n(5687);const m=(0,o.op)({rfft_:function(e,t){(0,r.vA)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const o=e.size/n;let m;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,m=(0,c.d)(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,m=(0,a.x)([e,(0,h.U)(r)],e.shape.length-1),n=t}else m=e;const g=(0,p.P)(m),b=(0,u.t)((0,s.f)(m,g),[o,n]),y=(0,f.h)(b),w=Math.floor(n/2)+1,v=(0,l.x)(y),x=(0,i.n)(y),_=(0,d.l)(v,[w,n-w],v.shape.length-1),k=(0,d.l)(x,[w,n-w],x.shape.length-1),S=m.shape.slice();return S[m.shape.length-1]=w,(0,u.t)((0,s.f)(_[0],k[0]),S)}})},4782:(e,t,n)=>{"use strict";n.d(t,{l:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({split_:function(e,t,n=0){const i={x:(0,a.YT)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return r.T2.runKernel(s.Blb,i,o)}})},178:(e,t,n)=>{"use strict";n.d(t,{R:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({sqrt_:function(e){const t={x:(0,a.YT)(e,"x","sqrt","float32")};return r.T2.runKernel(s.dFH,t)}})},5935:(e,t,n)=>{"use strict";n.d(t,{E:()=>a});var r=n(9936),s=n(7243);const a=(0,n(779).op)({square_:function(e){const t=(0,s.YT)(e,"x","square");return r.T2.runKernel("Square",{x:t},{})}})},225:(e,t,n)=>{"use strict";n.d(t,{P:()=>l});var r=n(9936),s=n(2787),a=n(3031),i=n(7243),o=n(548);const l=(0,n(779).op)({squaredDifference_:function(e,t){let n=(0,i.YT)(e,"a","squaredDifference"),l=(0,i.YT)(t,"b","squaredDifference");[n,l]=(0,a.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.Ddj,u,{})}})},6758:(e,t,n)=>{"use strict";n.d(t,{r:()=>o});var r=n(7243),s=n(6689),a=n(779),i=n(6584);const o=(0,a.op)({squeeze_:function(e,t){const n=(0,r.YT)(e,"x","squeeze","string_or_numeric");return(0,i.t)(n,(0,s.gx)(n.shape,t).newShape)}})},1442:(e,t,n)=>{"use strict";n.d(t,{t:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({stack_:function(e,t=0){const n=(0,a.j1)(e,"tensors","stack","string_or_numeric");i.vA(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&i.vA(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const o=n,l={axis:t};return r.T2.runKernel(s.mM$,o,l)}})},5366:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({step_:function(e,t=0){const n={x:(0,a.YT)(e,"x","step")},i={alpha:t};return r.T2.runKernel(s.pnw,n,i)}})},5684:(e,t,n)=>{"use strict";n.d(t,{Y:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({stridedSlice_:function(e,t,n,i,o=0,l=0,u=0,c=0,d=0){const h={x:(0,a.YT)(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:i,beginMask:o,endMask:l,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:d};return r.T2.runKernel(s.UcO,h,p)}})},3136:(e,t,n)=>{"use strict";n.d(t,{j:()=>o});var r=n(9936),s=n(2787),a=n(3031),i=n(7243);const o=(0,n(779).op)({sub_:function(e,t){let n=(0,i.YT)(e,"a","sub"),o=(0,i.YT)(t,"b","sub");[n,o]=(0,a.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(s.PbM,l)}})},7917:(e,t,n)=>{"use strict";n.d(t,{c:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(3583);const o=(0,n(779).op)({sum_:function(e,t=null,n=!1){let o=(0,a.YT)(e,"x","sum");"bool"===o.dtype&&(o=(0,i.w)(o,"int32"));const l={x:o},u={axis:t,keepDims:n};return r.T2.runKernel(s.WuN,l,u)}})},845:(e,t,n)=>{"use strict";n.d(t,{M:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({tan_:function(e){const t={x:(0,a.YT)(e,"x","tan","float32")};return r.T2.runKernel(s.oFs,t)}})},8198:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({tanh_:function(e){const t={x:(0,a.YT)(e,"x","tanh","float32")};return r.T2.runKernel(s.iuW,t)}})},4233:(e,t,n)=>{"use strict";n.d(t,{O:()=>a});var r=n(7243),s=n(2061);function a(e,t,n){const a=(0,r.MZ)(e,n);return(0,s.Q)(e,t,a,n)}},1066:(e,t,n)=>{"use strict";n.d(t,{$:()=>i});var r=n(7243),s=n(6689),a=n(2061);function i(e,t,n){if((0,s.HO)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=(0,r.MZ)(e,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,a.Q)(e,t,i,n)}},2061:(e,t,n)=>{"use strict";n.d(t,{Q:()=>o});var r=n(9936),s=n(3056),a=n(6689),i=n(7343);function o(e,t,n,o){if(null==o)o=(0,a.X$)(e);else if("complex64"===o)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,s.Nw)(e)||(0,s.Oj)(e)){if("float32"!==o&&"int32"!==o)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${o}.`);return r.T2.backend.createTensorFromGPUData(e,t||n,o)}if(!(0,i.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,a.SA)(t);const e=(0,a.Ze)(t),r=(0,a.Ze)(n);(0,a.vA)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==(0,a.Ze)(t.slice(e));(0,a.vA)(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,i.isTypedArray)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==o?(0,i.toTypedArray)(e,o):(0,i.flatten)(e,[],!0),r.T2.makeTensor(e,t,o)}},4944:(e,t,n)=>{"use strict";n.d(t,{V:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({tile_:function(e,t){const n=(0,a.YT)(e,"x","tile","string_or_numeric");i.vA(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const o={x:n},l={reps:t};return r.T2.runKernel(s.FAs,o,l)}})},8244:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({topk_:function(e,t=1,n=!0){const i=(0,a.YT)(e,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=i.shape[i.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);const l={x:i},u={k:t,sorted:n},[c,d]=r.T2.runKernel(s.TBb,l,u);return{values:c,indices:d}}})},7365:(e,t,n)=>{"use strict";n.d(t,{m:()=>p});var r=n(9936),s=n(4917),a=n(2787),i=n(7243),o=n(6689),l=n(1030),u=n(6490),c=n(5428),d=n(779),h=n(8440);const p=(0,d.op)({transpose_:function(e,t,n){const d=(0,i.YT)(e,"x","transpose");if(null==t&&(t=d.shape.map(((e,t)=>t)).reverse()),o.vA(d.rank===t.length,(()=>`Error in transpose: rank of input ${d.rank} must match length of perm ${t}.`)),t.forEach((e=>{o.vA(e>=0&&e<d.rank,(()=>"All entries in 'perm' must be between 0 and "+(d.rank-1)+` but got ${t}`))})),d.rank<=1)return d.clone();const p={x:d},f={perm:t};return"complex64"===d.dtype?(0,s.DZ)((()=>{let e=(0,h.x)(d),t=(0,u.n)(d);return e=r.T2.runKernel(a.wx0,{x:e},f),t=r.T2.runKernel(a.wx0,{x:t},f),n&&(t=(0,c.H)(t)),(0,l.f)(e,t)})):r.T2.runKernel(a.wx0,p,f)}})},1211:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({unique_:function(e,t=0){const n=(0,a.YT)(e,"x","unique","string_or_numeric");(0,i.vA)(n.rank>0,(()=>"The input tensor must be at least 1D"));const o={x:n},l={axis:t},[u,c]=r.T2.runKernel(s.EwU,o,l);return{values:u,indices:c}}})},1896:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({unsortedSegmentSum_:function(e,t,n){const o=(0,a.YT)(e,"x","unsortedSegmentSum"),l=(0,a.YT)(t,"segmentIds","unsortedSegmentSum","int32");(0,i.vA)((0,i.E6)(n),(()=>"numSegments must be of dtype int"));const u={x:o,segmentIds:l},c={numSegments:n};return r.T2.runKernel(s.pPe,u,c)}})},2223:(e,t,n)=>{"use strict";n.d(t,{K:()=>o});var r=n(9936),s=n(2787),a=n(7243),i=n(6689);const o=(0,n(779).op)({unstack_:function(e,t=0){const n=(0,a.YT)(e,"x","unstack","string_or_numeric");i.vA(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const o={value:n},l={axis:t};return r.T2.runKernel(s.dXR,o,l)}})},6073:(e,t,n)=>{"use strict";n.d(t,{_:()=>l});var r=n(9936),s=n(2787),a=n(7243),i=n(209),o=n(548);const l=(0,n(779).op)({where_:function(e,t,n){const l=(0,a.YT)(t,"a","where"),u=(0,a.YT)(n,"b","where"),c=(0,a.YT)(e,"condition","where","bool"),d=(0,o.assertAndGetBroadcastShape)((0,o.assertAndGetBroadcastShape)(c.shape,l.shape),u.shape),h={condition:(0,i.h)(c,d),t:(0,i.h)(l,d),e:(0,i.h)(u,d)};return r.T2.runKernel(s.l6P,h)}})},8529:(e,t,n)=>{"use strict";n.d(t,{U:()=>i});var r=n(9936),s=n(6689),a=n(1030);function i(e,t="float32"){if((0,s.SA)(e),"complex64"===t){const t=i(e,"float32"),n=i(e,"float32");return(0,a.f)(t,n)}const n=(0,s.Ty)((0,s.Ze)(e),t);return r.T2.makeTensor(n,e,t)}},7591:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(9936),s=n(2787),a=n(7243);const i=(0,n(779).op)({zerosLike_:function(e){const t={x:(0,a.YT)(e,"x","zerosLike")};return r.T2.runKernel(s.xJ3,t)}})},9094:(e,t,n)=>{"use strict";function r(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}n.d(t,{Y:()=>r})},1794:(e,t,n)=>{"use strict";n.d(t,{qY:()=>x,yl:()=>f,rT:()=>k,tp:()=>_,B4:()=>v,Q5:()=>w,qP:()=>y});var r=n(9245),s=n(6689);const a=20,i=3,o=7;function l(e,t,n,r){const a=(0,s.Ur)(t),i=function(e,t,n,r){const a=(0,s.Ze)(t),i=r[r.length-1],o=new Array(i).fill(0),l=t.length,c="complex64"===n?h(e):e;if(l>1)for(let e=0;e<a/i;e++){const t=e*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],u(c[t+e],0,n).length)}return o}(e,t,n,a),o=t.length,l=d(e,t,n,a,i),c=["Tensor"];return r&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map((e=>"    "+e)).join("\n")),c.join("\n")}function u(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(o))} + ${parseFloat(e[1].toFixed(o))}j`:(0,s.Kg)(e)?`'${e}'`:"bool"===n?c(e):parseFloat(e.toFixed(o)).toString(),(0,s.av)(r,t)}function c(e){return 0===e?"false":"true"}function d(e,t,n,r,s,o=!0){const l="complex64"===n?2:1,p=t[0],f=t.length;if(0===f)return"complex64"===n?[u(h(e)[0],0,n)]:"bool"===n?[c(e[0])]:[e[0].toString()];if(1===f){if(p>a){const t=i*l;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((p-i)*l,p*l));return"complex64"===n&&(r=h(r),a=h(a)),["["+r.map(((e,t)=>u(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>u(e,s[p-i+t],n))).join(", ")+"]"]}return["["+("complex64"===n?h(e):Array.from(e)).map(((e,t)=>u(e,s[t],n))).join(", ")+"]"]}const m=t.slice(1),g=r.slice(1),b=r[0]*l,y=[];if(p>a){for(let t=0;t<i;t++){const r=t*b,a=r+b;y.push(...d(e.slice(r,a),m,n,g,s,!1))}y.push("...");for(let t=p-i;t<p;t++){const r=t*b,a=r+b;y.push(...d(e.slice(r,a),m,n,g,s,t===p-1))}}else for(let t=0;t<p;t++){const r=t*b,a=r+b;y.push(...d(e.slice(r,a),m,n,g,s,t===p-1))}const w=2===f?",":"";y[0]="["+(p>0?y[0]+w:"");for(let e=1;e<y.length-1;e++)y[e]=" "+y[e]+w;let v=",\n";for(let e=2;e<f;e++)v+="\n";return y[y.length-1]=" "+y[y.length-1]+"]"+(o?"":v),y}function h(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var p=n(7343);class f{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=s.Ze(e),null!=n){const e=n.length;s.vA(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||s.Ab(t,this.size),this.strides=(0,s.Ur)(e)}set(e,...t){0===t.length&&(t=[0]),s.vA(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return m().makeTensor(this.values,this.shape,this.dtype)}}let m=null,g=null,b=null;function y(e){m=e}function w(e){g=e}function v(e){b=e}class x{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=s.Ze(e),this.strides=(0,s.Ur)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return g.buffer(this.shape,this.dtype,e)}bufferSync(){return g.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,s.yw)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,s.yw)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=m().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>p.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),m().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=m().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>p.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await m().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),m().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return g.print(this,e)}clone(){return this.throwIfDisposed(),g.clone(this)}toString(e=!1){return l(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),g.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),m().makeVariable(this,e,t,n)}}function _(){return(0,r.m)("Tensor",(()=>x))}Object.defineProperty(x,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),_();class k extends x{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!s.r1(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);m().disposeTensor(this),this.dataId=e.dataId,m().incRef(this,null)}dispose(){m().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(k,Symbol.hasInstance,{value:e=>e instanceof x&&null!=e.assign&&e.assign instanceof Function})},3031:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertTypesMatch:()=>o,getTensorsInContainer:()=>u,isTensorInList:()=>l,makeTypesMatch:()=>i});var r=n(1794),s=n(3056),a=n(6689);function i(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,s.Tu)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function o(e,t){(0,a.vA)(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function l(e,t){return t.some((t=>t.id===e.id))}function u(e){const t=[];return c(e,t,new Set),t}function c(e,t,n){if(null==e)return;if(e instanceof r.qY)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const a=e;for(const e in a){const r=a[e];n.has(r)||(n.add(r),c(r,t,n))}}},7243:(e,t,n)=>{"use strict";n.d(t,{MZ:()=>u,YT:()=>h,j1:()=>p});var r=n(9936),s=n(3772),a=n(1794),i=n(3056),o=n(7343),l=n(6689);function u(e,t){let n=e;if((0,o.isTypedArray)(e))return"string"===t?[]:[e.length];if((0,i.Oj)(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if((0,i.Nw)(e))return[e.buffer.size/(null==t?4:(0,l.jv)(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||(0,o.isTypedArray)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,s._K)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&c(e,r,[]),r}function c(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,o.isTypedArray)(e))return void(0,l.vA)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,l.vA)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,l.vA)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)c(e[t],r,n.concat(t))}function d(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function h(e,t,n,s="numeric"){if(e instanceof(0,a.tp)())return d(s,e.dtype,t,n),e;let i=(0,l.X$)(e);if("string"!==i&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),d(s,i,t,n),null==e||!(0,o.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const c=u(e,i);(0,o.isTypedArray)(e)||Array.isArray(e)||(e=[e]);const h="string"!==i?(0,o.toTypedArray)(e,i):(0,o.flatten)(e,[],!0);return r.T2.makeTensor(h,c,i)}function p(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>h(e,`${t}[${s}]`,n,r)))}},3056:(e,t,n)=>{"use strict";var r,s,a,i,o;n.d(t,{Nw:()=>h,Oj:()=>d,Tu:()=>u,ch:()=>c,rg:()=>r}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(a||(a={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(i||(i={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(o||(o={}));const l={float32:i,int32:s,bool:a,complex64:o};function u(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return l[e][t]}function c(e){return u(e,"int32")}function d(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function h(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}},7343:(e,t,n)=>{"use strict";n.r(t),n.d(t,{arraysEqual:()=>a.r1,arraysEqualWithNull:()=>a.e_,assert:()=>a.vA,assertNonNegativeIntegerDimensions:()=>a.SA,assertNonNull:()=>a.HO,assertShapesMatch:()=>a.O3,bytesFromStringArray:()=>a.SL,bytesPerElement:()=>a.jv,checkConversionForErrors:()=>a.nd,clamp:()=>a.qE,computeStrides:()=>a.Ur,convertBackendValuesAndArrayBuffer:()=>a.o2,createScalarValue:()=>v,createShuffledIndices:()=>a.P8,decodeString:()=>T,distSquared:()=>a.oO,encodeString:()=>S,fetch:()=>k,fingerPrint64:()=>w,flatten:()=>E,getArrayFromDType:()=>a.Ab,getTypedArrayFromDType:()=>a.ce,hasEncodingLoss:()=>a.BE,hexToLong:()=>l,indexToLoc:()=>a._k,inferDtype:()=>a.X$,inferFromImplicitShape:()=>a.XT,isBoolean:()=>a.Lm,isFunction:()=>a.Tn,isInt:()=>a.E6,isNumber:()=>a.Et,isPromise:()=>a.yL,isScalarShape:()=>a.Sf,isString:()=>a.Kg,isTypedArray:()=>I,isValidDtype:()=>a.xn,locToIndex:()=>a.sX,makeOnesTypedArray:()=>a.FZ,makeZerosNestedTypedArray:()=>a.c7,makeZerosTypedArray:()=>a.Ty,nearestDivisor:()=>a.lK,nearestLargerEven:()=>a.eV,now:()=>_,parseAxisParam:()=>a.Y6,randUniform:()=>a.so,repeatedTry:()=>a._q,rightPad:()=>a.av,shuffle:()=>a.k4,shuffleCombo:()=>a.a0,sizeFromShape:()=>a.Ze,sizeToSquarishShape:()=>a.gS,squeezeShape:()=>a.gx,sum:()=>a.cz,swap:()=>a.wg,tanh:()=>a.ym,toNestedArray:()=>a.yw,toTypedArray:()=>x});var r=n(3772),s=n(9094),a=n(6689),i=n(9620);const o=n.n(i)()||i;function l(e){return o.fromString(e,!0,16)}const u=l("c3a5c85c97cb3127"),c=l("b492b66fbe98f273"),d=l("9ae16a3b2f90404f");function h(e){return e.xor(e.shru(47))}function p(e,t,n){const r=e.slice(t,t+n);return o.fromBytes(Array.from(r),!0,!0)}function f(e,t){return p(e,t,8)}function m(e,t){return p(e,t,4)}function g(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function b(e,t,n=l("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function y(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=g(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(g(s,44)),[s.add(r),a.add(i)]}(f(e,t),f(e,t+8),f(e,t+16),f(e,t+24),n,r)}function w(e,t=e.length){const n=o.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=d.add(2*t),r=f(e,0).add(d),s=f(e,t-8);return b(g(s,37).mul(n).add(r),g(r,25).add(s).mul(n),n)}if(t>=4){const n=d.add(2*t);return b(m(e,0).shl(3).add(t),m(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return h(d.mul(n).xor(u.mul(r))).mul(d)}return d}(e,t):function(e,t=e.length){const n=d.add(2*t),r=f(e,0).mul(c),s=f(e,8),a=f(e,t-8).mul(n),i=f(e,t-16).mul(d);return b(g(r.add(s),43).add(g(a,30)).add(i),r.add(g(s.add(d),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=d.add(2*t),r=f(e,0).mul(d),s=f(e,8),a=f(e,t-8).mul(n),i=f(e,t-16).mul(d),o=g(r.add(s),43).add(g(a,30)).add(i),l=b(o,r.add(g(s.add(d),18)).add(a),n),u=f(e,16).mul(n),c=f(e,24),h=o.add(f(e,t-32)).mul(n),p=l.add(f(e,t-24)).mul(n);return b(g(u.add(c),43).add(g(h,30)).add(p),u.add(g(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(c).add(113),a=h(s.mul(d).add(113)).mul(d),i=[o.UZERO,o.UZERO],l=[o.UZERO,o.UZERO];r=r.mul(d).add(f(e,0));let p=0;const w=64*(t-1>>6),v=w+(t-1&63)-63;do{r=g(r.add(s).add(i[0]).add(f(e,p+8)),37).mul(c),s=g(s.add(i[1]).add(f(e,p+48)),42).mul(c),r=r.xor(l[1]),s=s.add(i[0]).add(f(e,p+40)),a=g(a.add(l[0]),33).mul(c),i=y(e,p,i[1].mul(c),r.add(l[0])),l=y(e,p+32,a.add(l[1]),s.add(f(e,p+16))),[a,r]=[r,a],p+=64}while(p!==w);const x=c.add(a.and(255).shl(1));return p=v,l[0]=l[0].add(t-1&63),i[0]=i[0].add(l[0]),l[0]=l[0].add(i[0]),r=g(r.add(s).add(i[0]).add(f(e,p+8)),37).mul(x),s=g(s.add(i[1]).add(f(e,p+48)),42).mul(x),r=r.xor(l[1].mul(9)),s=s.add(i[0].mul(9).add(f(e,p+40))),a=g(a.add(l[0]),33).mul(x),i=y(e,p,i[1].mul(x),r.add(l[0])),l=y(e,p+32,a.add(l[1]),s.add(f(e,p+16))),[a,r]=[r,a],b(b(i[0],l[0],x).add(h(s).mul(u)).add(a),b(i[1],l[1],x).add(r),x)}function v(e,t){return"string"===t?S(e):x([e],t)}function x(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=E(e)),(0,r._K)().getBool("DEBUG")&&a.nd(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function _(){return(0,r._K)().platform.now()}function k(e,t){return(0,r._K)().platform.fetch(e,t)}function S(e,t="utf-8"){return t=t||"utf-8",(0,r._K)().platform.encode(e,t)}function T(e,t="utf-8"){return t=t||"utf-8",(0,r._K)().platform.decode(e,t)}function I(e){return null!=(0,r._K)().platform.isTypedArray?(0,r._K)().platform.isTypedArray(e):(0,s.Y)(e)}function E(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||a.yL(e)||null==e||I(e)&&n)t.push(e);else if(Array.isArray(e)||I(e))for(let r=0;r<e.length;++r)E(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)E(e[s],t,n)}return t}},6689:(e,t,n)=>{"use strict";function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,o(e,t,n)}function s(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,o(e,n,r),o(t,n,r)}function a(e,t,n){return Math.max(e,Math.min(t,n))}function i(e){return e%2==0?e:e+1}function o(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function l(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function u(e,t){const n=Math.random();return t*n+(1-n)*e}function c(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function d(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function h(e,t,n=""){d(b(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function p(e){d(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function f(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function m(e){return 0===e.length}function g(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function b(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function y(e){return e%1==0}function w(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function v(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function x(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function _(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function k(e,t=(e=>0),n,r){return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function S(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function T(e,t){const n=t.length;return d((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),d(e.every((e=>y(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function I(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:T(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function E(e,t){return A(e,t)}function A(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function C(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function N(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function $(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function O(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function D(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function F(e){return"string"==typeof e||e instanceof String}function R(e){return"boolean"==typeof e}function M(e){return"number"==typeof e}function L(e){return Array.isArray(e)?L(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":M(e)?"float32":F(e)?"string":R(e)?"bool":"float32"}function P(e){return!!(e&&e.constructor&&e.call&&e.apply)}function z(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function B(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function V(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=V(e+t*o,i,n,r)}return s}function U(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return V(0,e,t,n)}function j(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function W(e,t){const n=G(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function G(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function H(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return U(e,new Float32Array(n));if("int32"===t)return U(e,new Int32Array(n));if("bool"===t)return U(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function q(e){e.forEach((t=>{d(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Z(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function K(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function Y(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{Ab:()=>A,BE:()=>$,E6:()=>y,Et:()=>M,FZ:()=>W,HO:()=>p,Kg:()=>F,Lm:()=>R,O3:()=>h,P8:()=>x,SA:()=>q,SL:()=>D,Sf:()=>m,Tn:()=>P,Ty:()=>G,Ur:()=>B,X$:()=>L,XT:()=>S,Y6:()=>T,Ze:()=>f,_k:()=>K,_q:()=>k,a0:()=>s,av:()=>_,c7:()=>H,ce:()=>E,cz:()=>l,eV:()=>i,e_:()=>g,gS:()=>v,gx:()=>I,jv:()=>O,k4:()=>r,lK:()=>z,nd:()=>C,o2:()=>j,oO:()=>c,qE:()=>a,r1:()=>b,sX:()=>Z,so:()=>u,vA:()=>d,wg:()=>o,xn:()=>N,yL:()=>Y,ym:()=>w,yw:()=>U})},5558:(e,t,n)=>{"use strict";n.r(t),n.d(t,{Abs:()=>c.ljI,Acos:()=>c.Vvy,Acosh:()=>c.PH8,AdadeltaOptimizer:()=>c.K$F,AdagradOptimizer:()=>c.ah4,AdamOptimizer:()=>c.FYc,AdamaxOptimizer:()=>c.oC7,Add:()=>c.OMN,AddN:()=>c.EkD,All:()=>c.u8Z,Any:()=>c.FSt,ArgMax:()=>c.Jp_,ArgMin:()=>c.p_m,Asin:()=>c.QKF,Asinh:()=>c.epO,Atan:()=>c.TyE,Atan2:()=>c.lxb,Atanh:()=>c.zP9,AvgPool:()=>c.ho8,AvgPool3D:()=>c.cS,AvgPool3DGrad:()=>c.wwC,AvgPoolGrad:()=>c.VCH,BatchMatMul:()=>c.jAQ,BatchToSpaceND:()=>c.Ik2,Bincount:()=>c.N4F,BitwiseAnd:()=>c.HNs,BroadcastArgs:()=>c.vj7,BroadcastTo:()=>c.LB5,Callback:()=>Hd,CallbackList:()=>Mi,Cast:()=>c.KXH,Ceil:()=>c.QDP,ClipByValue:()=>c.vaV,Complex:()=>c.pr3,ComplexAbs:()=>c.$zE,Concat:()=>c.$dB,Conv2D:()=>c.p2J,Conv2DBackpropFilter:()=>c.rFm,Conv2DBackpropInput:()=>c.jfg,Conv3D:()=>c.A1h,Conv3DBackpropFilterV2:()=>c.iGz,Conv3DBackpropInputV2:()=>c.gC7,Cos:()=>c.Mn0,Cosh:()=>c.MnK,CropAndResize:()=>c.MRQ,Cumprod:()=>c.jj_,Cumsum:()=>c.nY8,CustomCallback:()=>zi,DataStorage:()=>c.GJx,DenseBincount:()=>c.wNW,DepthToSpace:()=>c.TMz,DepthwiseConv2dNative:()=>c.tGH,DepthwiseConv2dNativeBackpropFilter:()=>c.X$8,DepthwiseConv2dNativeBackpropInput:()=>c.nVu,Diag:()=>c.ORI,Dilation2D:()=>c.jxD,Dilation2DBackpropFilter:()=>c.pk0,Dilation2DBackpropInput:()=>c.bP9,Draw:()=>c.XmO,ENV:()=>c.Kmu,EarlyStopping:()=>Kd,Einsum:()=>c.Qgm,Elu:()=>c.Pah,EluGrad:()=>c.rsH,Environment:()=>c.OH$,Equal:()=>c.BRl,Erf:()=>c._s9,Exp:()=>c.ox3,ExpandDims:()=>c.ybN,Expm1:()=>c.ybj,FFT:()=>c.rGP,Fill:()=>c.SQl,FlipLeftRight:()=>c.BxF,Floor:()=>c.ZgB,FloorDiv:()=>c.ElG,FromPixels:()=>c.awo,FusedBatchNorm:()=>c.i5R,FusedConv2D:()=>c.aAr,FusedDepthwiseConv2D:()=>c.T7M,GPGPUContext:()=>op.GPGPUContext,GatherNd:()=>c.O4G,GatherV2:()=>c.mxL,GraphModel:()=>Qd.k7,Greater:()=>c.XhZ,GreaterEqual:()=>c.lLS,History:()=>Pi,IFFT:()=>c.OAQ,Identity:()=>c.lzr,Imag:()=>c.dv8,InputSpec:()=>Va,IsFinite:()=>c.gIW,IsInf:()=>c.E3$,IsNan:()=>c.iPs,KernelBackend:()=>c.uI_,LRN:()=>c.jM4,LRNGrad:()=>c.ToN,LayerVariable:()=>Pa,LayersModel:()=>Po,LeakyRelu:()=>c.X0$,Less:()=>c.mIA,LessEqual:()=>c.CwD,LinSpace:()=>c.mnI,Log:()=>c.tG8,Log1p:()=>c.Cg$,LogSoftmax:()=>c.zfU,LogicalAnd:()=>c.RUm,LogicalNot:()=>c.nZd,LogicalOr:()=>c.LXA,LogicalXor:()=>c.RW8,LowerBound:()=>c.yPW,MathBackendCPU:()=>ip.MathBackendCPU,MathBackendWebGL:()=>op.MathBackendWebGL,MatrixBandPart:()=>c.WRv,Max:()=>c.VAI,MaxPool:()=>c.t3d,MaxPool3D:()=>c.ySp,MaxPool3DGrad:()=>c.cHb,MaxPoolGrad:()=>c.RXX,MaxPoolWithArgmax:()=>c.TL8,Maximum:()=>c.LDN,Mean:()=>c.g5A,Min:()=>c.lNG,Minimum:()=>c.LG0,MirrorPad:()=>c.x7F,Mod:()=>c.BLA,MomentumOptimizer:()=>c.Qu_,Multinomial:()=>c.WT3,Multiply:()=>c.xu7,Neg:()=>c.l0G,NonMaxSuppressionV3:()=>c.SDM,NonMaxSuppressionV4:()=>c.Zl4,NonMaxSuppressionV5:()=>c.e0f,NotEqual:()=>c.ylV,OP_SCOPE_SUFFIX:()=>c.BTT,OneHot:()=>c.urI,OnesLike:()=>c.LWX,Optimizer:()=>c.ELo,OptimizerConstructors:()=>c.L5p,Pack:()=>c.mM$,PadV2:()=>c.ODT,Pool:()=>c.bCz,Pow:()=>c.pyJ,Prelu:()=>c.Ncv,Prod:()=>c.kdj,RMSPropOptimizer:()=>c.PS5,RNN:()=>Wl,RaggedGather:()=>c.oJ2,RaggedRange:()=>c.CQC,RaggedTensorToTensor:()=>c.mH5,Range:()=>c.Q6t,Rank:()=>c.rgM,Real:()=>c.LRy,RealDiv:()=>c.sDr,Reciprocal:()=>c.huO,Reduction:()=>c.iDl,Relu:()=>c.fUj,Relu6:()=>c.P_L,Reshape:()=>c.R23,ResizeBilinear:()=>c.hgw,ResizeBilinearGrad:()=>c.FCQ,ResizeNearestNeighbor:()=>c.jOE,ResizeNearestNeighborGrad:()=>c.XQy,Reverse:()=>c.D7i,RotateWithOffset:()=>c.BK4,Round:()=>c.hVg,Rsqrt:()=>c.TOR,SGDOptimizer:()=>c.SYI,ScatterNd:()=>c.pJc,SearchSorted:()=>c.uWl,Select:()=>c.l6P,Selu:()=>c.u$b,Sequential:()=>Uo,Sigmoid:()=>c.vI1,Sign:()=>c.YVe,Sin:()=>c.hql,Sinh:()=>c.J3C,Slice:()=>c.JiE,Softmax:()=>c.rFG,Softplus:()=>c.Fin,SpaceToBatchND:()=>c.A8B,SparseFillEmptyRows:()=>c.C8s,SparseReshape:()=>c.BoJ,SparseSegmentMean:()=>c.L6G,SparseSegmentSum:()=>c.DvZ,SparseToDense:()=>c.jgd,SplitV:()=>c.Blb,Sqrt:()=>c.dFH,Square:()=>c.M6A,SquaredDifference:()=>c.Ddj,StaticRegexReplace:()=>c.GZp,Step:()=>c.pnw,StridedSlice:()=>c.UcO,StringNGrams:()=>c.YAb,StringSplit:()=>c.iW0,StringToHashBucketFast:()=>c.$jE,Sub:()=>c.PbM,Sum:()=>c.WuN,SymbolicTensor:()=>Ua,Tan:()=>c.oFs,Tanh:()=>c.iuW,Tensor:()=>c.qYS,TensorBuffer:()=>c.ylz,TensorScatterUpdate:()=>c.X4r,Tile:()=>c.FAs,TopK:()=>c.TBb,Transform:()=>c.dLy,Transpose:()=>c.wx0,Unique:()=>c.EwU,Unpack:()=>c.dXR,UnsortedSegmentSum:()=>c.pPe,UpperBound:()=>c.RMm,Variable:()=>c.rTt,ZerosLike:()=>c.xJ3,_FusedMatMul:()=>c.Dr,abs:()=>c.tnl,acos:()=>c.HQu,acosh:()=>c.FqL,add:()=>c.WQq,addN:()=>c.QiD,all:()=>c.Q7R,any:()=>c.bzn,argMax:()=>c.FLi,argMin:()=>c.XRg,asin:()=>c.qRo,asinh:()=>c.yHs,atan:()=>c.rYl,atan2:()=>c.FPz,atanh:()=>c.rfv,avgPool:()=>c.$jT,avgPool3d:()=>c.sub,backend:()=>c.Hs,backend_util:()=>c.backend_util,basicLSTMCell:()=>c.lZX,batchNorm:()=>c.$v7,batchNorm2d:()=>c.BFc,batchNorm3d:()=>c.kSi,batchNorm4d:()=>c.T5N,batchToSpaceND:()=>c.GTe,bincount:()=>c.HbZ,bitwiseAnd:()=>c.vjT,booleanMaskAsync:()=>c.ftb,broadcastArgs:()=>c.ROE,broadcastTo:()=>c.hOW,broadcast_util:()=>c.ZEY,browser:()=>c.TaL,buffer:()=>c.ra8,callbacks:()=>Yd,cast:()=>c.wgE,ceil:()=>c.mkO,clipByValue:()=>c.zQh,clone:()=>c.o8B,complex:()=>c.faB,concat:()=>c.xWs,concat1d:()=>c.I1m,concat2d:()=>c.RPU,concat3d:()=>c.O5O,concat4d:()=>c.P1l,constraints:()=>r,conv1d:()=>c.kA9,conv2d:()=>c.Xtf,conv2dTranspose:()=>c.wX9,conv3d:()=>c.IPL,conv3dTranspose:()=>c.jIJ,copyRegisteredKernels:()=>c.Cfv,cos:()=>c.gnS,cosh:()=>c.yIG,cosineWindow:()=>c._jP,cumprod:()=>c.Lp0,cumsum:()=>c.rCv,customGrad:()=>c._Xg,data:()=>u,denseBincount:()=>c.aOp,deprecationWarn:()=>c.fLc,depthToSpace:()=>c.Rj8,depthwiseConv2d:()=>c.Gl3,deregisterOp:()=>Qd.Ad,device_util:()=>c.eMq,diag:()=>c.smy,dilation2d:()=>c.X7t,disableDeprecationWarnings:()=>c.ISJ,dispose:()=>c.ASo,disposeVariables:()=>c.rm6,div:()=>c.y4m,divNoNan:()=>c.ek5,dot:()=>c.Omf,dropout:()=>c.EZY,einsum:()=>c._3C,elu:()=>c.Pqc,enableDebugMode:()=>c.gYU,enableProdMode:()=>c.SmG,enclosingPowerOfTwo:()=>c.FJY,engine:()=>c.Hi9,ensureShape:()=>c.QP2,env:()=>c._K2,equal:()=>c.LCg,erf:()=>c.Y12,euclideanNorm:()=>c.p4S,exp:()=>c.oNF,expandDims:()=>c.UG6,expm1:()=>c.IYd,eye:()=>c.y5U,fft:()=>c.hVP,fill:()=>c.GSj,findBackend:()=>c.goy,findBackendFactory:()=>c.W4C,floor:()=>c.RIf,floorDiv:()=>c.wh_,forceHalfFloat:()=>op.forceHalfFloat,fused:()=>c.cZk,gather:()=>c.kgh,gatherND:()=>c.SY9,gather_util:()=>c.FJy,getBackend:()=>c.jz4,getGradient:()=>c.vQR,getKernel:()=>c._5H,getKernelsForBackend:()=>c.OpK,gpgpu_util:()=>op.gpgpu_util,grad:()=>c.Dvk,grads:()=>c.ok9,greater:()=>c.rhj,greaterEqual:()=>c.DQN,ifft:()=>c.KGM,imag:()=>c.ngS,image:()=>c.image,inTopKAsync:()=>c.U4u,initializers:()=>s,input:()=>Go,io:()=>c.io,irfft:()=>c.ggX,isFinite:()=>c.MIs,isInf:()=>c.EN4,isNaN:()=>c.yrW,keep:()=>c.aCs,kernel_impls:()=>c.kpo,layers:()=>a,leakyRelu:()=>c.H8d,less:()=>c.M7h,lessEqual:()=>c.InN,linalg:()=>c.mPL,linspace:()=>c.mT8,loadGraphModel:()=>Qd.ox,loadGraphModelSync:()=>Qd.R9,loadLayersModel:()=>Vo,localResponseNormalization:()=>c.Kgs,log:()=>c.Rm2,log1p:()=>c.Kko,logSigmoid:()=>c.nqI,logSoftmax:()=>c.HPB,logSumExp:()=>c.VZ,logicalAnd:()=>c.n76,logicalNot:()=>c.NSZ,logicalOr:()=>c.ztW,logicalXor:()=>c.rxB,losses:()=>c.YYh,lowerBound:()=>c.yzS,matMul:()=>c.NoW,math:()=>c.DyF,max:()=>c.T9B,maxPool:()=>c.jgi,maxPool3d:()=>c.NYV,maxPoolWithArgmax:()=>c.RO,maximum:()=>c.PhQ,mean:()=>c.i2o,memory:()=>c.m1Z,meshgrid:()=>c.OYQ,metrics:()=>i,min:()=>c.jkA,minimum:()=>c.BpO,mirrorPad:()=>c.FFZ,mod:()=>c.ziu,model:()=>jo,models:()=>o,moments:()=>c.Clk,movingAverage:()=>c.CRk,mul:()=>c.lKK,multiRNNCell:()=>c.YDF,multinomial:()=>c.OjQ,neg:()=>c.HZy,nextFrame:()=>c.dA1,norm:()=>c.xbf,notEqual:()=>c.Ec,oneHot:()=>c.Mw0,ones:()=>c.SaS,onesLike:()=>c.P61,op:()=>c.op,outerProduct:()=>c.X4o,pad:()=>c.eVF,pad1d:()=>c.BZs,pad2d:()=>c.grY,pad3d:()=>c.XHu,pad4d:()=>c.WLX,pool:()=>c.dzn,pow:()=>c.n7C,prelu:()=>c.NsG,print:()=>c.yyV,prod:()=>c._eU,profile:()=>c.MEE,raggedGather:()=>c.whe,raggedRange:()=>c.iyU,raggedTensorToTensor:()=>c.Q0_,rand:()=>c._9M,randomGamma:()=>c.pR9,randomNormal:()=>c.FE$,randomStandardNormal:()=>c.m0H,randomUniform:()=>c.YeY,randomUniformInt:()=>c.HYA,range:()=>c.y17,ready:()=>c.Gc4,real:()=>c.xav,reciprocal:()=>c.VOZ,registerBackend:()=>c.gJX,registerCallbackConstructor:()=>Ho,registerGradient:()=>c.krJ,registerKernel:()=>c.tAK,registerOp:()=>Qd.Nn,regularizers:()=>l,relu:()=>c.VVh,relu6:()=>c.j__,removeBackend:()=>c.rEj,reshape:()=>c.tQQ,reverse:()=>c.BEg,reverse1d:()=>c.QD2,reverse2d:()=>c.LMr,reverse3d:()=>c.I2l,reverse4d:()=>c.JYU,rfft:()=>c.z8$,round:()=>c.LIG,rsqrt:()=>c.Z$r,scalar:()=>c.d_2,scatterND:()=>c.NFr,scatter_util:()=>c.g23,searchSorted:()=>c.sZg,selu:()=>c.WfX,separableConv2d:()=>c.wdz,sequential:()=>Wo,serialization:()=>c.JFn,setBackend:()=>c.jh6,setPlatform:()=>c.OkC,setWebGLContext:()=>op.setWebGLContext,setdiff1dAsync:()=>c.F12,shared:()=>ip.shared,sigmoid:()=>c.ry7,sign:()=>c._SZ,signal:()=>c.vPA,sin:()=>c.F8e,sinh:()=>c.L0l,slice:()=>c.dik,slice1d:()=>c.Q$M,slice2d:()=>c.zAd,slice3d:()=>c.wck,slice4d:()=>c.R0O,slice_util:()=>c.Kro,softmax:()=>c.Vs9,softplus:()=>c.lw0,spaceToBatchND:()=>c.eDJ,sparse:()=>c.lMo,sparseToDense:()=>c.Zhr,spectral:()=>c.lOn,split:()=>c.lDo,sqrt:()=>c.RZD,square:()=>c.EwI,squaredDifference:()=>c.Pbu,squeeze:()=>c.r2V,stack:()=>c.t$z,step:()=>c.PMw,stridedSlice:()=>c.Ym9,string:()=>c.YjP,sub:()=>c.jbE,sum:()=>c.czq,sumOutType:()=>c.chL,tan:()=>c.Mlm,tanh:()=>c.ymU,tensor:()=>c.OEK,tensor1d:()=>c.tGX,tensor2d:()=>c.KtR,tensor3d:()=>c.$_$,tensor4d:()=>c.g9W,tensor5d:()=>c.Lpo,tensor6d:()=>c.yxw,tensorScatterUpdate:()=>c.NNh,tensor_util:()=>c.d_S,test_util:()=>c.Obs,tidy:()=>c.DZQ,tile:()=>c.Vsq,time:()=>c.kBw,topk:()=>c.rfw,train:()=>c.BaG,transpose:()=>c.mgz,truncatedNormal:()=>c.efE,unique:()=>c.AmM,unregisterGradient:()=>c.rYx,unregisterKernel:()=>c.iPt,unsortedSegmentSum:()=>c.zAU,unstack:()=>c.K$i,upcastType:()=>c.TuY,upperBound:()=>c.rni,util:()=>c.ZSL,valueAndGrad:()=>c.jYt,valueAndGrads:()=>c.muS,variable:()=>c.bvq,variableGrads:()=>c.y7e,version:()=>lp,version_converter:()=>Qd.uW,version_core:()=>c.bgA,version_cpu:()=>ip.version_cpu,version_layers:()=>vo,version_webgl:()=>op.version_webgl,webgl:()=>op.webgl,webgl_util:()=>op.webgl_util,where:()=>c._M9,whereAsync:()=>c.YJN,zeros:()=>c.Ul9,zerosLike:()=>c.POl});var r={};n.r(r),n.d(r,{maxNorm:()=>pi,minMaxNorm:()=>gi,nonNeg:()=>mi,unitNorm:()=>fi});var s={};n.r(s),n.d(s,{constant:()=>wi,glorotNormal:()=>Ii,glorotUniform:()=>Ti,heNormal:()=>Ei,heUniform:()=>Ai,identity:()=>ki,leCunNormal:()=>Ci,leCunUniform:()=>Ni,ones:()=>yi,orthogonal:()=>$i,randomNormal:()=>xi,randomUniform:()=>vi,truncatedNormal:()=>_i,varianceScaling:()=>Si,zeros:()=>bi});var a={};n.r(a),n.d(a,{Layer:()=>Ha,RNN:()=>Wl,RNNCell:()=>Gl,activation:()=>_c,add:()=>$c,alphaDropout:()=>xd,average:()=>Oc,averagePooling1d:()=>Vc,averagePooling2d:()=>Wc,averagePooling3d:()=>qc,avgPool1d:()=>Uc,avgPool2d:()=>Gc,avgPool3d:()=>Zc,avgPooling1d:()=>jc,avgPooling2d:()=>Hc,avgPooling3d:()=>Kc,batchNormalization:()=>Pc,bidirectional:()=>pd,categoryEncoding:()=>Id,centerCrop:()=>Sd,concatenate:()=>Dc,conv1d:()=>pc,conv2d:()=>fc,conv2dTranspose:()=>mc,conv3d:()=>gc,conv3dTranspose:()=>bc,convLstm2d:()=>ud,convLstm2dCell:()=>cd,cropping2D:()=>wc,dense:()=>kc,depthwiseConv2d:()=>xc,dot:()=>Lc,dropout:()=>Sc,elu:()=>oc,embedding:()=>Nc,flatten:()=>Ic,gaussianDropout:()=>vd,gaussianNoise:()=>wd,globalAveragePooling1d:()=>Yc,globalAveragePooling2d:()=>Xc,globalMaxPool1d:()=>md,globalMaxPool2d:()=>gd,globalMaxPooling1d:()=>Qc,globalMaxPooling2d:()=>Jc,gru:()=>rd,gruCell:()=>sd,input:()=>Go,inputLayer:()=>ic,layerNormalization:()=>zc,leakyReLU:()=>uc,lstm:()=>ad,lstmCell:()=>id,masking:()=>_d,maxPool1d:()=>bd,maxPool2d:()=>yd,maxPooling1d:()=>ed,maxPooling2d:()=>td,maxPooling3d:()=>nd,maximum:()=>Fc,minimum:()=>Rc,multiply:()=>Mc,permute:()=>Cc,prelu:()=>cc,randomWidth:()=>Ed,reLU:()=>lc,repeatVector:()=>Ec,rescaling:()=>kd,reshape:()=>Ac,resizing:()=>Td,rnn:()=>dd,separableConv2d:()=>yc,simpleRNN:()=>od,simpleRNNCell:()=>ld,softmax:()=>dc,spatialDropout1d:()=>Tc,stackedRNNCells:()=>hd,thresholdedReLU:()=>hc,timeDistributed:()=>fd,upSampling2d:()=>vc,zeroPadding2d:()=>Bc});var i={};n.r(i),n.d(i,{MAPE:()=>Pd,MSE:()=>Vd,binaryAccuracy:()=>Ad,binaryCrossentropy:()=>Cd,categoricalAccuracy:()=>$d,categoricalCrossentropy:()=>Od,cosineProximity:()=>Rd,mape:()=>zd,meanAbsoluteError:()=>Md,meanAbsolutePercentageError:()=>Ld,meanSquaredError:()=>Bd,mse:()=>Ud,precision:()=>Dd,recall:()=>Fd,sparseCategoricalAccuracy:()=>Nd});var o={};n.r(o),n.d(o,{modelFromJSON:()=>Bo});var l={};n.r(l),n.d(l,{l1:()=>Wd,l1l2:()=>jd,l2:()=>Gd});var u={};n.r(u),n.d(u,{CSVDataset:()=>Bh,Dataset:()=>Ah,FileDataSource:()=>Qh,TextLineDataset:()=>Dh,URLDataSource:()=>Jh,array:()=>Nh,csv:()=>ep,func:()=>tp,generator:()=>np,microphone:()=>sp,version_data:()=>ap,webcam:()=>rp,zip:()=>$h});var c=n(1592),d=n(2787),h=n(3583),p=n(6596),f=n(5366);const m={kernelName:d.ljI,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,(0,f.P)((0,h.w)(n,"float32"),-1))}}};var g=n(4493),b=n(5428),y=n(9e3),w=n(178),v=n(5935),x=n(3136);const _={kernelName:d.Vvy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,v.E)((0,h.w)(n,"float32")),r=(0,w.R)((0,x.j)((0,y.d)(1),t));return(0,b.H)((0,g.y)(e,r))}}}},k={kernelName:d.PH8,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,w.R)((0,x.j)((0,v.E)((0,h.w)(n,"float32")),1));return(0,g.y)(e,t)}}}};var S=n(548),T=n(6584),I=n(7917);const E={kernelName:d.OMN,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=S.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{let t=e;const r=S.getReductionAxes(n.shape,s);return r.length>0&&(t=(0,I.c)(t,r)),(0,T.t)(t,n.shape)},b:()=>{let t=e;const n=S.getReductionAxes(r.shape,s);return n.length>0&&(t=(0,I.c)(t,n)),(0,T.t)(t,r.shape)}}}},A={kernelName:d.EkD,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}};var C=n(7591);const N={kernelName:d.Jp_,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,C.P)(n)}}},$={kernelName:d.p_m,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,C.P)(n)}}},O={kernelName:d.QKF,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,w.R)((0,x.j)((0,y.d)(1),(0,v.E)((0,h.w)(n,"float32")))))}}};var D=n(9389);const F={kernelName:d.epO,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,w.R)((0,D.W)((0,y.d)(1),(0,v.E)((0,h.w)(n,"float32"))));return(0,g.y)(e,t)}}}},R={kernelName:d.lxb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=(0,S.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,D.W)((0,v.E)(n),(0,v.E)(r));let a=(0,p.l)(e,(0,g.y)(r,t));const i=(0,S.getReductionAxes)(n.shape,s);return i.length>0&&(a=(0,I.c)(a,i)),(0,T.t)(a,n.shape)},b:()=>{const t=(0,D.W)((0,v.E)(n),(0,v.E)(r));let a=(0,b.H)((0,p.l)(e,(0,g.y)(n,t)));const i=(0,S.getReductionAxes)(r.shape,s);return i.length>0&&(a=(0,I.c)(a,i)),(0,T.t)(a,r.shape)}}}},M={kernelName:d.TyE,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,D.W)((0,v.E)((0,h.w)(n,"float32")),1))}}},L={kernelName:d.zP9,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,x.j)((0,y.d)(1),(0,v.E)((0,h.w)(n,"float32"))))}}};var P=n(9936),z=n(7243),B=n(6689),V=n(8785),U=n(779);const j=(0,U.op)({avgPool3dGrad_:function(e,t,n,r,s,a){const i=(0,z.YT)(e,"dy","avgPool3dGrad"),o=(0,z.YT)(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=(0,T.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=(0,T.t)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),B.vA(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),B.vA(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),(0,V.s_)("avgPool3dGrad",s,a);const h={dy:l,input:u},p={filterSize:n,strides:r,pad:s,dimRoundingMode:a},f=P.T2.runKernel(d.wwC,h,p);return c?(0,T.t)(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),W={kernelName:d.cS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>j(e,r,s,a,i,o)}}},G=(0,U.op)({avgPoolGrad_:function(e,t,n,r,s){const a=(0,z.YT)(e,"dy","avgPoolGrad"),i=(0,z.YT)(t,"input","avgPoolGrad");B.vA(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=(0,T.t)(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=(0,T.t)(a,[1,a.shape[0],a.shape[1],a.shape[2]])),B.vA(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),B.vA(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:r,pad:s},p=P.T2.runKernel(d.VCH,c,h);return u?(0,T.t)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),H={kernelName:d.ho8,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>G(e,r,s,a,i)}}};var q=n(4293);const Z={kernelName:d.jAQ,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>(0,q.N)(e,s,!1,!1),b:()=>(0,q.N)(e,r,!0,!1)}:a&&!i?{a:()=>(0,q.N)(s,e,!1,!0),b:()=>(0,q.N)(r,e,!1,!1)}:{a:()=>(0,q.N)(s,e,!0,!0),b:()=>(0,q.N)(e,r,!0,!0)}:{a:()=>(0,q.N)(e,s,!1,!0),b:()=>(0,q.N)(r,e,!0,!1)}}};var K=n(4926);const Y={kernelName:d.Ik2,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>(0,K.e)(e,r,s)}}},X={kernelName:d.LB5,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let e=s.length-1;e>=0;e--)if(s[e]===a[e])i[e]=1;else if(1!==s[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let e=0;e<i.length;e++)i[e]>1&&o.push(e);return{x:()=>(0,I.c)(e,o,!0)}}},Q={kernelName:d.KXH,gradFunc:e=>({x:()=>e.clone()})},J={kernelName:d.QDP,gradFunc:e=>({x:()=>(0,C.P)(e)})};var ee=n(8395),te=n(2566),ne=n(1795),re=n(6073);const se={kernelName:d.vaV,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>(0,re._)((0,ne.n)((0,ee.D)(r,s),(0,te.I)(r,a)),e,(0,C.P)(e))}}},ae={kernelName:d.$zE,inputsToSave:["x"],gradFunc:m.gradFunc};var ie=n(4782);const oe={kernelName:d.$dB,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=(0,B.Y6)(s,t[0].shape)[0],i=r.map((e=>e[a]));return(0,ie.l)(e,i,a).map((e=>()=>e))}};var le=n(4958),ue=n(4314);const ce={kernelName:d.p2J,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return B.vA(V.Dh(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>(0,ue.v)(r.shape,e,s,i,o,l),filter:()=>(0,le.H)(r,e,s.shape,i,o,l)}}};var de=n(4300);const he={kernelName:d.jfg,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>(0,de.X)(e,s,a,i,o,1,l),filter:()=>(0,le.H)(e,r,s.shape,a,i,o,l)}}},pe=(0,U.op)({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=(0,T.t)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=(0,T.t)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),B.vA(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),B.vA(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),B.vA(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),B.vA(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),B.vA(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return P.T2.runKernel(d.iGz,o,l)}});var fe=n(8413);const me={kernelName:d.A1h,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;B.vA((0,V.Dh)(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>(0,fe.c)(i.shape,e,o,s,a),filter:()=>pe(i,e,o.shape,s,a)}}};var ge=n(56);const be={kernelName:d.Mn0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)((0,b.H)((0,ge.F)((0,h.w)(n,"float32"))),e)}}};var ye=n(2306);const we={kernelName:d.MnK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)((0,ye.L)((0,h.w)(n,"float32")),e)}}};var ve=n(4640),xe=n(8062),_e=n(7365);const ke={kernelName:d.nY8,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=(0,ve.Em)([s],r.rank);let n=(0,xe.r)(e,s,a,!i);return null!=t&&(n=(0,_e.m)(n,t)),n}}}};var Se=n(1020),Te=n(2392);const Ie={kernelName:d.tGH,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;B.vA(V.Dh(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return B.vA(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),B.vA(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),B.vA(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),B.vA(V.G0(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),V.s_("depthwiseConv2d",a,i),{x:()=>(0,Te.l)(l.shape,e,u,s,a,o,i),filter:()=>(0,Se.x)(l,e,u.shape,s,a,o,i)}}},Ee={kernelName:d.jxD,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>P.T2.runKernel(d.bP9,a,n),filter:()=>P.T2.runKernel(d.pk0,i,n)}}},Ae={kernelName:d.Pah,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>P.T2.runKernel(d.rsH,r)}}};var Ce=n(7145);const Ne={kernelName:d._s9,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,p.l)((0,Ce.o)((0,b.H)((0,v.E)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,p.l)(e,r)}}},$e={kernelName:d.ox3,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,n)}}},Oe={kernelName:d.ybN,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>(0,T.t)(e,n.shape)}}},De={kernelName:d.ybj,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,(0,Ce.o)(n))}}},Fe={kernelName:d.ZgB,gradFunc:e=>({x:()=>(0,C.P)(e)})},Re={kernelName:d.ElG,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=(0,S.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,g.y)(e,(0,h.w)(r,"float32")),a=(0,S.getReductionAxes)(n.shape,s);return a.length>0?(0,T.t)((0,I.c)(t,a),n.shape):t},b:()=>{let t=(0,p.l)(e,(0,h.w)(n,"float32"));const a=(0,S.getReductionAxes)(r.shape,s);a.length>0&&(t=(0,T.t)((0,I.c)(t,a),r.shape));const i=(0,v.E)(r);return(0,b.H)((0,g.y)(t,(0,h.w)(i,"float32")))}}}};var Me=n(882),Le=n(4944);const Pe={kernelName:d.i5R,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?(0,y.d)(1):o,u=(0,S.getReductionAxes)(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const d=(0,x.j)(s,a),h=(0,p.l)(e,l),f=(0,Me.Z)((0,D.W)(i,(0,y.d)(r))),m=(0,p.l)((0,p.l)((0,p.l)(f,f),f),(0,y.d)(-.5));return{x:()=>1===a.rank?(0,T.t)((0,p.l)((0,p.l)(e,(0,Le.V)((0,T.t)(f,[1,1,1,a.shape[0]]),c)),l),s.shape):(0,T.t)((0,p.l)((0,p.l)(e,f),l),s.shape),mean:()=>{let e=(0,p.l)((0,p.l)(f,(0,y.d)(-1)),h);return 1===a.rank&&(e=(0,I.c)(e,u)),(0,T.t)(e,a.shape)},variance:()=>{let e=(0,p.l)((0,p.l)(m,d),h);return 1===a.rank&&(e=(0,I.c)(e,u)),(0,T.t)(e,a.shape)},scale:()=>{const t=(0,p.l)(d,f);let n=(0,p.l)(e,t);return 1===a.rank&&(n=(0,I.c)(n,u)),(0,T.t)(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=(0,I.c)(t,u)),(0,T.t)(t,a.shape)}}}};var ze=n(1442),Be=n(1896);const Ve={kernelName:d.mxL,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=(0,B.Y6)(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,d=Ue(0,l),h=Ue(l+1,l+1+c),p=je([i,[s],u]),f=(0,T.t)(n,p),m=(0,T.t)(t,[s]),g=je([[l],d,h]),b=(0,_e.m)(f,g);let y=(0,Be.z)(b,m,e.shape[o]);const w=(0,ve.gx)(g);return y=(0,_e.m)(y,w),y};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=(0,ze.t)(n.map(((t,n)=>l(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function Ue(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function je(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const We={kernelName:d.lLS,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,C.P)(n),b:()=>(0,C.P)(r)}}},Ge={kernelName:d.lzr,gradFunc:e=>({x:()=>(0,h.w)(e,"float32")})},He={kernelName:d.gIW,gradFunc:e=>({x:()=>(0,C.P)(e)})},qe={kernelName:d.E3$,gradFunc:e=>({x:()=>(0,C.P)(e)})},Ze={kernelName:d.iPs,gradFunc:e=>({x:()=>(0,C.P)(e)})};var Ke=n(560);const Ye={kernelName:d.X0$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=(0,Ke.r)(r,0);return{x:()=>(0,re._)(a,e,(0,p.l)(e,s))}}},Xe={kernelName:d.Cg$,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,D.W)(n,1))}}},Qe={kernelName:d.tG8,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,h.w)(n,"float32"))}}},Je={kernelName:d.zfU,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=(0,Ce.o)(r);return(0,x.j)(e,(0,p.l)((0,I.c)(e,s,!0),t))}}}},et=(0,U.op)({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return P.T2.runKernel(d.ToN,o,l)}}),tt={kernelName:d.jM4,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>et(r,s,e,a,i,o,l)}}};var nt=n(6414);function rt(e,t,n,r){return t.rank<n.rank&&(t=(0,T.t)(t,ve.SM(t.shape,r))),e.rank<n.rank&&(e=(0,T.t)(e,ve.SM(e.shape,r))),{x:()=>(0,p.l)(e,(0,h.w)((0,nt.L)(n,t),e.dtype))}}const st={kernelName:d.VAI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=rt(e,t[1],a,B.Y6(s,a.shape));return{x:()=>i.x()}}};var at=n(349);const it={kernelName:d.LDN,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,p.l)(e,(0,h.w)((0,ee.D)(n,r),"float32")),b:()=>(0,p.l)(e,(0,h.w)((0,at.M)(n,r),"float32"))}}},ot=(0,U.op)({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=(0,z.YT)(e,"dy","maxPool3dGrad"),l=(0,z.YT)(t,"input","maxPool3dGrad"),u=(0,z.YT)(n,"output","maxPool3dGrad");let c=o,h=l,p=u,f=!1;4===l.rank&&(f=!0,c=(0,T.t)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=(0,T.t)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=(0,T.t)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),B.vA(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),B.vA(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),B.vA(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),(0,V.s_)("maxPool3dGrad",a,i);const m={dy:c,input:h,output:p},g={filterSize:r,strides:s,pad:a,dimRoundingMode:i},b=P.T2.runKernel(d.cHb,m,g);return f?(0,T.t)(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}}),lt={kernelName:d.ySp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>ot(e,r,s,a,i,o,l)}}},ut=(0,U.op)({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=(0,z.YT)(e,"dy","maxPoolGrad"),l=(0,z.YT)(t,"input","maxPoolGrad"),u=(0,z.YT)(n,"output","maxPoolGrad");B.vA(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),B.vA(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),B.vA(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),V.s_("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return P.T2.runKernel(d.RXX,c,h)}}),ct={kernelName:d.t3d,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>ut(e,r,s,a,i,o)}}};var dt=n(5101);const ht={kernelName:d.g5A,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=B.Y6(s,r.shape),i=(0,ve.lb)(r.shape,a)[1],o=B.Ze(i);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=(0,T.t)(e,t);return(0,g.y)((0,p.l)(n,(0,dt.S)(r.shape,"float32")),o)}}}},pt={kernelName:d.lNG,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=rt(e,i,a,B.Y6(s,a.shape));return{x:()=>o.x()}}},ft={kernelName:d.LG0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,p.l)(e,(0,h.w)((0,te.I)(n,r),"float32")),b:()=>(0,p.l)(e,(0,h.w)((0,Ke.r)(n,r),"float32"))}}};var mt=n(9340);const gt={kernelName:d.x7F,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>(0,mt.d)(e,a,r.shape)}}};var bt=n(7160);const yt={kernelName:d.BLA,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=(0,S.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,S.getReductionAxes)(n.shape,s);return t.length>0?(0,T.t)((0,I.c)(e,t),n.shape):e},b:()=>{const t=(0,p.l)(e,(0,b.H)((0,bt.R)((0,g.y)(n,r)))),a=(0,S.getReductionAxes)(r.shape,s);return a.length>0?(0,T.t)((0,I.c)(t,a),r.shape):t}}}},wt={kernelName:d.xu7,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=(0,S.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,p.l)(e,(0,h.w)(r,"float32")),a=(0,S.getReductionAxes)(n.shape,s);return a.length>0?(0,T.t)((0,I.c)(t,a),n.shape):t},b:()=>{const t=(0,p.l)(e,(0,h.w)(n,"float32")),a=(0,S.getReductionAxes)(r.shape,s);return a.length>0?(0,T.t)((0,I.c)(t,a),r.shape):t}}}},vt={kernelName:d.l0G,gradFunc:e=>({x:()=>(0,b.H)(e)})};var xt=n(8529);const _t={kernelName:d.urI,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>(0,xt.U)(n.shape,"float32")}}},kt={kernelName:d.LWX,gradFunc:e=>({x:()=>(0,C.P)(e)})};var St=n(2223);const Tt={kernelName:d.mM$,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return(0,St.K)(e,r).map((e=>()=>e))}},It={kernelName:d.ODT,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>(0,mt.d)(e,a,r.shape)}}};var Et=n(8148),At=n(6712);const Ct={kernelName:d.pyJ,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=S.assertAndGetBroadcastShape(a.shape,i.shape);return{a:()=>{const t=(0,h.w)(i,"float32");let n=(0,p.l)(e,(0,p.l)(t,(0,At.n)(a,(0,x.j)(t,(0,y.d)(1)))));const r=S.getReductionAxes(a.shape,o);return r.length>0&&(n=(0,I.c)(n,r)),(0,T.t)(n,a.shape)},b:()=>{const t=(0,Ke.r)(a,0),n=(0,re._)(t,(0,Et.R)(a),(0,C.P)(a));let r=(0,p.l)(e,(0,p.l)(s,n));const l=S.getReductionAxes(i.shape,o);return l.length>0&&(r=(0,I.c)(r,l)),(0,T.t)(r,i.shape)}}}},Nt={kernelName:d.Ncv,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=(0,Ke.r)(n,0);return{x:()=>(0,re._)(s,e,(0,p.l)(e,r)),alpha:()=>{let t=(0,re._)(s,(0,C.P)(e),(0,p.l)(e,n));const a=(0,S.getReductionAxes)(r.shape,e.shape);return a.length>0&&(t=(0,I.c)(t,a)),(0,T.t)(t,r.shape)}}}};var $t=n(2268);const Ot={kernelName:d.kdj,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=null==s?r.shape.map(((e,t)=>t)):"number"==typeof s?[s]:s,{x:()=>function(e,t,n){const r=e.shape.length,s=r-n.length,a=ve.Em(n,r);let i=e;null!=a&&(i=(0,_e.m)(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=(0,T.t)(t,r),a=(0,$t.L)(e,n,!0,!1),i=(0,$t.L)(e,n,!0,!0),o=(0,p.l)(a,i);return(0,p.l)(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=ve.gx(a);u=(0,_e.m)(u,e)}return u}(r,e,a)}}},Dt={kernelName:d.sDr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=S.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{const t=(0,g.y)(e,(0,h.w)(r,"float32")),a=S.getReductionAxes(n.shape,s);return a.length>0?(0,T.t)((0,I.c)(t,a),n.shape):t},b:()=>{let t=(0,p.l)(e,(0,h.w)(n,"float32"));const a=S.getReductionAxes(r.shape,s);a.length>0&&(t=(0,T.t)((0,I.c)(t,a),r.shape));const i=(0,v.E)(r);return(0,b.H)((0,g.y)(t,(0,h.w)(i,"float32")))}}}},Ft={kernelName:d.huO,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,b.H)((0,v.E)(n)))}}},Rt={kernelName:d.P_L,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,p.l)((0,te.I)(n,6),(0,f.P)(n));return{x:()=>(0,p.l)(e,(0,h.w)(r,"float32"))}}},Mt={kernelName:d.fUj,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,(0,h.w)((0,f.P)(n),"float32"))}}},Lt={kernelName:d.R23,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,T.t)(e,n.shape)}}},Pt={kernelName:d.hgw,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>P.T2.runKernel(d.FCQ,s,n)}}},zt={kernelName:d.jOE,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>P.T2.runKernel(d.XQy,s,n)}}};var Bt=n(4032);const Vt={kernelName:d.D7i,gradFunc:(e,t,n)=>{const{dims:r}=n,s=(0,B.Y6)(r,e.shape);return{x:()=>(0,Bt.B)(e,s)}}},Ut={kernelName:d.hVg,gradFunc:e=>({x:()=>(0,C.P)(e)})},jt={kernelName:d.TOR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,b.H)((0,g.y)(e,(0,p.l)((0,At.n)(n,1.5),2)))}}};var Wt=n(6443);const Gt={kernelName:d.l6P,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>(0,h.w)((0,C.P)(n),"float32"),t:()=>(0,p.l)(e,(0,h.w)(n,e.dtype)),e:()=>(0,p.l)(e,(0,h.w)((0,Wt.N)(n),e.dtype))}}};var Ht=n(3130);const qt={kernelName:d.u$b,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,Ke.r)(n,(0,y.d)(0)),r=(0,y.d)(Ht.j),s=(0,y.d)(Ht.X),a=(0,p.l)(e,s),i=(0,p.l)((0,p.l)(e,r),(0,Ce.o)((0,h.w)(n,"float32")));return(0,re._)(t,a,i)}}}},Zt={kernelName:d.vI1,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,(0,p.l)(n,(0,x.j)((0,y.d)(1),n)))}}},Kt={kernelName:d.YVe,gradFunc:e=>({x:()=>(0,C.P)(e)})};var Yt=n(579);const Xt={kernelName:d.hql,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)((0,Yt.g)((0,h.w)(n,"float32")),e)}}};var Qt=n(765);const Jt={kernelName:d.J3C,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)((0,Qt.y)((0,h.w)(n,"float32")),e)}}};var en=n(6023),tn=n(2955);const nn={kernelName:d.JiE,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=(0,tn.parseSliceParams)(r,s,a),u=[];for(let t=0;t<e.rank;t++)u.push([o[t],i[t]-o[t]-l[t]]);return{x:()=>(0,en.e)(e,u)}}},rn={kernelName:d.rFG,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=(0,p.l)(e,r);return{logits:()=>(0,x.j)(a,(0,p.l)((0,I.c)(a,[s],!0),r))}}};var sn=n(6118);const an={kernelName:d.Fin,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,(0,sn.r)(n))}}};var on=n(610);const ln={kernelName:d.A8B,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>(0,on.G)(e,r,s)}}};var un=n(4636);const cn={kernelName:d.Blb,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>(0,un.x)(e,r)}}},dn={kernelName:d.dFH,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,p.l)((0,w.R)((0,h.w)(n,"float32")),2))}}},hn={kernelName:d.M6A,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)(e,(0,p.l)((0,h.w)(n,"float32"),2))}}},pn={kernelName:d.Ddj,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=(0,y.d)(2);return{a:()=>(0,p.l)(e,(0,p.l)(s,(0,x.j)(n,r))),b:()=>(0,p.l)(e,(0,p.l)(s,(0,x.j)(r,n)))}}},fn={kernelName:d.pnw,gradFunc:e=>({x:()=>(0,C.P)(e)})},mn={kernelName:d.PbM,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=S.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{let t=e;const r=S.getReductionAxes(n.shape,s);return r.length>0&&(t=(0,I.c)(t,r)),(0,T.t)(t,n.shape)},b:()=>{let t=e;const n=S.getReductionAxes(r.shape,s);return n.length>0&&(t=(0,I.c)(t,n)),(0,T.t)((0,b.H)(t),r.shape)}}}},gn={kernelName:d.WuN,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;(0,B.Y6)(a,r.shape).forEach((e=>{s[e]=1}));const i=(0,T.t)(e,s),o=(0,p.l)(i,(0,dt.S)(r.shape,"float32"));return{x:()=>o}}},bn={kernelName:d.oFs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,g.y)(e,(0,v.E)((0,Yt.g)(n)))}}},yn={kernelName:d.iuW,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,p.l)((0,x.j)((0,y.d)(1),(0,v.E)(n)),e)}}},wn={kernelName:d.FAs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=(0,C.P)(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=(0,D.W)(t,(0,mt.d)(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=(0,D.W)(t,(0,mt.d)(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=(0,D.W)(t,(0,mt.d)(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=(0,D.W)(t,(0,mt.d)(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},vn={kernelName:d.wx0,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=ve.gx(s);return{x:()=>(0,_e.m)(e,a)}}},xn={kernelName:d.dXR,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>(0,ze.t)(e,s)}}};var _n=n(3420),kn=n(7755),Sn=n(1460);const Tn={kernelName:d.pPe,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=(0,Sn.P)(t,(0,C.P)(t)),r=(0,kn.k)(e,n);let s=(0,ee.D)(t,(0,y.d)(0,"int32"));const a=r.rank-s.rank;for(let e=0;e<a;++e)s=(0,_n.U)(s,e+1);s=(0,ne.n)(s,(0,dt.S)(r.shape,"bool"));const i=(0,C.P)(r);return(0,re._)(s,r,i)}(e,n)}}},In={kernelName:d.xJ3,gradFunc:e=>({x:()=>(0,C.P)(e)})};var En=n(1112);const An=[m,_,k,E,A,N,$,O,F,R,M,L,W,H,Z,Y,X,Q,J,se,ae,oe,he,ce,me,be,we,ke,Ie,Ee,Dt,Ae,Ne,$e,Oe,De,Re,Fe,Pe,Ve,We,Ge,He,qe,Ze,Ye,Xe,Qe,Je,tt,st,st,it,lt,ct,ht,pt,ft,gt,yt,wt,vt,_t,kt,Tt,It,It,Ct,Nt,Ot,Ft,Rt,Mt,Lt,Pt,zt,Vt,Ut,jt,Gt,qt,Zt,Kt,Xt,Jt,nn,rn,an,ln,ln,cn,cn,dn,pn,hn,fn,mn,gn,bn,yn,wn,vn,xn,Tn,In];for(const e of An)(0,En.kr)(e);var Cn=n(6762),Nn=n(1794);(0,Nn.tp)().prototype.abs=function(){return this.throwIfDisposed(),(0,Cn.t)(this)};var $n=n(4702);(0,Nn.tp)().prototype.acos=function(){return this.throwIfDisposed(),(0,$n.H)(this)};var On=n(3876);(0,Nn.tp)().prototype.acosh=function(){return this.throwIfDisposed(),(0,On.F)(this)},(0,Nn.tp)().prototype.add=function(e){return this.throwIfDisposed(),(0,D.W)(this,e)};var Dn=n(6733);(0,Nn.tp)().prototype.all=function(e,t){return this.throwIfDisposed(),(0,Dn.Q)(this,e,t)};var Fn=n(3047);(0,Nn.tp)().prototype.any=function(e,t){return this.throwIfDisposed(),(0,Fn.b)(this,e,t)};var Rn=n(5455);(0,Nn.tp)().prototype.argMax=function(e){return this.throwIfDisposed(),(0,Rn.F)(this,e)};var Mn=n(2421);(0,Nn.tp)().prototype.argMin=function(e){return this.throwIfDisposed(),(0,Mn.X)(this,e)},(0,Nn.tp)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,B.vA)(1===this.size,(()=>"The array must have only 1 element.")),(0,T.t)(this,[])},(0,Nn.tp)().prototype.asType=function(e){return this.throwIfDisposed(),(0,h.w)(this,e)},(0,Nn.tp)().prototype.as1D=function(){return this.throwIfDisposed(),(0,T.t)(this,[this.size])},(0,Nn.tp)().prototype.as2D=function(e,t){return this.throwIfDisposed(),(0,T.t)(this,[e,t])},(0,Nn.tp)().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),(0,T.t)(this,[e,t,n])},(0,Nn.tp)().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),(0,T.t)(this,[e,t,n,r])},(0,Nn.tp)().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),(0,T.t)(this,[e,t,n,r,s])};var Ln=n(8807);(0,Nn.tp)().prototype.asin=function(){return this.throwIfDisposed(),(0,Ln.q)(this)};var Pn=n(2615);(0,Nn.tp)().prototype.asinh=function(){return this.throwIfDisposed(),(0,Pn.y)(this)};var zn=n(2774);(0,Nn.tp)().prototype.atan=function(){return this.throwIfDisposed(),(0,zn.r)(this)};var Bn=n(9374);(0,Nn.tp)().prototype.atan2=function(e){return this.throwIfDisposed(),(0,Bn.F)(this,e)};var Vn=n(7004);(0,Nn.tp)().prototype.atanh=function(){return this.throwIfDisposed(),(0,Vn.r)(this)};var Un=n(9303);(0,Nn.tp)().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),(0,Un.$)(this,e,t,n,r)},(0,Nn.tp)().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),(0,on.G)(this,e,t)};var jn=n(6363);(0,Nn.tp)().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),(0,jn.$)(this,e,t,n,r,s)};var Wn=n(209);(0,Nn.tp)().prototype.broadcastTo=function(e){return this.throwIfDisposed(),(0,Wn.h)(this,e)},(0,Nn.tp)().prototype.cast=function(e){return this.throwIfDisposed(),(0,h.w)(this,e)};var Gn=n(8665);(0,Nn.tp)().prototype.ceil=function(){return this.throwIfDisposed(),(0,Gn.m)(this)};var Hn=n(3406);(0,Nn.tp)().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),(0,Hn.z)(this,e,t)},(0,Nn.tp)().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Nn.qY&&(e=[e]),(0,un.x)([this,...e],t)};var qn=n(4347);(0,Nn.tp)().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),(0,qn.k)(this,e,t,n,r,s,a)};var Zn=n(5380);(0,Nn.tp)().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),(0,Zn.w)(this,e,t,n,r,s)},(0,Nn.tp)().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),(0,de.X)(this,e,t,n,r,s,a)},(0,Nn.tp)().prototype.cos=function(){return this.throwIfDisposed(),(0,Yt.g)(this)},(0,Nn.tp)().prototype.cosh=function(){return this.throwIfDisposed(),(0,Qt.y)(this)},(0,Nn.tp)().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),(0,$t.L)(this,e,t,n)},(0,Nn.tp)().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),(0,xe.r)(this,e,t,n)};var Kn=n(3682);(0,Nn.tp)().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),(0,Kn.R)(this,e,t)};var Yn=n(1490);(0,Nn.tp)().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),(0,Yn.G)(this,e,t,n,r,s,a)};var Xn=n(7268);(0,Nn.tp)().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),(0,Xn.X)(this,e,t,n,r,s)};var Qn=n(8209);(0,Nn.tp)().prototype.divNoNan=function(e){return this.throwIfDisposed(),(0,Qn.e)(this,e)},(0,Nn.tp)().prototype.div=function(e){return this.throwIfDisposed(),(0,g.y)(this,e)};var Jn=n(9426);(0,Nn.tp)().prototype.dot=function(e){return this.throwIfDisposed(),(0,Jn.O)(this,e)};var er=n(2810);(0,Nn.tp)().prototype.elu=function(){return this.throwIfDisposed(),(0,er.P)(this)},(0,Nn.tp)().prototype.equal=function(e){return this.throwIfDisposed(),(0,nt.L)(this,e)};var tr=n(9665);(0,Nn.tp)().prototype.erf=function(){return this.throwIfDisposed(),(0,tr.Y)(this)};var nr=n(983);(0,Nn.tp)().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),(0,nr.p)(this,e,t)},(0,Nn.tp)().prototype.exp=function(){return this.throwIfDisposed(),(0,Ce.o)(this)},(0,Nn.tp)().prototype.expandDims=function(e){return this.throwIfDisposed(),(0,_n.U)(this,e)};var rr=n(8172);(0,Nn.tp)().prototype.expm1=function(){return this.throwIfDisposed(),(0,rr.I)(this)};var sr=n(5687);(0,Nn.tp)().prototype.fft=function(){return this.throwIfDisposed(),(0,sr.h)(this)},(0,Nn.tp)().prototype.flatten=function(){return this.throwIfDisposed(),(0,T.t)(this,[this.size])},(0,Nn.tp)().prototype.floor=function(){return this.throwIfDisposed(),(0,bt.R)(this)};var ar=n(905);(0,Nn.tp)().prototype.floorDiv=function(e){return this.throwIfDisposed(),(0,ar.w)(this,e)},(0,Nn.tp)().prototype.gather=function(e,t,n){return this.throwIfDisposed(),(0,kn.k)(this,e,t,n)},(0,Nn.tp)().prototype.greaterEqual=function(e){return this.throwIfDisposed(),(0,ee.D)(this,e)},(0,Nn.tp)().prototype.greater=function(e){return this.throwIfDisposed(),(0,Ke.r)(this,e)};var ir=n(3966);(0,Nn.tp)().prototype.ifft=function(){return this.throwIfDisposed(),(0,ir.K)(this)};var or=n(1718);(0,Nn.tp)().prototype.irfft=function(){return this.throwIfDisposed(),(0,or.g)(this)};var lr=n(488);(0,Nn.tp)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,lr.M)(this)};var ur=n(9508);(0,Nn.tp)().prototype.isInf=function(){return this.throwIfDisposed(),(0,ur.E)(this)};var cr=n(8226);(0,Nn.tp)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,cr.y)(this)};var dr=n(1809);(0,Nn.tp)().prototype.leakyRelu=function(e){return this.throwIfDisposed(),(0,dr.H)(this,e)},(0,Nn.tp)().prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,te.I)(this,e)},(0,Nn.tp)().prototype.less=function(e){return this.throwIfDisposed(),(0,at.M)(this,e)};var hr=n(8557);(0,Nn.tp)().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),(0,hr.K)(this,e,t,n,r)};var pr=n(7023);(0,Nn.tp)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,pr.n)(this)};var fr=n(6417);(0,Nn.tp)().prototype.logSoftmax=function(e){return this.throwIfDisposed(),(0,fr.H)(this,e)};var mr=n(8160);(0,Nn.tp)().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),(0,mr.V)(this,e,t)},(0,Nn.tp)().prototype.log=function(){return this.throwIfDisposed(),(0,Et.R)(this)};var gr=n(7441);(0,Nn.tp)().prototype.log1p=function(){return this.throwIfDisposed(),(0,gr.K)(this)},(0,Nn.tp)().prototype.logicalAnd=function(e){return this.throwIfDisposed(),(0,ne.n)(this,e)},(0,Nn.tp)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,Wt.N)(this)};var br=n(6045);(0,Nn.tp)().prototype.logicalOr=function(e){return this.throwIfDisposed(),(0,br.z)(this,e)};var yr=n(1927);(0,Nn.tp)().prototype.logicalXor=function(e){return this.throwIfDisposed(),(0,yr.r)(this,e)},(0,Nn.tp)().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),(0,q.N)(this,e,t,n)};var wr=n(689);(0,Nn.tp)().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),(0,wr.j)(this,e,t,n,r)};var vr=n(7516);(0,Nn.tp)().prototype.max=function(e,t){return this.throwIfDisposed(),(0,vr.T)(this,e,t)},(0,Nn.tp)().prototype.maximum=function(e){return this.throwIfDisposed(),(0,Sn.P)(this,e)};var xr=n(597);(0,Nn.tp)().prototype.mean=function(e,t){return this.throwIfDisposed(),(0,xr.i)(this,e,t)};var _r=n(7858);(0,Nn.tp)().prototype.min=function(e,t){return this.throwIfDisposed(),(0,_r.j)(this,e,t)};var kr=n(9858);(0,Nn.tp)().prototype.minimum=function(e){return this.throwIfDisposed(),(0,kr.B)(this,e)};var Sr=n(1985);(0,Nn.tp)().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),(0,Sr.F)(this,e,t)};var Tr=n(9302);(0,Nn.tp)().prototype.mod=function(e){return this.throwIfDisposed(),(0,Tr.z)(this,e)},(0,Nn.tp)().prototype.mul=function(e){return this.throwIfDisposed(),(0,p.l)(this,e)},(0,Nn.tp)().prototype.neg=function(){return this.throwIfDisposed(),(0,b.H)(this)};var Ir=n(9134);(0,Nn.tp)().prototype.norm=function(e,t,n){return this.throwIfDisposed(),(0,Ir.x)(this,e,t,n)};var Er=n(5708);(0,Nn.tp)().prototype.notEqual=function(e){return this.throwIfDisposed(),(0,Er.E)(this,e)};var Ar=n(7690);(0,Nn.tp)().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),(0,Ar.M)(this,e,t,n)};var Cr=n(1619);(0,Nn.tp)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,Cr.P)(this)},(0,Nn.tp)().prototype.pad=function(e,t){return this.throwIfDisposed(),(0,en.e)(this,e,t)};var Nr=n(7606);(0,Nn.tp)().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),(0,Nr.d)(this,e,t,n,r,s,a)},(0,Nn.tp)().prototype.pow=function(e){return this.throwIfDisposed(),(0,At.n)(this,e)};var $r=n(5368);(0,Nn.tp)().prototype.prelu=function(e){return this.throwIfDisposed(),(0,$r.N)(this,e)};var Or=n(2105);(0,Nn.tp)().prototype.prod=function(e,t){return this.throwIfDisposed(),(0,Or._)(this,e,t)};var Dr=n(104);(0,Nn.tp)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,Dr.V)(this)};var Fr=n(5738);(0,Nn.tp)().prototype.relu=function(){return this.throwIfDisposed(),(0,Fr.V)(this)};var Rr=n(1958);(0,Nn.tp)().prototype.relu6=function(){return this.throwIfDisposed(),(0,Rr.j)(this)},(0,Nn.tp)().prototype.reshapeAs=function(e){return this.throwIfDisposed(),(0,T.t)(this,e.shape)},(0,Nn.tp)().prototype.reshape=function(e){return this.throwIfDisposed(),(0,T.t)(this,e)};var Mr=n(3541);(0,Nn.tp)().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),(0,Mr.v)(this,e,t,n)};var Lr=n(6728);(0,Nn.tp)().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),(0,Lr.b)(this,e,t,n)},(0,Nn.tp)().prototype.reverse=function(e){return this.throwIfDisposed(),(0,Bt.B)(this,e)};var Pr=n(2237);(0,Nn.tp)().prototype.rfft=function(){return this.throwIfDisposed(),(0,Pr.z)(this)};var zr=n(9646);(0,Nn.tp)().prototype.round=function(){return this.throwIfDisposed(),(0,zr.L)(this)},(0,Nn.tp)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,Me.Z)(this)};var Br=n(7703);(0,Nn.tp)().prototype.selu=function(){return this.throwIfDisposed(),(0,Br.W)(this)};var Vr=n(9348);(0,Nn.tp)().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),(0,Vr.w)(this,e,t,n,r,s,a)},(0,Nn.tp)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,sn.r)(this)};var Ur=n(5525);(0,Nn.tp)().prototype.sign=function(){return this.throwIfDisposed(),(0,Ur._)(this)},(0,Nn.tp)().prototype.sin=function(){return this.throwIfDisposed(),(0,ge.F)(this)},(0,Nn.tp)().prototype.sinh=function(){return this.throwIfDisposed(),(0,ye.L)(this)},(0,Nn.tp)().prototype.slice=function(e,t){return this.throwIfDisposed(),(0,mt.d)(this,e,t)};var jr=n(6288);(0,Nn.tp)().prototype.softmax=function(e){return this.throwIfDisposed(),(0,jr.V)(this,e)};var Wr=n(788);(0,Nn.tp)().prototype.softplus=function(){return this.throwIfDisposed(),(0,Wr.l)(this)},(0,Nn.tp)().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),(0,K.e)(this,e,t)},(0,Nn.tp)().prototype.split=function(e,t){return this.throwIfDisposed(),(0,ie.l)(this,e,t)},(0,Nn.tp)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,w.R)(this)},(0,Nn.tp)().prototype.square=function(){return this.throwIfDisposed(),(0,v.E)(this)};var Gr=n(225);(0,Nn.tp)().prototype.squaredDifference=function(e){return this.throwIfDisposed(),(0,Gr.P)(this,e)};var Hr=n(6758);(0,Nn.tp)().prototype.squeeze=function(e){return this.throwIfDisposed(),(0,Hr.r)(this,e)},(0,Nn.tp)().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Nn.qY?[this,e]:[this,...e];return(0,ze.t)(n,t)},(0,Nn.tp)().prototype.step=function(e){return this.throwIfDisposed(),(0,f.P)(this,e)};var qr=n(5684);(0,Nn.tp)().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),(0,qr.Y)(this,e,t,n,r,s,a,i,o)},(0,Nn.tp)().prototype.sub=function(e){return this.throwIfDisposed(),(0,x.j)(this,e)},(0,Nn.tp)().prototype.sum=function(e,t){return this.throwIfDisposed(),(0,I.c)(this,e,t)};var Zr=n(845);(0,Nn.tp)().prototype.tan=function(){return this.throwIfDisposed(),(0,Zr.M)(this)};var Kr=n(8198);(0,Nn.tp)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Kr.y)(this)},(0,Nn.tp)().prototype.tile=function(e){return this.throwIfDisposed(),(0,Le.V)(this,e)},(0,Nn.tp)().prototype.toBool=function(){return this.throwIfDisposed(),(0,h.w)(this,"bool")},(0,Nn.tp)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,h.w)(this,"float32")},(0,Nn.tp)().prototype.toInt=function(){return this.throwIfDisposed(),(0,h.w)(this,"int32")};var Yr=n(8244);(0,Nn.tp)().prototype.topk=function(e,t){return this.throwIfDisposed(),(0,Yr.r)(this,e,t)},(0,Nn.tp)().prototype.transpose=function(e){return this.throwIfDisposed(),(0,_e.m)(this,e)};var Xr=n(1211);(0,Nn.tp)().prototype.unique=function(e){return this.throwIfDisposed(),(0,Xr.A)(this,e)},(0,Nn.tp)().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),(0,Be.z)(this,e,t)},(0,Nn.tp)().prototype.unstack=function(e){return this.throwIfDisposed(),(0,St.K)(this,e)},(0,Nn.tp)().prototype.where=function(e,t){return this.throwIfDisposed(),(0,re._)(e,this,t)},(0,Nn.tp)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,C.P)(this)};class Qr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Qr.prototype)}}class Jr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Jr.prototype)}}class es extends Error{constructor(e){super(e),Object.setPrototypeOf(this,es.prototype)}}class ts extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ts.prototype)}}class ns extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ns.prototype)}}Error;class rs{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function ss(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function as(e,t){if(!e)throw new ns(t)}function is(e,t){let n=0;for(const r of e)r===t&&n++;return n}function os(e){return 1===e.length?e[0]:e}function ls(e){return Array.isArray(e)?e:[e]}function us(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function cs(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let ds={};function hs(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function ps(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>ps(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?ps(t):e[n]=t.value)}}}function fs(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in ds)a=ds[s];else if(a=t[s],null==a)throw new es(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new es(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in ds?[o,l]=ds.className:i in t&&([o,l]=t[i]),null==o)throw new es(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const t of Object.keys(ds))e[t]=ds[t];for(const t of Object.keys(n))e[t]=n[t];a.config.customObjects=e;const t=Object.assign({},ds);for(const e of Object.keys(n))ds[e]=n[e];ps(a.config);const r=l(o,a.config,n,s);return ds=Object.assign({},t),r}{const e=Object.assign({},ds);for(const e of Object.keys(n))ds[e]=n[e];const t=new o(a.config);return ds=Object.assign({},e),t}}}function ms(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function gs(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function bs(e){if(null==e)throw new es(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function ys(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new es(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function ws(e,t,n=0,r=1/0){return as(n>=0),as(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function vs(e,t){Array.isArray(e)?(c.ZSL.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>vs(e,`element ${n+1} of ${t}`)))):c.ZSL.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${xs(e)}.`))}function xs(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>xs(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function _s(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let ks=0;function Ss(){return ks++}const Ts={};function Is(e=""){return e in Ts||(Ts[e]=0),Ts[e]+=1,e+Ts[e].toString()}const Es=["channelsFirst","channelsLast"],As=["nearest","bilinear"],Cs=["valid","same","causal"],Ns=["max","avg"],$s=["sum","mul","concat","ave"],Os=new Map;function Ds(e){ys(Es,"DataFormat",e)}function Fs(e){ys(Cs,"PaddingMode",e)}function Rs(e){ys(Ns,"PoolMode",e)}const Ms=[];function Ls(e,t){Ms.push(e);try{const e=t();return Ms.pop(),e}catch(e){throw Ms.pop(),e}}function Ps(e){if(!Vs(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Ms.length?"":Ms.join("/")+"/")+e}function zs(e){if(!Vs(e))throw new Error("Not a valid tensor name: '"+e+"'");Os.has(e)||Os.set(e,0);const t=Os.get(e);if(Os.set(e,Os.get(e)+1),t>0){const n=`${e}_${t}`;return Os.set(n,1),n}return e}const Bs=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Vs(e){return!!e.match(Bs)}function Us(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function js(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function Ws(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function Gs(e,t){if(t<e)throw new es(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let Hs;function qs(){return null==Hs&&(Hs=(0,c.Hs)().epsilon()),Hs}function Zs(e,t){return c.wgE(e,t)}function Ks(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),c.tQQ(e,n)}function Ys(e,t,n){return(0,c.DZQ)((()=>{switch(e.rank){case 1:return c.Q$M(e,t,n);case 2:return c.zAd(e,[t,0],[n,e.shape[1]]);case 3:return c.wck(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return c.R0O(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return c.dik(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return c.dik(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new es(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Xs(e,t,n){return(0,c.DZQ)((()=>{switch(e.rank){case 1:return c.Q$M(e,t,n);case 2:return c.zAd(e,[0,t],[e.shape[0],n]);case 3:return c.wck(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return c.R0O(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new es(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Qs(e,t,n,r){return(0,c.DZQ)((()=>{switch(e.rank){case 1:return c.Q$M(e,t,n);case 2:switch(r){case 1:return Ys(e,t,n);case 2:return Xs(e,t,n);default:throw new es(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ys(e,t,n);case 2:return c.wck(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Xs(e,t,n);default:throw new es(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ys(e,t,n);case 2:return c.R0O(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return c.R0O(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Xs(e,t,n);default:throw new es(`The axis is not within the rank of the tensor ${r}`)}default:throw new es(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Js(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),c.xWs(e,t)}function ea(e,t){switch(e.rank){case 1:return c.I1m([e,t]);case 2:return c.RPU([e,t],0);case 3:return c.O5O([e,t],0);case 4:return c.P1l([e,t],0);default:throw new es(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function ta(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new es(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return c.Vsq(e,t)}function na(e,t=0,n=1,r,s){return c.FE$(e,t,n,r,s)}function ra(e,t,n,r){if(e.rank<2||t.rank<2)throw new ts(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new ts(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank){const s=!1,a=!1;return c.cZk.matMul({a:e,b:t,transposeA:s,transposeB:a,bias:r?ia(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=c.tQQ(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],d=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=c.tQQ(c.mgz(t,d),[l,-1]);const h=[...s,...u],p=!1,f=!1;return c.tQQ(c.cZk.matMul({a:e,b:t,transposeA:p,transposeB:f,bias:r?ia(e.rank,r,"channelsLast"):null,activation:n}),h)}}function sa(e,t,n){return(0,c.DZQ)((()=>(t=Array.isArray(t)?(0,c.tGX)(t,"int32"):c.wgE(t,"int32"),c.kgh(e,t,n))))}function aa(e){return c.lKK(e,e)}function ia(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new es(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?c.tQQ(t,[1,r[0],1,1,1]):c.tQQ(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?c.tQQ(t,[1,1,1,1,r[0]]):c.tQQ(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?c.tQQ(t,[1,r[0],1,1]):c.tQQ(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?c.tQQ(t,[1,1,1,r[0]]):c.tQQ(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?c.tQQ(t,[1,r[0],1]):c.tQQ(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?c.tQQ(t,[1,1,r[0]]):c.tQQ(t,[1].concat(r))}else if(e<3)return t;throw new es(`Unsupported input rank by biasAdd: ${t.rank}`)}function oa(e,t,n){return(0,c.DZQ)((()=>(null==n&&(n="channelsLast"),Ds(n),c.WQq(e,ia(e.rank,t,n)))))}function la(e,t,n,r){return(0,c.DZQ)((()=>c.EZY(e,t,n,r)))}function ua(e,t,n=!1){return n?e():t()}const ca=["fanIn","fanOut","fanAvg"],da=["normal","uniform","truncatedNormal"];class ha extends c.JFn.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class pa extends ha{apply(e,t){return(0,c.Ul9)(e,t)}}pa.className="Zeros",c.JFn.registerClass(pa);class fa extends ha{apply(e,t){return(0,c.SaS)(e,t)}}fa.className="Ones",c.JFn.registerClass(fa);class ma extends ha{constructor(e){if(super(),"object"!=typeof e)throw new es(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new es(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return(0,c.DZQ)((()=>(0,c.lKK)((0,c.d_2)(this.value),(0,c.SaS)(e,t))))}getConfig(){return{value:this.value}}}ma.className="Constant",c.JFn.registerClass(ma);class ga extends ha{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return(0,c.YeY)(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ga.className="RandomUniform",c.JFn.registerClass(ga);class ba extends ha{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new ts(`randomNormal does not support dType ${t}.`);return na(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ba.className="RandomNormal",c.JFn.registerClass(ba);class ya extends ha{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new ts(`truncatedNormal does not support dType ${t}.`);return(0,c.efE)(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ya.className="TruncatedNormal",c.JFn.registerClass(ya);class wa extends ha{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return(0,c.DZQ)((()=>{if(2!==e.length||e[0]!==e[1])throw new es("Identity matrix initializer can only be used for 2D square matrices.");return(0,c.lKK)(this.gain,(0,c.y5U)(e[0]))}))}getConfig(){return{gain:this.gain}}}wa.className="Identity",c.JFn.registerClass(wa);class va extends ha{constructor(e){if(super(),e.scale<0)throw new es(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,ys(ca,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){ys(da,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(Ds(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=Us(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=Us(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=Us(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new ts(`${this.getClassName()} does not support dType ${t}.`);return(0,c.efE)(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return(0,c.YeY)(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}va.className="VarianceScaling",c.JFn.registerClass(va);class xa extends va{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return va.className}}xa.className="GlorotUniform",c.JFn.registerClass(xa);class _a extends va{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return va.className}}_a.className="GlorotNormal",c.JFn.registerClass(_a);class ka extends va{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return va.className}}ka.className="HeNormal",c.JFn.registerClass(ka);class Sa extends va{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return va.className}}Sa.className="HeUniform",c.JFn.registerClass(Sa);class Ta extends va{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return va.className}}Ta.className="LeCunNormal",c.JFn.registerClass(Ta);class Ia extends va{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return va.className}}Ia.className="LeCunUniform",c.JFn.registerClass(Ia);class Ea extends ha{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return(0,c.DZQ)((()=>{if(e.length<2)throw new ts("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=c.ZSL.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=na([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=c.mPL.qr(a,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=(0,c.lKK)(o,l.sign()),n<r&&(o=o.transpose()),(0,c.lKK)((0,c.d_2)(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Ea.className="Orthogonal",c.JFn.registerClass(Ea);const Aa={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ca(e,t={}){return fs(e,c.JFn.SerializationMap.getMap().classNameMap,t,"initializer")}function Na(e){return hs(e)}function $a(e){if("string"==typeof e){const t=e in Aa?Aa[e]:e;if("GlorotNormal"===t)return new _a;if("GlorotUniform"===t)return new xa;if("HeNormal"===t)return new ka;if("HeUniform"===t)return new Sa;if("LeCunNormal"===t)return new Ta;if("LeCunUniform"===t)return new Ia;{const e={};return e.className=t,e.config={},Ca(e)}}return e instanceof ha?e:Ca(e)}function Oa(e){return Array.isArray(e)&&Array.isArray(e[0])}function Da(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Fa(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new es(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Ra(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new es(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Ma(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const La="Variable";class Pa{constructor(e,t="float32",n=La,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Ss(),n=null==n?La:n,this.originalName=Ps(n),this.name=zs(this.originalName),this.trainable_=r,this.constraint=s,this.val=c.bvq(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function za(e){return e.map((e=>e.read()))}function Ba(e){e.forEach((e=>{e[0].write(e[1])}))}class Va{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Ua{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=Ss(),null!=a&&(this.originalName=Ps(a),this.name=zs(this.originalName)),this.rank=t.length}}let ja=0;class Wa{constructor(e,t){this.callArgs=t,this.id=ja++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Ga=0;class Ha extends c.JFn.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Ga++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=us(e)+"_"+Is(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Jr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new es(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return os(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return os(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Qr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Qr(`Layer ${this.name} is not connected, no input to return.`);return os(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Qr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Qr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return os(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=ls(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=ls(this.inputSpec);if(t.length!==n.length)throw new es(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){const r=t[e],s=n[e];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new es(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new es(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new es(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new es(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const n in s.axes){const r=Number(n),a=s.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new es(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=r.shape[t];if(null!=n&&null!=a&&n!==a)throw new es(`Input ${e} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=ls(e),r=function(e){let t=!0;for(const n of ls(e))if(!(n instanceof Ua)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of ls(e))if(n instanceof Ua){t=!1;break}return t}(e);if(r===s)throw new es("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ls(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of ls(e))t.push(n.shape);this.build(os(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=ls(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=os(a),null!=this.activityRegularizer)throw new ts("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=ls(e);const t=[];for(const n of e)t.push(n.shape);return os(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new Ua(a,n,this,ls(e),t,this.name,r))):new Ua(a,r,this,ls(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new ts("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Qr(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Qr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Jr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Ma(this.weights)}build(e){this.built=!0}getWeights(e=!1){return za(e?this.trainableWeights:this.weights)}setWeights(e){(0,c.DZQ)((()=>{const t=this.weights;if(t.length!==e.length)throw new es(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=za(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!c.ZSL.arraysEqual(a.shape,o.shape))throw new es(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Ba(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new es(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():$a("zeros"));const l=r.apply(t,n),u=new Pa(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=ls(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=ls(t),a=ls(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let e=0;e<s.length;e++)s[e].kerasMask=a[e]}addInboundNode(e,t,n,r,s,a,i=null){const o=ls(e);t=ls(t),n=ls(n),r=ls(r),s=Da(s),a=Da(a);const l=[],u=[],c=[];for(const e of o)l.push(e.sourceLayer),u.push(e.nodeIndex),c.push(e.tensorIndex);new Wa({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function qa(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=qa(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class Za extends Ha{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Is("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new es("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new es("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new es("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new Ua(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Wa({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new es(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function Ka(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new es("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new Za({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}Za.className="InputLayer",c.JFn.registerClass(Za);class Ya{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Ya)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new es(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return(0,c.wgE)(t,e.dtype)}catch(n){throw new es(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Ua){if(null==this.id2Value[e.id])throw new es(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new es(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Ua){if(null==this.id2Value[e.id])throw new es(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new es(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&(0,c.ASo)(this.id2Mask)}}const Xa=new rs,Qa=new rs;function Ja(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const e of o)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const d=o.join(",")+"|"+t.names().sort().join(",");let h,p=Xa.get(d);if(null==p){const e=function(e,t){c.ZSL.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=ti(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=ti(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const e in i)null==r[e]&&(r[e]=new Set),i[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:ei(r)}}(i,t);p=e.sorted,h=e.recipientCounts,Xa.put(d,p),Qa.put(d,h)}h={},s||Object.assign(h,Qa.get(d));const f=new Ya(t);for(let e=0;e<p.length;++e){if(null!=r){const e=(0,c.m1Z)().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const a=p[e],i=a.sourceLayer;if(i instanceof Za)continue;const u=[],d=[],m=[];let g=!1;for(const e of a.inputs){const n=f.getValue(e),r=f.getMask(e);u.push(n),d.push(r),null!=r&&(g=!0),s||(h[e.name]--,0!==h[e.name]||t.hasKey(e)||-1!==o.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||m.push(n))}g&&((n=n||{}).mask=d[0]);const b=ls(i.apply(u,n));let y=null;i.supportsMasking&&(y=i.computeMask(u,d));const w=ni(a),v=Array.isArray(w)?w:[w];for(let e=0;e<v.length;++e){f.hasKey(v[e])||f.add(v[e],b[e],Array.isArray(y)?y[0]:y);const t=o.indexOf(v[e].name);-1!==t&&(l[t]=b[e])}s||(0,c.ASo)(m)}return f.disposeMasks(),a?l:l[0]}function ei(e){const t={};for(const n in e)t[n]=e[n].size;return t}function ti(e,t){const n=new Set,r=[],s={};for(const e of t.names())n.add(e);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function ni(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function ri(e,t){return(0,c.DZQ)((()=>c.RZD(c.czq(c.lKK(e,e),t,!0))))}(0,c._K2)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Xa&&Xa.setMaxEntries(e),null!=Qa&&Qa.setMaxEntries(e)}));class si extends c.JFn.Serializable{getConfig(){return{}}}class ai extends si{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,c.DZQ)((()=>{const t=ri(e,this.axis),n=c.zQh(t,0,this.maxValue);return c.lKK(e,c.y4m(n,c.WQq(qs(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ai.className="MaxNorm",c.JFn.registerClass(ai);class ii extends si{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,c.DZQ)((()=>c.y4m(e,c.WQq(qs(),ri(e,this.axis)))))}getConfig(){return{axis:this.axis}}}ii.className="UnitNorm",c.JFn.registerClass(ii);class oi extends si{apply(e){return c.VVh(e)}}oi.className="NonNeg",c.JFn.registerClass(oi);class li extends si{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,c.DZQ)((()=>{const t=ri(e,this.axis),n=c.WQq(c.lKK(this.rate,c.zQh(t,this.minValue,this.maxValue)),c.lKK(1-this.rate,t));return c.lKK(e,c.y4m(n,c.WQq(qs(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}li.className="MinMaxNorm",c.JFn.registerClass(li);const ui={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ci(e){return hs(e)}function di(e,t={}){return fs(e,c.JFn.SerializationMap.getMap().classNameMap,t,"constraint")}function hi(e){return null==e?null:"string"==typeof e?di({className:e in ui?ui[e]:e,config:{}}):e instanceof si?e:di(e)}function pi(e){return new ai(e)}function fi(e){return new ii(e)}function mi(){return new oi}function gi(e){return new li(e)}function bi(){return new pa}function yi(){return new fa}function wi(e){return new ma(e)}function vi(e){return new ga(e)}function xi(e){return new ba(e)}function _i(e){return new ya(e)}function ki(e){return new wa(e)}function Si(e){return new va(e)}function Ti(e){return new xa(e)}function Ii(e){return new _a(e)}function Ei(e){return new ka(e)}function Ai(e){return new Sa(e)}function Ci(e){return new Ta(e)}function Ni(e){return new Ia(e)}function $i(e){return new Ea(e)}async function Oi(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];(0,c.ASo)(r)}}function Di(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var Fi;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Fi||(Fi={}));class Ri{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Mi{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Li extends Ri{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const s=(0,c.DZQ)((()=>(0,c.WQq)(this.totals[e],(0,c.lKK)(r,n))));this.totals[e]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:(0,c.DZQ)((()=>{const n=(0,c.lKK)((0,c.y4m)(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),(0,c.aCs)(t[e])})))}}class Pi extends Ri{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let a=0;a<s.length;++a)if("number"!=typeof s[a]){const i=s[a];e.push(i.data()),t.push(r),n.push(a)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}class zi extends Ri{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||c.dA1,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");c.ZSL.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():c.ZSL.now();return(...a)=>{const i=null!=n?n():c.ZSL.now();return i-s<t||(s=i,r=e(...a)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await Oi(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Oi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Oi(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Oi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Oi(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):c.ZSL.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Oi(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Oi(e),await this.trainEnd(e))}}function Bi(e,t){return null==e&&(e={}),e instanceof Ri?[e]:Array.isArray(e)&&e[0]instanceof Ri?e:ls(e).map((e=>new zi(e,t)))}class Vi{constructor(){}static registerCallbackConstructor(e,t){c.ZSL.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),Vi.checkForDuplicate(t),null==Vi.constructors[e]&&(Vi.constructors[e]=[]),Vi.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Vi.constructors)Vi.constructors[+t].forEach((t=>{if(t===e)throw new es("Duplicate callback constructor.")}))}static clear(){Vi.constructors={}}static createCallbacks(e){const t=[];for(const n in Vi.constructors){const r=+n;e>=r&&t.push(...Vi.constructors[r])}return t.map((e=>new e))}}function Ui(e,t,n,r,s,a,i,o,l){const u=new Pi,c=[new Li,...Vi.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new Mi(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function ji(e,t={},n=!1){return fs(e,c.JFn.SerializationMap.getMap().classNameMap,t,"layer",n)}function Wi(e,t){return(0,c.DZQ)((()=>{"float32"!==e.dtype&&(e=c.wgE(e,"float32"));const n=c.czq(aa(e),t,!0),r=c.GSj(n.shape,qs()),s=c.RZD(c.PhQ(n,r));return c.y4m(e,s)}))}function Gi(e,t){return(0,c.DZQ)((()=>c.i2o(aa(c.jbE(t,e)),-1)))}function Hi(e,t){return(0,c.DZQ)((()=>c.i2o(c.tnl(c.jbE(t,e)),-1)))}function qi(e,t){return(0,c.DZQ)((()=>{const n=c.jbE(e,t),r=c.zQh(c.tnl(e),qs(),Number.MAX_VALUE),s=c.tnl(c.y4m(n,r));return c.lKK(100,c.i2o(s,-1))}))}function Zi(e,t,n=!1){return(0,c.DZQ)((()=>{if(n)t=c.Vs9(t);else{const e=c.czq(t,t.shape.length-1,!0);t=c.y4m(t,e)}return t=c.zQh(t,qs(),1-qs()),c.HZy(c.czq(c.lKK(c.wgE(e,"float32"),c.Rm2(t)),t.shape.length-1))}))}function Ki(e,t,n=!1){return(0,c.DZQ)((()=>{const r=c.wgE(c.RIf(function(e){const t=[Us(e.shape)];return c.tQQ(e,t)}(e)),"int32"),s=(t=c.zQh(t,qs(),1-qs())).shape;return Zi(c.tQQ(c.Mw0(r,s[s.length-1]),s),t,n)}))}function Yi(e,t){return(0,c.DZQ)((()=>{let n;return n=c.zQh(t,qs(),1-qs()),n=c.Rm2(c.y4m(n,c.jbE(1,n))),c.i2o(function(e,t){if(!c.ZSL.arraysEqual(e.shape,t.shape))throw new es(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return(0,c.DZQ)((()=>{const n=c.VVh(t),r=c.HZy(c.tnl(t));return c.WQq(c.jbE(n,c.lKK(t,e)),c.Kko(c.oNF(r)))}))}(e,n),-1)}))}function Xi(e,t){return(0,c.DZQ)((()=>{const n=Wi(e,-1),r=Wi(t,-1),s=c.lKK(n,r);return c.HZy(c.czq(s,-1))}))}Vi.constructors={};const Qi={meanSquaredError:Gi,meanAbsoluteError:Hi,meanAbsolutePercentageError:qi,meanSquaredLogarithmicError:function(e,t){return(0,c.DZQ)((()=>{const n=c.zQh(t,qs(),Number.MAX_VALUE),r=c.Rm2(c.WQq(1,n)),s=c.zQh(e,qs(),Number.MAX_VALUE),a=c.Rm2(c.WQq(1,s));return c.i2o(aa(c.jbE(r,a)),-1)}))},squaredHinge:function(e,t){return(0,c.DZQ)((()=>{const n=c.PhQ(0,c.jbE(1,c.lKK(e,t)));return c.i2o(aa(n),-1)}))},hinge:function(e,t){return(0,c.DZQ)((()=>{const n=c.PhQ(0,c.jbE(1,c.lKK(e,t)));return c.i2o(n,-1)}))},categoricalHinge:function(e,t){return(0,c.DZQ)((()=>{const n=c.czq(c.lKK(e,t),-1),r=c.T9B(c.lKK(c.jbE(1,e),t),-1);return c.PhQ(0,c.WQq(1,c.jbE(r,n)))}))},logcosh:function(e,t){return(0,c.DZQ)((()=>{const n=Math.log(2),r=c.jbE(t,e),s=c.jbE(c.WQq(r,c.lw0(c.lKK(-2,r))),n);return c.i2o(s,-1)}))},categoricalCrossentropy:Zi,sparseCategoricalCrossentropy:Ki,binaryCrossentropy:Yi,kullbackLeiblerDivergence:function(e,t){return(0,c.DZQ)((()=>{const n=c.zQh(e,qs(),1),r=c.zQh(t,qs(),1);return c.czq(c.lKK(e,c.Rm2(c.y4m(n,r))),-1)}))},poisson:function(e,t){return(0,c.DZQ)((()=>{const n=c.Rm2(c.WQq(qs(),t));return c.i2o(c.jbE(t,c.lKK(e,n)),-1)}))},cosineProximity:Xi};function Ji(e){if("string"==typeof e){if(e in Qi)return Qi[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new es(t)}return e}function eo(e,t){return(0,c.DZQ)((()=>{const n=c.lKK(.5,c.P61(t)),r=Zs(c.rhj(t,n),e.dtype);return c.i2o(c.LCg(e,r),-1)}))}function to(e,t){return(0,c.DZQ)((()=>Zs(c.LCg(c.FLi(e,-1),c.FLi(t,-1)),"float32")))}function no(e,t){return(0,c.DZQ)((()=>c.wgE(c.czq(c.n76(c.LCg(e,1),c.LCg(t,1))),"float32")))}function ro(e,t){return(0,c.DZQ)((()=>{const n=no(e,t),r=function(e,t){return(0,c.DZQ)((()=>c.wgE(c.czq(c.n76(c.LCg(e,0),c.LCg(t,1))),"float32")))}(e,t),s=c.WQq(n,r);return c.wgE(c._M9(c.rhj(s,0),c.y4m(n,s),0),"float32")}))}function so(e,t){return Yi(e,t)}function ao(e,t){return e.rank===t.rank&&(e=c.r2V(e,[e.rank-1])),(t=c.FLi(t,-1)).dtype!==e.dtype&&(t=c.wgE(t,e.dtype)),c.wgE(c.LCg(e,t),"float32")}const io=Zi,oo=Ki,lo={binaryAccuracy:eo,categoricalAccuracy:to,precision:ro,categoricalCrossentropy:io,sparseCategoricalCrossentropy:oo,mse:Gi,MSE:Gi,mae:Hi,MAE:Hi,mape:qi,MAPE:qi,cosine:Xi};function uo(e){if("string"==typeof e&&e in lo)return lo[e];if("string"!=typeof e&&null!=e)return e;throw new es(`Unknown metric ${e}`)}function co(e){if(as(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(Qi))if(Qi[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(lo))if(lo[n]===e){t=n;break}return void 0!==t?t:e.name}}function ho(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!po(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function po(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!po(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!po(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function fo(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function mo(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}fo([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function go(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(e){s="multiple"}const i=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],s=t.tensorIndices[e];i.push(`${n}[${r}][${s}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];fo([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let e=1;e<i.length;++e)fo(["","","","",i[e]],t,r)}function bo(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function yo(e,t){if(null===e)return null;if("string"==typeof e)return cs(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];bo(t,s,r)?n.push(r):n.push(yo(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=cs(n);t[e]=yo(r,e)}}return t}}function wo(e,t){if(null==e)return null;if("string"==typeof e)return us(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];bo(t,s,r)?n.push(r):n.push(wo(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[us(n)]="name"!==n&&"className"!==n||"string"!=typeof r?wo(r,n):r}return t}}const vo="4.18.0";class xo extends Ha{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Is(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],gs(this.inputs).length!==this.inputs.length)throw new es(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);gs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;as(0===n,"input layer has >1 nodes"),as(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof Za))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new Jr(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(xo.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let e=0;e<c;e++){const r=u.inputTensors[e],s=u.inboundLayers[e],a=u.nodeIndices[e],i=u.tensorIndices[e];o(r,t,n,s,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const e of this.outputs)o(e,l,u);const c=i.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let a=t[e.id];const i=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];a=Math.max(a,i),r[e.outboundLayer.id]=a,s[e.outboundLayer.id]=e.outboundLayer,t[e.id]=a;for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.nodeIndices[r],o=s.inboundNodes[i],l=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(a+1,l),n[o.id]=o}}const d={};for(const e in t){const r=t[e];r in d||(d[r]=[]),d[r].push(n[e])}const h={};for(const e in r){const t=r[e];t in h||(h[t]=[]),h[t].push(s[e])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(ms);this.layers=[];for(const e of p){const t=h[e];t.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof xo&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(ms);const f=this.inputs.slice(),m=[];for(const e of p)for(const t of d[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new Jr(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const e of g){const t=g.filter((t=>t===e)).length;if(1!==t)throw new Jr(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Wa({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new es("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const e of this.layers)for(const[t,a]of e.weights.entries()){const e=s?`${a.name.split("/").slice(0,-1).join("/")+"/"}${t}`:a.originalName;if(null!=n[e])throw new es(`Duplicate weight name: ${e}`);n[e]=a,r++}const a=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])a.push([n[s],e[r]]);else if(t)throw new es(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new es(`${e.length} of ${r} weights are not set: ${e}`)}Ba(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${vo}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=wo(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return(0,c.DZQ)((()=>{e=ls(e);const n=new Ya;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Ja(this.outputs,n,t)}))}computeMask(e,t){return(0,c.DZQ)((()=>{let n;return e=ls(e),n=null==t?ss(null,e.length):ls(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Da(e);if(t.length!==this.inputLayers.length)throw new es(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],s=t[e];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(ms);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const s=e.inboundLayers[t],a=e.nodeIndices[t],i=e.tensorIndices[t],o=n[`${s.name}_${a}_${i}`];r.push(o)}const s=Da(t.computeOutputShape(os(r))),a=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++)n[`${t.name}_${a}_${e}`]=s[e]}}const s=[],a=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],s=`${t.name}_${n}_${r}`;a.push(s)}for(let e=0;e<a.length;e++){const t=a[e];as(t in n),s.push(n[t])}return os(s)}runInternalGraph(e,t){null==t&&(t=ss(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],a=e[r],i=t[r];n[s.id]=[a,i]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(ms);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,a=new Array;for(const e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===a.length){const[e,n]=a[0];null==u.mask&&(u.mask=n),o=ls(t.call(e,u)),l=ls(t.computeMask(e,n)),r=[e],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==u.mask&&(u.mask=i),o=ls(t.call(r,u)),l=ls(t.computeMask(r,i));if(t.activityRegularizer)throw new ts("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const e of this.outputs){as(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];i.push(t.shape),s.push(t),a.push(r)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof xo?1:0;for(let r=0;r<e.inboundNodes.length;r++){const s=xo.nodeKey(e,r);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new es("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(const t of this.layers)if(t.name===e)return t;throw new es(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new es(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return(0,c.DZQ)((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=xo.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),s=e.getConfig(),a=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],s=xo.nodeKey(e,n);let i={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],a=r.nodeIndices[n],o=r.tensorIndices[n];let l=t[xo.nodeKey(s,a)];null==l&&(l=0),e.push([s.name,l,o,i])}a.push(e)}}}const i={};i.name=e.name,i.className=r,i.config=s,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],s=this.inputLayersNodeIndices[e],a=xo.nodeKey(n,s);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.inputLayersTensorIndices[e];r.push([n.name,i,o])}e.inputLayers=r;const s=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],a=xo.nodeKey(n,r);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.outputLayersTensorIndices[e];s.push([n.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],l=a[1],u=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=l)return void i(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(os(n),r)}function l(e){const n=e.name,a=ji(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new es(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const u=t.name,c=t.layers;for(const e of c)l(e);for(;!bs(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const d=[],h=[],p=t.inputLayers;for(const e of p){const t=e[0],n=e[1],r=e[2];as(t in s);const a=s[t].inboundNodes[n].outputTensors;d.push(a[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];as(t in s);const a=s[t].inboundNodes[n].outputTensors;h.push(a[r])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new es("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){(0,c.DZQ)((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function _o(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function ko(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=(0,c.DZQ)((()=>{if(1===e.shape.length)return(0,c.o8B)(e);if(2===e.shape.length){if(e.shape[1]>1){const t=1;return(0,c.FLi)(e,t)}if(1===e.shape[1])return(0,c.tQQ)(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());(0,c.ASo)(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),(0,c.tGX)(s,"float32")}return null}function So(e,t){return(0,c.lKK)(e,t)}function To(e,t){let n,r;const s=t;n=s.xs,r=s.ys,c.ZSL.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=Io("input",e.inputNames,n),i=Io("output",e.outputNames,r),o=a[0].shape[0];c.ZSL.assert(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),c.ZSL.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<a.length;t++)c.ZSL.assert(a[t].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let t=0;t<i.length;t++)c.ZSL.assert(i[t].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function Io(e,t,n){if(n instanceof c.qYS)return[n];if(Array.isArray(n))return c.ZSL.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new es(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function Eo(e){return"function"==typeof e.iterator}function Ao(e){c.ZSL.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Co(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Ys(e,t,n-t))):Ys(e,t,n-t)}function No(e,t){return c.DZQ((()=>null==e?null:Array.isArray(e)?e.map((e=>No(e,t))):sa(e,"int32"===t.dtype?t:c.wgE(t,"int32"))))}function $o(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function Oo(e){const t=[];e instanceof c.qYS&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(Ks(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Do(e,t){if(null==e)return;const n=[];if(t instanceof c.qYS)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof c.qYS)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const t in e){const s=e[t];-1===n.indexOf(s.id)&&r.push(s)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Fo(e){return Array.isArray(e)}function Ro(e){return!function(e){return e instanceof c.qYS}(e)&&!Fo(e)}function Mo(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(Fo(e)&&e.length>0)t=!0;else if(Ro(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new es(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let a;if(Ro(e)){a=[];for(const n of t){if(null==e[n])throw new es(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(Fo(e)){if(e.length!==t.length)throw new es(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new es(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=Oo(a),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new es(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const a=i.shape[t],o=n[e][t];if(null!=o&&o>=0&&a!==o)throw new es(`${s} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function Lo(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new es(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new es(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new es(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const o=i.shape[a],l=n[e][a];if(null!=l&&l!==o)throw new es(`Error when checking ${s}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class Po extends xo{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new es("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),fo(a,n,r),r("=".repeat(t));const o=e.layers;for(let e=0;e<o.length;++e)s?mo(o[e],n,r):go(o[e],n,i,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;return t=null!=e.collectedTrainableWeights?Ma(e.collectedTrainableWeights):Ma(e.trainableWeights),t}(e),u=Ma(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>c.BaG.adagrad(.01),Adadelta:()=>c.BaG.adadelta(1,.95,qs()),Adam:()=>c.BaG.adam(.001,.9,.999,qs()),Adamax:()=>c.BaG.adamax(.002,.9,.999,qs(),0),RMSProp:()=>c.BaG.rmsprop(.001,.9,0,qs()),SGD:()=>c.BaG.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new es(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof c.ELo))throw new es("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new es(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>Ji(e)))}else{const n=Ji(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new es(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(Ji(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ls("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Ls("metric",(()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===Yi?-1!==["accuracy","acc"].indexOf(i)?r=eo:-1!==["crossentropy","ce"].indexOf(i)&&(r=so):this.lossFunctions[e]===Ki?-1!==["accuracy","acc"].indexOf(i)?r=ao:-1!==["crossentropy","ce"].indexOf(i)&&(r=oo):-1!==["accuracy","acc"].indexOf(i)?r=to:-1!==["crossentropy","ce"].indexOf(i)&&(r=io),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=uo(i);a=e,n=""+co(i)}let t;Ls(n,(()=>{t=a})),s(e,n,t)}})(r[e])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;Ao(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return os(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Do(s[0],e),Do(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new ts("Verbose mode is not implemented yet.");c.ZSL.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"==typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=c.DZQ((()=>{if(t.value){const{xs:n,ys:r}=To(e,t.value),i=n.concat(r),u=c.DZQ((()=>s(i)));if(c.ASo(i),0===l)for(let e=0;e<u.length;++e)a.push((0,c.d_2)(0));const d=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=c.DZQ((()=>c.WQq(a[e],c.lKK(d,t)))),l>0&&c.ASo(n)}c.ASo(u),o+=d,++l}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<a.length;++e){const t=a[e];a[e]=c.y4m(a[e],o),c.ASo(t)}return os(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new es(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new es(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new es("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Ya;if(e instanceof c.qYS&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new es(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new es(`No value is provided for the model's input ${t.name}`);a.add(t,n)}const i=Ja(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=ss(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new es(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return c.DZQ((()=>{const r=this.checkNumSamples(e);if(n)throw new ts("Verbose predictLoop() is not implemented yet.");const s=$o(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t)c.DZQ((()=>{const n=s[t][0],r=s[t][1],a=Co(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new Ya(i);return Ja(this.outputs,o)})).forEach(((e,t)=>a[t].push(e)));return os(a.map((e=>c.xWs(e,0))))}))}predict(e,t={}){const n=Oo(e);Lo(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Ao(e),this.predictLoop(n,e)}finally{Do(n,e)}}predictOnBatch(e){Lo(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new Jr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===Ki?s.push(t.slice(0,t.length-1).concat([1])):s.push(t)}if(function(e,t,n){const r=gs(e.map((e=>e.shape[0])));r.sort();const s=gs(t.map((e=>e.shape[0])));if(s.sort(),r.length>1)throw new es(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(s.length>1)throw new es(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&s.length>0&&!c.ZSL.arraysEqual(r,s))throw new es(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=Mo(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Mo(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[Gi,Yi,Zi];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===Zi&&1===a.shape[a.shape.length-1])throw new es(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new es(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new es(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=_o(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await ko(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return c.DZQ((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new ts("Verbose mode is not implemented yet.");if(null!=s)throw new ts("steps mode in testLoop() is not implemented yet");{const r=$o(a,n),s=(0,c.tGX)(Gs(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=Ys(s,a,o-a),u=No(t,l),d=e(u);if(0===n)for(let e=0;e<d.length;++e)i.push((0,c.d_2)(0));for(let e=0;e<d.length;++e){const t=d[e];i[e]=c.WQq(i[e],c.lKK(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=c.y4m(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;is(e,r)>1&&(s+=`_${is(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new Ya(e),o=Ja(this.outputs,i,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],o[e]);null!=s[e]&&(n=So(n,s[e]));const a=c.i2o(n);t.push(a),l=0===e?n:c.WQq(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],s=this.metricsTensors[e][1];n=c.i2o(t(r[s],o[s]))}c.aCs(n),a.push(n)}return l=c.i2o(l),this.calculateLosses().forEach((e=>{l=c.WQq(l,e)})),l}),!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>c.DZQ((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new Ya(a),o=Ja(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=c.i2o(r(s[e],o[e]));n=0===e?a:c.WQq(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=c.i2o(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,o,l,u,d,h;this.isTraining=!0;try{const c=null==n.batchSize?32:n.batchSize;Ao(c);const p=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,p,c);r=f[0],s=f[1],h=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new ts("validationData including sample weights is not supported yet."):new es(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],l=n.validationData[1];const e=!0,t=await this.standardizeUserData(o,l,null,null,e,c);u=t[0],d=t[1],m=u.concat(d)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=Co(r,e,t),a=r,r=Co(r,0,e),d=Co(s,e,t),i=s,s=Co(s,0,e),m=u.concat(d)}else null!=n.validationSteps&&(g=!0);const b=r.concat(s).concat(h);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let v,x;g?(this.makeTestFunction(),v=this.testFunction,x=w.slice().concat(w.map((e=>"val_"+e)))):(v=null,m=[],x=w.slice());const _=Bi(n.callbacks,n.yieldEvery);return await this.fitLoop(y,b,w,c,n.epochs,n.verbose,_,v,m,n.shuffle,x,n.initialEpoch,null,null)}finally{this.isTraining=!1,Do(r,e),Do(s,t),Do(a,e),Do(i,t),Do(u,o),Do(d,l),null!=h&&c.ASo(h)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,d,h,p,f){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==h&&(h=0);let m=!1;if(null!=o&&null!=l&&(m=!0),null!=f&&(m=!0,null==p))throw new es("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,r,p,"steps_per_epoch");let b;null!=g&&(b=Gs(0,g)),null==a&&(a=1);const{callbackList:y,history:w}=Ui(i,a,s,h,g,p,r,m,d);y.setModel(this),this.history=w,await y.onTrainBegin(),this.stopTraining_=!1;for(let a=h;a<s;++a){await y.onEpochBegin(a);const s={};if(null!=p)throw new ts("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new ts("batch shuffling is not implemneted yet");u&&c.ZSL.shuffle(b);const a=(0,c.tGX)(b),i=$o(g,r);for(let u=0;u<i.length;++u){const d={};if(await y.onBatchBegin(u,d),c.DZQ((()=>{const h=i[u][0],p=i[u][1],f=Ys(a,h,p-h);d.batch=u,d.size=p-h;const g=No(t,f),b=e(g);for(let e=0;e<n.length;++e){const t=n[e],r=b[e];d[t]=r,c.aCs(r)}if(u===i.length-1&&m){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];c.aCs(a),s["val_"+r]=a}}})),await y.onBatchEnd(u,d),Di(d),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(a,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return async function(e,t,n){const r=null!=n.batchesPerEpoch;if(c.ZSL.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),c.ZSL.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),c.ZSL.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),c.ZSL.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),c.ZSL.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(Eo(n.validationData))c.ZSL.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new ts("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const d=Bi(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=Ui(d,h,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,s,u);p.setModel(e),e.history=f,await p.onTrainBegin(),e.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;m<n.epochs;){const u={};await p.onEpochBegin(m);let d=0,h=0;for(r||(g=await t.iterator());!r||d<n.batchesPerEpoch;){const t=await g.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${d} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=To(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],await p.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=_o(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await ko(s[e],null,t[e]))}const u=r.concat(s).concat(i),f=o(u);c.ASo(u);for(let e=0;e<l.length;++e){const t=l[e],n=f[e];a[t]=n,c.aCs(n)}await p.onBatchEnd(h,a),Di(a),h++,d++}if(r?d>=n.batchesPerEpoch:t.done){if(s){let t;t=Eo(n.validationData)?ls(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):ls(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(m,u),m++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const e of a){const t=await e.data();i.push(t[0])}return c.ASo(a),Do(n[0],e),Do(n[1],t),os(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:s[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=c.m1Z().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-c.m1Z().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=us(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>us(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=us(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[us(co(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>us(co(e))));{const e={};for(const t in this.metrics)e[t]=us(co(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=ji(yo(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=cs(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>cs(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=cs(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>cs(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=cs(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=c.io.getSaveHandlers(e);if(0===t.length)throw new es(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new es(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new es("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await c.io.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${vo}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await c.io.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=c.io.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;ho(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){ho(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Po.className="Model",c.JFn.registerClass(Po);class zo extends Po{}async function Bo(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);const r=ji(yo(n),t);if(null!=e.weightsManifest){const t=await c.io.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(const e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),(0,c.ASo)(t)}return r}async function Vo(e,t){if(null==t&&(t={}),"string"==typeof e){const n=c.io.getLoadHandlers(e,t);if(0===n.length)n.push(c.io.browserHTTPRequest(e,t));else if(n.length>1)throw new es(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new es("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const a=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&a,o=ji(yo(s),void 0,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new es("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=c.io.decodeWeights(e,t),r={},s=[];return t.forEach((e=>{"optimizer"===e.group?s.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);o.loadWeights(e,a),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),(0,c.ASo)(e),(0,c.ASo)(t.map((e=>e.tensor)))}return o}(e,0,t)}zo.className="Functional",c.JFn.registerClass(zo);class Uo extends Po{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Is("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new es(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Uo||e instanceof Po;let n;if(t){if(n=e,1!==n.outputs.length)throw new es("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new es("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new es("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=Ka({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new es(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new es("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=qa(this.outputs[0])}this.inboundNodes=[],new Wa({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ss(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Ra(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Po({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new es("Legacy serialization format not supported yet.");s=t}else c.ZSL.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof Uo))throw new ts(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const e of s){const t=ji(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new es("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new es("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function jo(e){return new Po(e)}function Wo(e){return new Uo(e)}function Go(e){return Ka(e)}function Ho(e,t){Vi.registerCallbackConstructor(e,t)}Uo.className="Sequential",c.JFn.registerClass(Uo);class qo extends c.JFn.Serializable{getConfig(){return{}}}class Zo extends qo{apply(e,t=1){return function(e,t=1){if(1!==t)throw new ts(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return c.Pqc(e)}(e,t)}}Zo.className="elu",c.JFn.registerClass(Zo);class Ko extends qo{apply(e){return c.WfX(e)}}Ko.className="selu",c.JFn.registerClass(Ko);class Yo extends qo{apply(e){return c.VVh(e)}}Yo.className="relu",c.JFn.registerClass(Yo);class Xo extends qo{apply(e){return(0,c.DZQ)((()=>c.BpO(6,c.VVh(e))))}}Xo.className="relu6",c.JFn.registerClass(Xo);class Qo extends qo{apply(e){return e}}Qo.className="linear",c.JFn.registerClass(Qo);class Jo extends qo{apply(e){return c.ry7(e)}}Jo.className="sigmoid",c.JFn.registerClass(Jo);class el extends qo{apply(e){return function(e){return(0,c.DZQ)((()=>{const t=c.WQq(.5,c.lKK(.2,e));return c.zQh(t,0,1)}))}(e)}}el.className="hardSigmoid",c.JFn.registerClass(el);class tl extends qo{apply(e){return c.lw0(e)}}tl.className="softplus",c.JFn.registerClass(tl);class nl extends qo{apply(e){return function(e){return(0,c.DZQ)((()=>c.y4m(e,c.WQq(c.tnl(e),1))))}(e)}}nl.className="softsign",c.JFn.registerClass(nl);class rl extends qo{apply(e){return c.ymU(e)}}rl.className="tanh",c.JFn.registerClass(rl);class sl extends qo{apply(e,t=-1){return c.Vs9(e,t)}}sl.className="softmax",c.JFn.registerClass(sl);class al extends qo{apply(e,t=-1){return c.HPB(e,t)}}al.className="logSoftmax",c.JFn.registerClass(al);class il extends qo{apply(e,t=1){return(0,c.DZQ)((()=>c.lKK(c.ry7(c.lKK(e,t)),e)))}}il.className="swish",c.JFn.registerClass(il);class ol extends qo{apply(e){return(0,c.DZQ)((()=>c.lKK(e,c.ymU(c.lw0(e)))))}}function ll(e){return e.getClassName()}function ul(e,t={}){return fs(e,c.JFn.SerializationMap.getMap().classNameMap,t,"activation")}function cl(e){if(null==e){return ul({className:"linear",config:{}})}if("string"==typeof e){const t={};return t.className=e,t.config={},ul(t)}return e instanceof qo?e:ul(e)}function dl(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}ol.className="mish",c.JFn.registerClass(ol);class hl extends c.JFn.Serializable{}class pl extends hl{constructor(e){super(),dl(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,c.DZQ)((()=>{let t=(0,c.Ul9)([1]);return this.hasL1&&(t=(0,c.WQq)(t,(0,c.czq)(c.lKK(this.l1,(0,c.tnl)(e))))),this.hasL2&&(t=(0,c.WQq)(t,(0,c.czq)(c.lKK(this.l2,aa(e))))),c.tQQ(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}pl.className="L1L2",c.JFn.registerClass(pl);const fl={l1l2:"L1L2"};function ml(e){return hs(e)}function gl(e,t={}){return fs(e,c.JFn.SerializationMap.getMap().classNameMap,t,"regularizer")}function bl(e){return null==e?null:"string"==typeof e?gl({className:e in fl?fl[e]:e,config:{}}):e instanceof hl?e:gl(e)}class yl extends Ha{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Fa(e);let n=(0,c.VVh)(e);return null!=this.maxValue&&(n=(0,c.zQh)(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}yl.className="ReLU",c.JFn.registerClass(yl);class wl extends Ha{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Fa(e);return(0,c.H8d)(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}wl.className="LeakyReLU",c.JFn.registerClass(wl);class vl extends Ha{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=$a(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=bl(e.alphaRegularizer),this.alphaConstraint=hi(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new es(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=Ra(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new Va({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Fa(e),(0,c.NsG)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Na(this.alphaInitializer),alphaRegularizer:ml(this.alphaRegularizer),alphaConstraint:ci(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}vl.className="PReLU",c.JFn.registerClass(vl);class xl extends Ha{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new ts(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Fa(e);return(0,c.Pqc)(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}xl.className="ELU",c.JFn.registerClass(xl);class _l extends Ha{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Fa(e);return(0,c.lKK)(n,(0,c.wgE)((0,c.rhj)(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}_l.className="ThresholdedReLU",c.JFn.registerClass(_l);class kl extends Ha{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new sl).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return(0,c.DZQ)((()=>{let n=Fa(e);const r=t.mask;if(null!=r){const e=(0,c.lKK)((0,c.jbE)((0,c.SaS)(n.shape),(0,c.wgE)(r,n.dtype)),(0,c.d_2)(-1e9));n=(0,c.WQq)(n,e)}return this.axis instanceof Array?this.axis.length>1?(0,c.oNF)((0,c.jbE)(n,(0,c.VZ)(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Sl(e,t,n){if("number"==typeof e)return ss(e,t);if(e.length!==t)throw new es(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new es(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function Tl(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function Il(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+Ws([n-t,0]);else{if("same"!==r)throw new es(`Unsupport padding mode: ${r}.`);e*=t}return e}function El(e,t){return(0,c.DZQ)((()=>(Ds(t),"channelsFirst"===t?c.mgz(e,[0,2,3,1]):e)))}function Al(e,t){return(0,c.DZQ)((()=>(Ds(t),"channelsFirst"===t?c.mgz(e,[0,2,3,4,1]):e)))}function Cl(e,t,n,r=[1,1],s="valid",a,i,o=null){return(0,c.DZQ)((()=>{if(null==a&&(a="channelsLast"),Ds(a),3!==e.rank&&4!==e.rank)throw new es(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new es(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=El(e,a);if("causal"===s)throw new ts("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=c.cZk.conv2d({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=c.mgz(l,[0,3,1,2])),l}))}kl.className="Softmax",c.JFn.registerClass(kl);class Nl extends Ha{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Nl.verifyArgs(t),this.rank=e,vs(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new ts(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Sl(t.kernelSize,e,"kernelSize"),this.strides=Sl(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Fs(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ds(this.dataFormat),this.activation=cl(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=$a(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=hi(t.biasConstraint),this.biasRegularizer=bl(t.biasRegularizer),this.activityRegularizer=bl(t.activityRegularizer),this.dilationRate=Sl(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new es(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new es(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new es(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(as("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!ws(e.kernelSize,"number",1,3))throw new es(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ll(this.activation),useBias:this.useBias,biasInitializer:Na(this.biasInitializer),biasRegularizer:ml(this.biasRegularizer),activityRegularizer:ml(this.activityRegularizer),biasConstraint:ci(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class $l extends Nl{constructor(e,t){super(e,t),this.kernel=null,$l.verifyArgs(t),this.filters=t.filters,vs(this.filters,"filters"),this.kernelInitializer=$a(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=hi(t.kernelConstraint),this.kernelRegularizer=bl(t.kernelRegularizer)}build(e){e=Ra(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new es(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return(0,c.DZQ)((()=>{let t;e=Fa(e);const n=null==this.bias?null:this.bias.read(),r=_s(this.activation.getClassName());if(null!=r&&2===this.rank)t=Cl(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",a,i=1){return(0,c.DZQ)((()=>{if(null==a&&(a="channelsLast"),Ds(a),3!==e.shape.length)throw new es(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new es(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new es(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(e=c.mgz(e,[0,2,1])),"causal"===s)throw new ts("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=c.kA9(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=oa(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Cl(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new ts("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",a,i){return(0,c.DZQ)((()=>{if(null==a&&(a="channelsLast"),Ds(a),4!==e.rank&&5!==e.rank)throw new es(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new es(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Al(e,a);if("causal"===s)throw new ts("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=c.IPL(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=oa(o,n)),"channelsFirst"===a&&(o=c.mgz(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Ra(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=Tl(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Na(this.kernelInitializer),kernelRegularizer:ml(this.kernelRegularizer),kernelConstraint:ci(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new es(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Ol extends $l{constructor(e){super(2,e),Ol.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!ws(e.kernelSize,"number",1,2))throw new es(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Ol.className="Conv2D",c.JFn.registerClass(Ol);class Dl extends $l{constructor(e){super(3,e),Dl.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new es(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Dl.className="Conv3D",c.JFn.registerClass(Dl);class Fl extends Ol{constructor(e){if(super(e),this.inputSpec=[new Va({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new es(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Ra(e)).length)throw new es("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new es("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Va({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return c.DZQ((()=>{let t=Fa(e);if(4!==t.shape.length)throw new es(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=[r,Il(i,d,l,this.padding),Il(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=c.mgz(t,[0,2,3,1]));let f=c.wX9(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(f=c.mgz(f,[0,3,1,2])),null!=this.bias&&(f=oa(f,this.bias.read(),this.dataFormat)),null!=this.activation&&(f=this.activation.apply(f)),f}))}computeOutputShape(e){const t=(e=Ra(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Il(t[r],o,a,this.padding),t[s]=Il(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Fl.className="Conv2DTranspose",c.JFn.registerClass(Fl);class Rl extends Dl{constructor(e){if(super(e),this.inputSpec=[new Va({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new es(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Ra(e)).length)throw new es("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new es("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Va({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return c.DZQ((()=>{let t=Fa(e);if(5!==t.shape.length)throw new es(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],b=[r,Il(o,f,d,this.padding),Il(l,m,h,this.padding),Il(u,g,p,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=c.mgz(t,[0,2,3,4,1]));let y=c.jIJ(t,this.kernel.read(),b,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=c.mgz(y,[0,4,1,2,3])),null!==this.bias&&(y=oa(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=Ra(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=Il(t[r],u,i,this.padding),t[s]=Il(t[s],c,o,this.padding),t[a]=Il(t[a],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Rl.className="Conv3DTranspose",c.JFn.registerClass(Rl);class Ml extends $l{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new es("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new es("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new es(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=$a(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=bl(t.depthwiseRegularizer),this.depthwiseConstraint=hi(t.depthwiseConstraint),this.pointwiseInitializer=$a(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=bl(t.pointwiseRegularizer),this.pointwiseConstraint=hi(t.pointwiseConstraint)}build(e){if((e=Ra(e)).length<this.rank+2)throw new es(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new es(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let e=0;e<this.rank;++e)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Va({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return(0,c.DZQ)((()=>{let t;if(e=Fa(e),1===this.rank)throw new ts("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=c.mgz(e,[0,2,3,1])),t=c.wdz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=oa(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=c.mgz(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Na(this.depthwiseInitializer),e.pointwiseInitializer=Na(this.pointwiseInitializer),e.depthwiseRegularizer=ml(this.depthwiseRegularizer),e.pointwiseRegularizer=ml(this.pointwiseRegularizer),e.depthwiseConstraint=ci(this.depthwiseConstraint),e.pointwiseConstraint=ci(this.pointwiseConstraint),e}}Ml.className="SeparableConv";class Ll extends Ml{constructor(e){super(2,e)}}Ll.className="SeparableConv2D",c.JFn.registerClass(Ll);class Pl extends $l{constructor(e){super(1,e),Pl.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!ws(e.kernelSize,"number",1,1))throw new es(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Pl.className="Conv1D",c.JFn.registerClass(Pl);class zl extends Ha{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return(0,c.DZQ)((()=>{if(e=Fa(e),"channelsLast"===this.dataFormat){const t=Qs(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Qs(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Qs(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Qs(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}zl.className="Cropping2D",c.JFn.registerClass(zl);class Bl extends Ha{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ds(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,ys(As,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return c.DZQ((()=>{let t=Fa(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=c.mgz(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?c.image.resizeNearestNeighbor(t,[e,r]):c.image.resizeBilinear(t,[e,r]);return c.mgz(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?c.image.resizeNearestNeighbor(t,[e,r]):c.image.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Bl.className="UpSampling2D",c.JFn.registerClass(Bl);class Vl extends Nl{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=$a(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=hi(e.depthwiseConstraint),this.depthwiseRegularizer=bl(e.depthwiseRegularizer)}build(e){if((e=Ra(e)).length<4)throw new es(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new es(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,c.DZQ)((()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return(0,c.DZQ)((()=>{null==s&&(s="channelsLast"),Ds(s);let i=El(e,s);if(4!==e.rank)throw new es(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new es(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=c.Gl3(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=c.mgz(i,[0,3,1,2])),i}))}(e=Fa(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=oa(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Ra(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Tl(t,this.kernelSize[0],this.padding,this.strides[0]),a=Tl(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Na(this.depthwiseInitializer),e.depthwiseRegularizer=ml(this.depthwiseRegularizer),e.depthwiseConstraint=ci(this.depthwiseRegularizer),e}}function Ul(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new es("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function jl(e,t,n,r=!1,s,a,i=!1,o=!1){return c.DZQ((()=>{const l=t.shape.length;if(l<3)throw new es(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(Gs(2,l));if(t=c.mgz(t,u),null!=a)throw new ts("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=c.wgE(c.wgE(s,"bool"),"float32")).rank===l-1&&(s=c.UG6(s,-1)),s=c.mgz(s,u)),r&&(t=c.BEg(t,0),null!=s&&(s=c.BEg(s,0)));const d=[];let h,p=n;const f=t.shape[0],m=c.K$i(t);let g,b;null!=s&&(g=c.K$i(s));for(let t=0;t<f;++t){const n=m[t],r=c.DZQ((()=>e(n,p)));if(null==s)h=r[0],p=r[1];else{const e=c.DZQ((()=>{const e=g[t],n=c.jbE(c.P61(e),e);return{output:c.WQq(c.lKK(r[0],e),c.lKK(p[0],n)),newStates:p.map(((t,s)=>c.WQq(c.lKK(r[1][s],e),c.lKK(t,n))))}}));h=e.output,p=e.newStates}o&&d.push(h)}if(o){const e=1;b=c.t$z(d,e)}return[h,b,p]}))}Vl.className="DepthwiseConv2D",c.JFn.registerClass(Vl);class Wl extends Ha{constructor(e){let t;if(super(e),null==e.cell)throw new es("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Ql({cells:e.cell}):e.cell,null==t.stateSize)throw new es("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Va({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?Gs(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null)):this.states_}setStates(e){this.states_=e}computeOutputShape(e){Oa(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return c.DZQ((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new ts("Constants support is not implemented in RNN yet.");Oa(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Va({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!c.ZSL.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new es(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new Va({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){(0,c.DZQ)((()=>{if(!this.stateful)throw new Qr("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new es("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>c.Ul9([n,e]))):this.states_=[c.Ul9([n,this.cell.stateSize])];else if(null==e)c.ASo(this.states_),null!=this.keptStates&&(c.ASo(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>c.Ul9([n,e]))):this.states_[0]=c.Ul9([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new es(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):c.ASo(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!c.ZSL.arraysEqual(r.shape,a))throw new es(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>c.aCs(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=Ul(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Va({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Ua){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return(0,c.DZQ)((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=Fa(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new es(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=jl(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return(0,c.DZQ)((()=>{let t=c.Ul9(e.shape);return t=c.czq(t,[1,2]),t=Ks(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?ta(t,[1,e]):t)):this.cell.stateSize>1?[ta(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Wl.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=ji(t.cell,n);return new e(Object.assign(t,{cell:r}))}}Wl.className="RNN",c.JFn.registerClass(Wl);class Gl extends Ha{}class Hl extends Gl{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vs(this.units,"units"),this.activation=cl(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=$a(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$a(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$a(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=bl(e.kernelRegularizer),this.recurrentRegularizer=bl(e.recurrentRegularizer),this.biasRegularizer=bl(e.biasRegularizer),this.kernelConstraint=hi(e.kernelConstraint),this.recurrentConstraint=hi(e.recurrentConstraint),this.biasConstraint=hi(e.biasConstraint),this.dropout=js([1,Ws([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=js([1,Ws([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ra(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,c.DZQ)((()=>{if(2!==e.length)throw new es(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jl({ones:()=>c.P61(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jl({ones:()=>c.P61(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=ra(null!=a?c.lKK(e,a):e,this.kernel.read()),null!=this.bias&&(s=oa(s,this.bias.read())),null!=i&&(n=c.lKK(n,i));let o=c.WQq(s,ra(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ll(this.activation),useBias:this.useBias,kernelInitializer:Na(this.kernelInitializer),recurrentInitializer:Na(this.recurrentInitializer),biasInitializer:Na(this.biasInitializer),kernelRegularizer:ml(this.kernelRegularizer),recurrentRegularizer:ml(this.recurrentRegularizer),biasRegularizer:ml(this.biasRegularizer),activityRegularizer:ml(this.activityRegularizer),kernelConstraint:ci(this.kernelConstraint),recurrentConstraint:ci(this.recurrentConstraint),biasConstraint:ci(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Hl.className="SimpleRNNCell",c.JFn.registerClass(Hl);class ql extends Wl{constructor(e){e.cell=new Hl(e),super(e)}call(e,t){return(0,c.DZQ)((()=>{null!=this.cell.dropoutMask&&(c.ASo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.ASo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}ql.className="SimpleRNN",c.JFn.registerClass(ql);class Zl extends Gl{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new es("GRUCell does not support reset_after parameter set to true.");this.units=e.units,vs(this.units,"units"),this.activation=cl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=$a(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$a(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$a(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=bl(e.kernelRegularizer),this.recurrentRegularizer=bl(e.recurrentRegularizer),this.biasRegularizer=bl(e.biasRegularizer),this.kernelConstraint=hi(e.kernelConstraint),this.recurrentConstraint=hi(e.recurrentConstraint),this.biasConstraint=hi(e.biasConstraint),this.dropout=js([1,Ws([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=js([1,Ws([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=Ra(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,c.DZQ)((()=>{if(2!==e.length)throw new es(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jl({ones:()=>c.P61(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jl({ones:()=>c.P61(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=c.lKK(e,s[0]));let u=ra(e,this.kernel.read());this.useBias&&(u=oa(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=c.lKK(r,a[0]));const d=this.recurrentKernel.read(),[h,p]=c.lDo(d,[2*this.units,this.units],d.rank-1),f=ra(r,h),[m,g,b]=c.lDo(u,3,u.rank-1),[y,w]=c.lDo(f,2,f.rank-1);i=this.recurrentActivation.apply(c.WQq(m,y)),o=this.recurrentActivation.apply(c.WQq(g,w));const v=ra(c.lKK(o,r),p);l=this.activation.apply(c.WQq(b,v));const x=c.WQq(c.lKK(i,r),c.lKK(c.WQq(1,c.HZy(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ll(this.activation),recurrentActivation:ll(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Na(this.kernelInitializer),recurrentInitializer:Na(this.recurrentInitializer),biasInitializer:Na(this.biasInitializer),kernelRegularizer:ml(this.kernelRegularizer),recurrentRegularizer:ml(this.recurrentRegularizer),biasRegularizer:ml(this.biasRegularizer),activityRegularizer:ml(this.activityRegularizer),kernelConstraint:ci(this.kernelConstraint),recurrentConstraint:ci(this.recurrentConstraint),biasConstraint:ci(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Zl.className="GRUCell",c.JFn.registerClass(Zl);class Kl extends Wl{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Zl(e),super(e)}call(e,t){return(0,c.DZQ)((()=>{null!=this.cell.dropoutMask&&(c.ASo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.ASo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Kl.className="GRU",c.JFn.registerClass(Kl);class Yl extends Gl{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vs(this.units,"units"),this.activation=cl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=$a(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$a(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$a(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=bl(e.kernelRegularizer),this.recurrentRegularizer=bl(e.recurrentRegularizer),this.biasRegularizer=bl(e.biasRegularizer),this.kernelConstraint=hi(e.kernelConstraint),this.recurrentConstraint=hi(e.recurrentConstraint),this.biasConstraint=hi(e.biasConstraint),this.dropout=js([1,Ws([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=js([1,Ws([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=Ra(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends ha{apply(t,r){const s=e.apply([n]),a=(new fa).apply([n]),i=e.apply([2*n]);return ea(ea(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return(0,c.DZQ)((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new es(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jl({ones:()=>c.P61(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jl({ones:()=>c.P61(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,d;0<this.dropout&&this.dropout<1&&(e=c.lKK(e,a[0]));let h=ra(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=c.lKK(r,i[0])),h=c.WQq(h,ra(r,this.recurrentKernel.read())),this.useBias&&(h=oa(h,this.bias.read()));const[p,f,m,g]=c.lDo(h,4,h.rank-1);o=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(f),u=c.WQq(c.lKK(l,s),c.lKK(o,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const b=c.lKK(d,this.activation.apply(u));return[b,b,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ll(this.activation),recurrentActivation:ll(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Na(this.kernelInitializer),recurrentInitializer:Na(this.recurrentInitializer),biasInitializer:Na(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ml(this.kernelRegularizer),recurrentRegularizer:ml(this.recurrentRegularizer),biasRegularizer:ml(this.biasRegularizer),activityRegularizer:ml(this.activityRegularizer),kernelConstraint:ci(this.kernelConstraint),recurrentConstraint:ci(this.recurrentConstraint),biasConstraint:ci(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Yl.className="LSTMCell",c.JFn.registerClass(Yl);class Xl extends Wl{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Yl(e),super(e)}call(e,t){return(0,c.DZQ)((()=>{null!=this.cell.dropoutMask&&(c.ASo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.ASo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Xl.className="LSTM",c.JFn.registerClass(Xl);class Ql extends Gl{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return(0,c.DZQ)((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Oa(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{Ls(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(ji(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return za(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}Ba(t)}}function Jl(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):la(t(),n),o=()=>ua(i,t,r);return!s||s<=1?c.aCs(o().clone()):Array(s).fill(void 0).map(o).map((e=>c.aCs(e.clone())))}Ql.className="StackedRNNCells",c.JFn.registerClass(Ql);class eu extends Wl{constructor(e){if(e.unroll)throw new ts("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ts("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Va({ndim:5})]}call(e,t){return c.DZQ((()=>{if(null!=this.cell.dropoutMask&&(c.ASo(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.ASo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new es("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return c.DZQ((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=c.Ul9(s);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e,t=!1){c.DZQ((()=>{if(!this.stateful)throw new Qr("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new es("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>c.Ul9(s))):this.states_=[c.Ul9(s)];else if(null==e)c.ASo(this.states_),null!=this.keptStates&&(c.ASo(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>c.Ul9(s))):this.states_[0]=c.Ul9(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new es(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):c.ASo(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!c.ZSL.arraysEqual(n.shape,r))throw new es(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>c.aCs(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=Tl(l,r[0],s,a[0],i[0]),d=Tl(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}eu.className="ConvRNN2D";class tu extends Yl{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,vs(this.filters,"filters"),this.kernelSize=Sl(n,2,"kernelSize"),this.kernelSize.forEach((e=>vs(e,"kernelSize"))),this.strides=Sl(r||1,2,"strides"),this.strides.forEach((e=>vs(e,"strides"))),this.padding=s||"valid",Fs(this.padding),this.dataFormat=a||"channelsLast",Ds(this.dataFormat),this.dilationRate=Sl(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>vs(e,"dilationRate")))}build(e){var t;e=Ra(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new es(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends ha{apply(e,t){return Js([n.apply([r]),c.SaS([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return c.DZQ((()=>{if(3!==e.length)throw new es(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jl({ones:()=>c.P61(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?c.lKK(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),d=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jl({ones:()=>c.P61(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let f=o(s,p,0),m=o(s,p,1),g=o(s,p,2),b=o(s,p,3);const[y,w,v,x]=c.lDo(this.kernel.read(),4,3),[_,k,S,T]=this.useBias?c.lDo(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,_,this.padding),u=this.inputConv(u,w,k,this.padding),d=this.inputConv(d,v,S,this.padding),h=this.inputConv(h,x,T,this.padding);const[I,E,A,C]=c.lDo(this.recurrentKernel.read(),4,3);f=this.recurrentConv(f,I),m=this.recurrentConv(m,E),g=this.recurrentConv(g,A),b=this.recurrentConv(b,C);const N=this.recurrentActivation.apply(c.WQq(l,f)),$=this.recurrentActivation.apply(c.WQq(u,m)),O=c.WQq(c.lKK($,a),c.lKK(N,this.activation.apply(c.WQq(d,g)))),D=c.lKK(this.recurrentActivation.apply(c.WQq(h,b)),this.activation.apply(O));return[D,D,O]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=c.Xtf(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?oa(s,n,this.dataFormat):s}recurrentConv(e,t){return c.Xtf(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}tu.className="ConvLSTM2DCell",c.JFn.registerClass(tu);class nu extends eu{constructor(e){const t=new tu(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}nu.className="ConvLSTM2D",c.JFn.registerClass(nu);class ru extends Ha{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return ua((()=>la(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}ru.className="Dropout",c.JFn.registerClass(ru);class su extends ru{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}su.className="SpatialDropout1D",c.JFn.registerClass(su);class au extends Ha{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,vs(this.units,"units"),this.activation=cl(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=$a(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=$a(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=hi(e.kernelConstraint),this.biasConstraint=hi(e.biasConstraint),this.kernelRegularizer=bl(e.kernelRegularizer),this.biasRegularizer=bl(e.biasRegularizer),this.activityRegularizer=bl(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=Ra(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=Ra(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e),r=_s(this.activation.getClassName());let s;return null!=r?s=ra(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=ra(n,this.kernel.read()),null!=this.bias&&(s=oa(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:ll(this.activation),useBias:this.useBias,kernelInitializer:Na(this.kernelInitializer),biasInitializer:Na(this.biasInitializer),kernelRegularizer:ml(this.kernelRegularizer),biasRegularizer:ml(this.biasRegularizer),activityRegularizer:ml(this.activityRegularizer),kernelConstraint:ci(this.kernelConstraint),biasConstraint:ci(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}au.className="Dense",c.JFn.registerClass(au);class iu extends Ha{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ra(e);for(const t of e.slice(1))if(null==t)throw new es(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Us(e,1)]}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);let n=Fa(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=(0,c.mgz)(n,e)}return function(e){if(e.rank<=1)throw new es(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],Us(e.shape,1)];return c.tQQ(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}iu.className="Flatten",c.JFn.registerClass(iu);class ou extends Ha{constructor(e){super(e),this.supportsMasking=!0,this.activation=cl(e.activation)}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e);return this.activation.apply(n)}))}getConfig(){const e={activation:ll(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}ou.className="Activation",c.JFn.registerClass(ou);class lu extends Ha{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return(0,c.DZQ)((()=>{return e=Fa(e),t=e,n=this.n,(0,c.DZQ)((()=>{if(2!==t.shape.length)throw new es(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return ta(Ks(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}lu.className="RepeatVector",c.JFn.registerClass(lu);class uu extends Ha{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==a)throw new es("Can only specifiy one unknown dimension.");a=e}else s*=t}const i=Us(e);if(null!==a){if(0===s||i%s!=0)throw new es(n);r[a]=i/s}else if(i!==s)throw new es(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return(0,c.tQQ)(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}uu.className="Reshape",c.JFn.registerClass(uu);class cu extends Ha{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Gs(1,e.dims.length+1);if(!c.ZSL.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Va({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=Ra(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return(0,c.mgz)(Fa(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}cu.className="Permute",c.JFn.registerClass(cu);class du extends Ha{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Fa(e);return(0,c.bzn)((0,c.Ec)(n,this.maskValue),-1)}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e),r=(0,c.bzn)((0,c.Ec)(n,this.maskValue),-1,!0);return(0,c.lKK)(n,(0,c.wgE)(r,n.dtype))}))}}du.className="Masking",c.JFn.registerClass(du);class hu extends Ha{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(ls(e.inputLength))}this.inputDim=e.inputDim,vs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,vs(this.outputDim,"outputDim"),this.embeddingsInitializer=$a(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=bl(e.embeddingsRegularizer),this.activityRegularizer=bl(e.activityRegularizer),this.embeddingsConstraint=hi(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return(0,c.DZQ)((()=>this.maskZero?(e=Fa(e),(0,c.Ec)(e,(0,c.POl)(e))):null))}computeOutputShape(e){if(e=Ra(e),null==this.inputLength)return[...e,this.outputDim];const t=ls(this.inputLength);if(t.length!==e.length-1)throw new es(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new es(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);let n=Fa(e);"int32"!==n.dtype&&(n=Zs(n,"int32"));const r=sa(this.embeddings.read(),(0,c.tQQ)(n,[n.size]));return(0,c.tQQ)(r,Ra(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Na(this.embeddingsInitializer),embeddingsRegularizer:ml(this.embeddingsRegularizer),activityRegularizer:ml(this.activityRegularizer),embeddingsConstraint:ci(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}hu.className="Embedding",c.JFn.registerClass(hu);class pu extends Ha{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ts}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new es("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ra(e)]),e.length<2)throw new es(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=gs(t),t.length>1)throw new es(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===gs(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return(0,c.DZQ)((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=Ws(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=Ks(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,s=e[0],a=e.slice(1).concat([s]);let i=c.tQQ(r,[s].concat(Us(e.slice(1))));i=c.mgz(i,[1,0]),i=c.tQQ(i,a),t.push(i),n=!0}else if(e>1){const s=Gs(1,e).concat([0]);t.push(c.mgz(r,s)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=c.tQQ(c.mgz(c.tQQ(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(Gs(0,s-1));r=c.mgz(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=gs(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return c.DZQ((()=>{if(null==t)return null;if(!Array.isArray(t))throw new es("`mask` should be an Array");if(!Array.isArray(e))throw new es("`inputs` should be an Array");if(t.length!==e.length)throw new es(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:c.UG6(e,0))))[0];for(let e=1;e<t.length-1;++e)n=c.n76(n,t[e]);return n}))}}class fu extends pu{constructor(e){super(e)}mergeFunction(e){return(0,c.DZQ)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=c.WQq(t,e[n]);return t}))}}fu.className="Add",c.JFn.registerClass(fu);class mu extends pu{constructor(e){super(e)}mergeFunction(e){return(0,c.DZQ)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=c.lKK(t,e[n]);return t}))}}mu.className="Multiply",c.JFn.registerClass(mu);class gu extends pu{constructor(e){super(e)}mergeFunction(e){return(0,c.DZQ)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=c.WQq(t,e[n]);return c.lKK(1/e.length,t)}))}}gu.className="Average",c.JFn.registerClass(gu);class bu extends pu{constructor(e){super(e)}mergeFunction(e){return(0,c.DZQ)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=c.PhQ(t,e[n]);return t}))}}bu.className="Maximum",c.JFn.registerClass(bu);class yu extends pu{constructor(e){super(e)}mergeFunction(e){return(0,c.DZQ)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=c.BpO(t,e[n]);return t}))}}yu.className="Minimum",c.JFn.registerClass(yu);class wu extends pu{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new es("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let s=!1;for(const e of n)if(c.ZSL.arraysEqual(e,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new es("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,c.DZQ)((()=>Js(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new es("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new es("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new es("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new es(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return c.DZQ((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(c.wgE(c.P61(e[n]),"bool")):t[n].rank<e[n].rank?r.push(c.UG6(t[n],-1)):r.push(t[n]);const s=c.xWs(r,this.axis);return c.Q7R(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function vu(e,t){for(;e<0;)e+=t;return e}wu.className="Concatenate",c.JFn.registerClass(wu);class xu extends pu{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){c.ZSL.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new ts("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new es(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new es(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>vu(t,e[n].shape.length))):[vu(this.axes,n.shape.length),vu(this.axes,r.shape.length)],this.normalize&&(n=Wi(n,t[0]),r=Wi(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new ts("batchDot is not implemented for tensors of 4D or higher rank yet");if(c.ZSL.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),c.ZSL.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new ts("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return c.DZQ((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=c.tQQ(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=c.tQQ(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?c.czq(c.lKK(e,t),a[0]):c.czq(c.lKK(c.mgz(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=c.NoW(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=c.r2V(i,t)}return 1===i.shape.length&&(i=c.UG6(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[vu(this.axes,e.length),vu(this.axes,t.length)],n}computeOutputShape(e){c.ZSL.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new ts("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}xu.className="Dot",c.JFn.registerClass(xu);class _u extends Ha{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e);return ua((()=>(0,c.WQq)(na(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}_u.className="GaussianNoise",c.JFn.registerClass(_u);class ku extends Ha{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t);const n=Fa(e);return this.rate>0&&this.rate<1?ua((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return(0,c.lKK)(n,na(n.shape,1,e))}),(()=>n),t.training||!1):n}))}}ku.className="GaussianDropout",c.JFn.registerClass(ku);class Su extends Ha{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Fa(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,c.DZQ)((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=Fa(e),r=-1.7580993408473766;let s=(0,c.DQN)((0,c.YeY)(n),this.rate);s=Zs(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=(0,c.WQq)((0,c.lKK)(t,s),(0,c.lKK)((0,c.WQq)(s,-1),r));return(0,c.WQq)((0,c.lKK)(o,a),i)};return ua(r,(()=>Fa(e)),t.training||!1)}return e}))}}function Tu(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=c.BFc(e,t,n,r,s,a);else if(3===e.rank)i=c.kSi(e,t,n,r,s,a);else{if(4!==e.rank)throw new ts(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=c.T5N(e,t,n,r,s,a)}return i}Su.className="AlphaDropout",c.JFn.registerClass(Su);class Iu extends Ha{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=$a(e.betaInitializer||"zeros"),this.gammaInitializer=$a(e.gammaInitializer||"ones"),this.movingMeanInitializer=$a(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=$a(e.movingVarianceInitializer||"ones"),this.betaConstraint=hi(e.betaConstraint),this.gammaConstraint=hi(e.gammaConstraint),this.betaRegularizer=bl(e.betaRegularizer),this.gammaRegularizer=bl(e.gammaRegularizer)}build(e){e=Ra(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new es(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Va({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return(0,c.DZQ)((()=>{const n=null!=t.training&&t.training,r=Fa(e),s=r.shape,a=s.length,i=Gs(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=ss(1,a);l[o]=s[o];const u=i.slice();u.sort();const d=!c.ZSL.arraysEqual(u,Gs(0,a).slice(0,a-1));if(!n)return(()=>{if(d){const e=(0,c.tQQ)(this.movingMean.read(),l),t=(0,c.tQQ)(this.movingVariance.read(),l),n=this.center?(0,c.tQQ)(this.beta.read(),l):null,s=this.scale?(0,c.tQQ)(this.gamma.read(),l):null;return Tu(r,e,t,n,s,this.epsilon)}return Tu(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,p,f]=function(e,t,n,r,s=.001){return c.ZSL.arraysEqual(r.slice().sort(),Gs(0,e.rank-1))?function(e,t,n,r,s=.001){return(0,c.DZQ)((()=>{const a=c.Clk(e,r),i=a.mean,o=a.variance;return[Tu(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r,s=.001){return(0,c.DZQ)((()=>{const a=c.Clk(e,r),i=a.mean,o=a.variance,l=[];for(const t of Gs(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=(0,c.tQQ)(i,l),d=(0,c.tQQ)(o,l),h=null==t?null:(0,c.tQQ)(t,l),p=null==n?null:(0,c.tQQ)(n,l);return[Tu(e,u,d,p,h,s),i,o]}))}(e,t,n,r,s)}(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,n)=>{c.DZQ((()=>{const r=1-n,s=e.read(),a=c.lKK(c.jbE(s,t),r);e.write(c.jbE(s,a))}))};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Na(this.betaInitializer),gammaInitializer:Na(this.gammaInitializer),movingMeanInitializer:Na(this.movingMeanInitializer),movingVarianceInitializer:Na(this.movingVarianceInitializer),betaRegularizer:ml(this.betaRegularizer),gammaRegularizer:ml(this.gammaRegularizer),betaConstraint:ci(this.betaConstraint),gammaConstraint:ci(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Iu.className="BatchNormalization",c.JFn.registerClass(Iu);class Eu extends Ha{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=$a(e.betaInitializer||"zeros"),this.gammaInitializer=$a(e.gammaInitializer||"ones"),this.betaRegularizer=bl(e.betaRegularizer),this.gammaRegularizer=bl(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=Ra(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==gs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=Fa(e),r=n.shape,s=r.length;return(0,c.DZQ)((()=>{let{mean:e,variance:t}=(0,c.Clk)(n,this.axis,!0);const a=ss(1,s);for(const e of this.axis)a[e]=r[e];const i=e=>null!=e&&e.shape.length!==s?c.tQQ(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],d=[];for(let e=0;e<s;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),d.push(1)):(u.push(1),d.push(r[e]));return e=c.Vsq(e,u),t=c.Vsq(t,u),null!=o&&(o=c.Vsq(o,d)),null!=l&&(l=c.Vsq(l,d)),Tu(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Na(this.betaInitializer),gammaInitializer:Na(this.gammaInitializer),betaRegularizer:ml(this.betaRegularizer),gammaRegularizer:ml(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Eu.className="LayerNormalization",c.JFn.registerClass(Eu);class Au extends Ha{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new es(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new es(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new es(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Va({ndim:4})]}computeOutputShape(e){let t,n;return e=Ra(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return(0,c.DZQ)((()=>{return t=Fa(e),n=this.padding,r=this.dataFormat,(0,c.DZQ)((()=>{if(4!==t.rank)throw new es(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new es("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new es(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],c.eVF(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Cu(e,t,n,r,s,a){return(0,c.DZQ)((()=>{let i;Ds(s),Rs(a),Fs(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=El(e,s);const o="same"===r?"same":"valid";return i="max"===a?c.jgi(e,t,n,o):c.$jT(e,t,n,o),"channelsFirst"===s&&(i=c.mgz(i,[0,3,1,2])),i}))}function Nu(e,t,n,r,s,a){return(0,c.DZQ)((()=>{let i;Ds(s),Rs(a),Fs(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=Al(e,s);const o="same"===r?"same":"valid";return i="max"===a?c.NYV(e,t,n,o):c.sub(e,t,n,o),"channelsFirst"===s&&(i=c.mgz(i,[0,4,1,2,3])),i}))}Au.className="ZeroPadding2D",c.JFn.registerClass(Au);class $u extends Ha{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new es(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(vs(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new es(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}vs(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Fs(this.padding),this.inputSpec=[new Va({ndim:3})]}computeOutputShape(e){const t=Tl((e=Ra(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return(0,c.DZQ)((()=>{this.invokeCallHook(e,t),e=Ks(Fa(e),2);const n=this.poolingFunction(Fa(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return c.r2V(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Ou extends $u{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ds(s),Fs(r),Cu(e,t,n,r,s,"max")}}Ou.className="MaxPooling1D",c.JFn.registerClass(Ou);class Du extends $u{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ds(s),Fs(r),Cu(e,t,n,r,s,"avg")}}Du.className="AveragePooling1D",c.JFn.registerClass(Du);class Fu extends Ha{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new es(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];vs(this.poolSize,"poolSize"),vs(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ds(this.dataFormat),Fs(this.padding),this.inputSpec=[new Va({ndim:4})]}computeOutputShape(e){e=Ra(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Tl(t,this.poolSize[0],this.padding,this.strides[0]),n=Tl(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return(0,c.DZQ)((()=>(this.invokeCallHook(e,t),this.poolingFunction(Fa(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Ru extends Fu{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ds(s),Fs(r),Cu(e,t,n,r,s,"max")}}Ru.className="MaxPooling2D",c.JFn.registerClass(Ru);class Mu extends Fu{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ds(s),Fs(r),Cu(e,t,n,r,s,"avg")}}Mu.className="AveragePooling2D",c.JFn.registerClass(Mu);class Lu extends Ha{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new es(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];vs(this.poolSize,"poolSize"),vs(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ds(this.dataFormat),Fs(this.padding),this.inputSpec=[new Va({ndim:5})]}computeOutputShape(e){e=Ra(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Tl(t,this.poolSize[0],this.padding,this.strides[0]),n=Tl(n,this.poolSize[1],this.padding,this.strides[1]),r=Tl(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return(0,c.DZQ)((()=>(this.invokeCallHook(e,t),this.poolingFunction(Fa(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Pu extends Lu{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ds(s),Fs(r),Nu(e,t,n,r,s,"max")}}Pu.className="MaxPooling3D",c.JFn.registerClass(Pu);class zu extends Lu{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Ds(s),Fs(r),Nu(e,t,n,r,s,"avg")}}zu.className="AveragePooling3D",c.JFn.registerClass(zu);class Bu extends Ha{constructor(e){super(e),this.inputSpec=[new Va({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ts}}class Vu extends Bu{constructor(e){super(e||{})}call(e,t){return(0,c.DZQ)((()=>{const t=Fa(e);return c.i2o(t,1)}))}}Vu.className="GlobalAveragePooling1D",c.JFn.registerClass(Vu);class Uu extends Bu{constructor(e){super(e||{})}call(e,t){return(0,c.DZQ)((()=>{const t=Fa(e);return c.T9B(t,1)}))}}Uu.className="GlobalMaxPooling1D",c.JFn.registerClass(Uu);class ju extends Ha{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Ds(this.dataFormat),this.inputSpec=[new Va({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ts}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Wu extends ju{call(e,t){return(0,c.DZQ)((()=>{const t=Fa(e);return"channelsLast"===this.dataFormat?c.i2o(t,[1,2]):c.i2o(t,[2,3])}))}}Wu.className="GlobalAveragePooling2D",c.JFn.registerClass(Wu);class Gu extends ju{call(e,t){return(0,c.DZQ)((()=>{const t=Fa(e);return"channelsLast"===this.dataFormat?c.T9B(t,[1,2]):c.T9B(t,[2,3])}))}}Gu.className="GlobalMaxPooling2D",c.JFn.registerClass(Gu);class Hu extends Ha{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=ji(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class qu extends Hu{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Ra(e)).length<3)throw new es(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=Ra(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return(0,c.DZQ)((()=>jl(((e,n)=>[Fa(this.layer.call(e,t)),[]]),e=Fa(e),[],!1,null,null,!1,!0)[1]))}}qu.className="TimeDistributed",c.JFn.registerClass(qu);class Zu extends Hu{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=ji(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=ji(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,ys($s,"BidirectionalMergeMode",s),e.weights)throw new ts("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):os(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=Ul(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new es("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new Va({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new ts("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof Ua;for(const e of a)if(e instanceof Ua!==o)throw new es("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return(0,c.DZQ)((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=c.BEg(s,1)),"concat"===this.mergeMode?i=Js([r,s]):"sum"===this.mergeMode?i=c.WQq(r,s):"ave"===this.mergeMode?i=c.lKK(.5,c.WQq(r,s)):"mul"===this.mergeMode?i=c.lKK(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ls(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Ls(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=ji(t.layer);if(delete t.layer,null!=t.numConstants)throw new ts("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}Zu.className="Bidirectional",c.JFn.registerClass(Zu);class Ku extends Ha{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return(0,c.DZQ)((()=>("float32"!==(e=Fa(e)).dtype&&(e=Zs(e,"float32")),(0,c.WQq)((0,c.lKK)(e,this.scale),this.offset))))}}Ku.className="Rescaling",c.JFn.registerClass(Ku);const{resizeBilinear:Yu,cropAndResize:Xu}=c.image;class Qu extends Ha{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return(0,c.DZQ)((()=>{let l,u=!1;const d=[t/a,n/i,(r+t)/a,(s+n)/i],h=[];3===e.rank?(u=!0,l=(0,c.t$z)([e])):l=e;for(let e=0;e<l.shape[0];e++)h.push(d);const p=(0,c.OEK)(h,[h.length,4]),f=(0,c.y17)(0,h.length,1,"int32"),m=Xu(l,p,f,[r,s],"nearest");return Zs(u?Fa((0,c.K$i)(m)):m,o)}))}upsize(e,t,n,r){return(0,c.DZQ)((()=>Zs(Yu(e,[t,n]),r)))}call(e,t){return(0,c.DZQ)((()=>{const t=Fa(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=Ra(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}Qu.className="CenterCrop",c.JFn.registerClass(Qu);class Ju extends Ha{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Ra(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return(0,c.DZQ)((()=>{let n;if("int32"!==(e=Fa(e)).dtype&&(e=Zs(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new es(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Fa(t.countWeights)}const r=(0,c.T9B)(e),s=(0,c.jkA)(e),a=(0,c.rhj)(this.numTokens,r).bufferSync().get(0),i=(0,c.DQN)(s,0).bufferSync().get(0);if(!a||!i)throw new es(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=Fa(e);if("int32"!==s.dtype&&(s=Zs(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=(0,c.UG6)(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=(0,c.UG6)(s,-1)),s.rank>2)throw new es(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(l=void 0!==r&&"count"===t?(0,c.aOp)(o,r,n,i):(0,c.aOp)(o,[],n,i),"tfIdf"!==t)return l;if(r)return(0,c.lKK)(l,r);throw new es("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}Ju.className="CategoryEncoding",c.JFn.registerClass(Ju);const ec=new Set(["bilinear","nearest"]);class tc extends Ha{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!ec.has(e.interpolation))throw new es(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=Ra(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return(0,c.DZQ)((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return c.image.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return c.image.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ec]} are supported`)}))}}tc.className="Resizing",c.JFn.registerClass(tc);class nc{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}nc.className="RandomSeed";class rc extends Ha{constructor(e){super(e),this.randomGenerator=new nc(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}rc.className="BaseRandomLayer";const sc=new Set(["bilinear","nearest"]);class ac extends rc{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new es(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new es(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new es(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!sc.has(n))throw new es(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=Ra(e))[2];return[this.imgHeight,-1,t]}call(e,t){return(0,c.DZQ)((()=>{const t=Fa(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=(0,c.YeY)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return c.image.resizeBilinear(e,s);case"nearest":return c.image.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...sc]} are supported`)}}))}}function ic(e){return new Za(e)}function oc(e){return new xl(e)}function lc(e){return new yl(e)}function uc(e){return new wl(e)}function cc(e){return new vl(e)}function dc(e){return new kl(e)}function hc(e){return new _l(e)}function pc(e){return new Pl(e)}function fc(e){return new Ol(e)}function mc(e){return new Fl(e)}function gc(e){return new Dl(e)}function bc(e){return new Rl(e)}function yc(e){return new Ll(e)}function wc(e){return new zl(e)}function vc(e){return new Bl(e)}function xc(e){return new Vl(e)}function _c(e){return new ou(e)}function kc(e){return new au(e)}function Sc(e){return new ru(e)}function Tc(e){return new su(e)}function Ic(e){return new iu(e)}function Ec(e){return new lu(e)}function Ac(e){return new uu(e)}function Cc(e){return new cu(e)}function Nc(e){return new hu(e)}function $c(e){return new fu(e)}function Oc(e){return new gu(e)}function Dc(e){return new wu(e)}function Fc(e){return new bu(e)}function Rc(e){return new yu(e)}function Mc(e){return new mu(e)}function Lc(e){return new xu(e)}function Pc(e){return new Iu(e)}function zc(e){return new Eu(e)}function Bc(e){return new Au(e)}function Vc(e){return new Du(e)}function Uc(e){return Vc(e)}function jc(e){return Vc(e)}function Wc(e){return new Mu(e)}function Gc(e){return Wc(e)}function Hc(e){return Wc(e)}function qc(e){return new zu(e)}function Zc(e){return qc(e)}function Kc(e){return qc(e)}function Yc(e){return new Vu(e)}function Xc(e){return new Wu(e)}function Qc(e){return new Uu(e)}function Jc(e){return new Gu(e)}function ed(e){return new Ou(e)}function td(e){return new Ru(e)}function nd(e){return new Pu(e)}function rd(e){return new Kl(e)}function sd(e){return new Zl(e)}function ad(e){return new Xl(e)}function id(e){return new Yl(e)}function od(e){return new ql(e)}function ld(e){return new Hl(e)}function ud(e){return new nu(e)}function cd(e){return new tu(e)}function dd(e){return new Wl(e)}function hd(e){return new Ql(e)}function pd(e){return new Zu(e)}function fd(e){return new qu(e)}ac.className="RandomWidth",c.JFn.registerClass(ac);const md=Qc,gd=Jc,bd=ed,yd=td;function wd(e){return new _u(e)}function vd(e){return new ku(e)}function xd(e){return new Su(e)}function _d(e){return new du(e)}function kd(e){return new Ku(e)}function Sd(e){return new Qu(e)}function Td(e){return new tc(e)}function Id(e){return new Ju(e)}function Ed(e){return new ac(e)}function Ad(e,t){return eo(e,t)}function Cd(e,t){return so(e,t)}function Nd(e,t){return ao(e,t)}function $d(e,t){return to(e,t)}function Od(e,t){return io(e,t)}function Dd(e,t){return ro(e,t)}function Fd(e,t){return function(e,t){return(0,c.DZQ)((()=>{const n=no(e,t),r=function(e,t){return(0,c.DZQ)((()=>c.wgE(c.czq(c.n76(c.LCg(e,1),c.LCg(t,0))),"float32")))}(e,t),s=c.WQq(n,r);return c.wgE(c._M9(c.rhj(s,0),c.y4m(n,s),0),"float32")}))}(e,t)}function Rd(e,t){return Xi(e,t)}function Md(e,t){return Hi(e,t)}function Ld(e,t){return qi(e,t)}function Pd(e,t){return qi(e,t)}function zd(e,t){return qi(e,t)}function Bd(e,t){return Gi(e,t)}function Vd(e,t){return Gi(e,t)}function Ud(e,t){return Gi(e,t)}function jd(e){return new pl(e)}function Wd(e){return dl(t=e),new pl({l1:null!=t?t.l1:null,l2:0});var t}function Gd(e){return dl(t=e),new pl({l2:null!=t?t.l2:null,l1:0});var t}class Hd extends Ri{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Po))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function qd(e,t){return e<t}function Zd(e,t){return e>t}class Kd extends Hd{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new ts("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=qd:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=Zd:this.monitorFunc=qd,this.monitorFunc===qd&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===qd?1/0:-1/0}async onEpochEnd(e,t){await Oi(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}const Yd={earlyStopping:function(e){return new Kd(e)}};var Xd,Qd=n(7164),Jd=n(8273);function eh(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(ah(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=eh(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function th(e,t=rh){return nh(e,t)}function nh(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(ah(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=nh(e.map((e=>e[a])),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function rh(e){return null===e?null:ah(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function sh(e,t){const n=new Map;eh(e,t,n);for(const e of Array.from(n.keys())){const t=n.get(e);if(c.ZSL.isPromise(t)){const r=await t;n.set(e,r)}}return eh(e,t,n)}function ah(e){let t=!1;if(c._K2().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof c.qYS)&&!(e instanceof Promise)&&!t)}function ih(e){return e instanceof c.qYS?{value:e.clone(),recurse:!1}:ah(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class oh{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class lh extends oh{constructor(){super(lh.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function uh(e){return new hh(e)}function ch(e){return new ph(e)}lh.INITIAL_CAPACITY=32;class dh{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new vh(this,e)}filter(e){return new yh(this,e)}map(e){return new wh(this,e)}mapAsync(e){return new xh(this,e)}serialMapAsync(e){return new xh(this,e).serial()}flatmap(e){return new kh(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new bh(this,e,t)}columnMajorBatch(e,t=!0,n=rh){return this.rowMajorBatch(e,t).map((e=>th(e,n)))}concatenate(e,t){return new Sh(uh([this,e]),t)}take(e){return e<0||null==e?this:new gh(this,e)}skip(e){return e<0||null==e?this:new mh(this,e)}prefetch(e){return new Ih(this,e)}shuffle(e,t){return new Eh(this,e,t)}serial(){return new fh(this)}}class hh extends dh{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:(t=e,function(e,t){return eh(e,t)}(t,ih)),done:!1};var t}}class ph extends dh{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class fh extends dh{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class mh extends dh{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;c.ASo(e.value)}return this.upstream.next()}}class gh extends dh{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class bh extends dh{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class yh extends dh{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;c.ASo(e.value)}}}class wh extends dh{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=c.d_S.getTensorsInContainer(e.value),n=this.transform(e.value),r=c.d_S.getTensorsInContainer(n);for(const e of t)c.d_S.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}}class vh extends dh{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class xh extends dh{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=c.d_S.getTensorsInContainer(e.value),n=await this.transform(e.value),r=c.d_S.getTensorsInContainer(n);for(const e of t)c.d_S.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}}class _h extends dh{constructor(){super(),this.outputQueue=new lh,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class kh extends _h{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=c.d_S.getTensorsInContainer(e.value),n=this.transform(e.value),r=c.d_S.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const e of t)c.d_S.isTensorInList(e,r)||e.dispose();return!0}}class Sh extends dh{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(Xd||(Xd={}));class Th extends dh{constructor(e,t=Xd.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;const r=await sh(this.iterators,(function(e){return e instanceof dh?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Xd.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Xd.SHORTEST:return{value:null,done:!0};case Xd.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class Ih extends dh{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new oh(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Eh extends Ih{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Jd.alea(n||c.ZSL.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class Ah{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return c.ZSL.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),Ch((async()=>(await n.iterator()).columnMajorBatch(e,t,Oh)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,Ch((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,Ch((async()=>(await t.iterator()).filter((t=>c.DZQ((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Ch((async()=>(await t.iterator()).map((t=>c.DZQ((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return Ch((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Ch((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,Ch((async()=>{return n=ch((async()=>({value:await t.iterator(),done:!1}))).take(e),new Sh(n,r);var n,r}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,Ch((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=Jd.alea(t||c.ZSL.now().toString());return Ch((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,Ch((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function Ch(e,t=null){return new class extends Ah{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Nh(e){return Ch((async()=>uh(e)),e.length)}function $h(e){if(!ah(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return Ch((async()=>function(e,t=Xd.FAIL){return new Th(e,t)}(await sh(e,(e=>{if(e instanceof Ah)return{value:e.iterator(),recurse:!1};if(ah(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),Xd.SHORTEST)),t)}function Oh(e){if(null===e)return null;return null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof c.qYS||c.ZSL.isTypedArray(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof c.qYS?c.t$z(e):c.OEK(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}Ah.MAX_BUFFER_SIZE=1e4;class Dh extends Ah{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}}const Fh='"',Rh=Symbol("out"),Mh=Symbol("field"),Lh=Symbol("quote"),Ph=Symbol("quoteafterquote"),zh=Symbol("quoteinquote");class Bh extends Ah{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&c.ZSL.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(c.ZSL.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(const e of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value;return this.parseRow(n,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Dh(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(c.ZSL.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){const t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){const a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!this.configuredColumnsOnly||i){const o=t[s];let l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);l=void 0}else{const e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[a]=l:n[a]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let r=0;const s=e.length;let a=Rh;for(let t=0;t<s;t++)switch(a){case Rh:switch(e.charAt(t)){case Fh:r=t+1,a=Lh;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),a=Rh;break;default:a=Mh,r=t}break;case Mh:e.charAt(t)===this.delimiter&&(n.push(e.substring(r,t)),a=Rh,r=t+1);break;case Lh:e.charAt(t)===Fh&&(a=Ph);break;case Ph:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),a=Rh,r=t+1;break;case Fh:a=Lh;break;default:a=zh}break;case zh:e.charAt(t)===Fh&&(a=Lh)}if(a===Ph?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}class Vh extends dh{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!(0,c._K2)().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new Vh(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise((r=>{const s=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(c.ZSL.sizeFromShape(t));return n.set(e,n.length-e.length),(0,c.OEK)(n,t)}}class Uh extends dh{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=(0,c.tGX)([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,s=n+e,a=t+r;this.cropBox=(0,c.KtR)([r,n,a,s],[1,4])}else this.cropBox=(0,c.KtR)([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!(0,c._K2)().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new Uh(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&c.ZSL.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=c.TaL.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return(0,c.DZQ)((()=>{const t=(0,c.UG6)((0,c.wgE)(e,"float32"),0);let n;n=c.image.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=n.shape;return(0,c.tQQ)(n,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class jh{}class Wh extends dh{split(e){return new Gh(this,e)}}class Gh extends Wh{constructor(e,t){super(),this.upstream=e,this.impl=new Hh(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Hh extends _h{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}class qh extends dh{decodeUTF8(){return new Zh(this)}}class Zh extends Wh{constructor(e){super(),this.upstream=e,this.impl=new Kh(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Kh extends _h{constructor(e){if(super(),this.upstream=e,(0,c._K2)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=n(4530);this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=(0,c._K2)().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}}class Yh extends qh{constructor(e,t={}){super(),this.file=e,this.options=t,c.ZSL.assert(e instanceof Uint8Array||!!(0,c._K2)().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise(((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const r=new FileReader;r.onload=n=>{let s=r.result;if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),!(s instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(s)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));const s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}));return{value:await e,done:!1}}}function Xh(e){return"string"==typeof e&&"file://"===e.slice(0,7)}class Qh extends jh{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(Xh(this.input)&&(0,c._K2)().get("IS_NODE")){const e=n(8108);this.input=e.readFileSync(this.input.slice(7))}return new Yh(this.input,this.options)}}class Jh extends jh{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return Xh(this.url)?new Qh(this.url,this.fileOptions).iterator():async function(e,t={},n){let r,s;var a;"string"==typeof e?r=e:(r=e.url,s={method:(a=e).method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});const i=await(n||c.ZSL.fetch)(r,s);if(i.ok){const e=new Uint8Array(await i.arrayBuffer());return new Yh(e,t)}throw new Error(i.statusText)}(this.url,this.fileOptions)}}function ep(e,t={}){return new Bh(new Jh(e),t)}function tp(e){const t=ch(e);return Ch((async()=>t))}function np(e){return Ch((async()=>{const t=await e();return ch((()=>t.next()))}))}async function rp(e,t){return Uh.create(e,t)}async function sp(e){return Vh.create(e)}const ap="4.18.0";var ip=n(3010),op=n(8412);const lp={"tfjs-core":c.bgA,"tfjs-backend-cpu":ip.version_cpu,"tfjs-backend-webgl":op.version_webgl,"tfjs-data":ap,"tfjs-layers":vo,"tfjs-converter":Qd.uW,tfjs:"4.18.0"}},1364:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,s,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var o=0;o<this.length;o++){var l=this[o][0];null!=l&&(i[l]=!0)}for(var u=0;u<e.length;u++){var c=[].concat(e[u]);r&&i[c[0]]||(void 0!==a&&(void 0===c[5]||(c[1]="@layer".concat(c[5].length>0?" ".concat(c[5]):""," {").concat(c[1],"}")),c[5]=a),n&&(c[2]?(c[1]="@media ".concat(c[2]," {").concat(c[1],"}"),c[2]=n):c[2]=n),s&&(c[4]?(c[1]="@supports (".concat(c[4],") {").concat(c[1],"}"),c[4]=s):c[4]="".concat(s)),t.push(c))}},t}},3615:e=>{"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},2379:e=>{"use strict";e.exports=function(e){return e[1]}},9620:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return _}else{if(e<=-f)return k;if(e+1>=f)return x}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));a=a.mul(h).add(o(d))}else a=(a=a.mul(s)).add(o(d))}return a.unsigned=t,a}function d(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var b=i(0,!0);n.UZERO=b;var y=i(1);n.ONE=y;var w=i(1,!0);n.UONE=w;var v=i(-1);n.NEG_ONE=v;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var _=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var k=l(0,-2147483648,!1);n.MIN_VALUE=k;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return!(1&~this.low)},S.isEven=function(){return!(1&this.low)},S.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(y)},S.neg=S.negate,S.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,h+=(p+=s+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},S.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(k))return e.isOdd()?k:g;if(e.eq(k))return this.isOdd()?k:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,w=0;return y+=(w+=i*p)>>>16,b+=(y+=a*p)>>>16,y&=65535,b+=(y+=i*h)>>>16,f+=(b+=s*p)>>>16,b&=65535,f+=(b+=a*h)>>>16,b&=65535,f+=(b+=i*c)>>>16,f+=n*p+s*h+a*c+i*u,l((y&=65535)<<16|(w&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return w;a=b}else{if(this.eq(k))return e.eq(y)||e.eq(v)?k:e.eq(k)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:v:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(k))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(s);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=y),a=a.add(h),s=s.sub(p)}return a},S.div=S.divide,S.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return l(~this.low,~this.high,this.unsigned)},S.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},6409:(e,t,n)=>{"use strict";n.r(t),n.d(t,{InferenceSession:()=>f,Tensor:()=>h,env:()=>i,registerBackend:()=>a});const r={},s=[],a=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createSessionHandler)throw new TypeError("not a valid backend");{const a=r[e];if(void 0===a)r[e]={backend:t,priority:n};else{if(a.priority>n)return;if(a.priority===n&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const t=s.indexOf(e);-1!==t&&s.splice(t,1);for(let t=0;t<s.length;t++)if(r[s[t]].priority<=n)return void s.splice(t,0,e);s.push(e)}}},i=new class{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},o="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,l="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,u=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),c=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);o&&(u.set("int64",BigInt64Array),c.set(BigInt64Array,"int64")),l&&(u.set("uint64",BigUint64Array),c.set(BigUint64Array,"uint64"));class d{constructor(e,t,n){let r,s,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");s=t}else{const n=u.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))s=n.from(t);else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);s=t}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",s=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",s=Uint8Array.from(e)}}else{const t=c.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,s=e}if(void 0===a)a=[s.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");const i=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(a);if(i!==s.length)throw new Error(`Tensor's size(${i}) does not match data length(${s.length}).`);this.dims=a,this.type=r,this.data=s,this.size=i}static bufferToTensor(e,t){if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");const{height:n,width:r}=t,s=t.norm;let a,i;a=void 0===s||void 0===s.mean?255:s.mean,i=void 0===s||void 0===s.bias?0:s.bias;const o=void 0!==t.bitmapFormat?t.bitmapFormat:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=n*r,c="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u);let h=4,p=0,f=1,m=2,g=3,b=0,y=u,w=2*u,v=-1;"RGB"===o&&(h=3,p=0,f=1,m=2,g=-1),"RGBA"===l?v=3*u:"RBG"===l?(b=0,w=u,y=2*u):"BGR"===l&&(w=0,y=u,b=2*u);for(let t=0;t<u;t++,p+=h,m+=h,f+=h,g+=h)c[b++]=(e[p]+i)/a,c[y++]=(e[f]+i)/a,c[w++]=(e[m]+i)/a,-1!==v&&-1!==g&&(c[v++]=(e[g]+i)/a);return new d("float32",c,"RGBA"===l?[1,4,n,r]:[1,3,n,r])}static async fromImage(e,t){const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,a="undefined"!=typeof String&&(e instanceof String||"string"==typeof e);let i,o={};if(n){const n=document.createElement("canvas"),r=n.getContext("2d");if(null==r)throw new Error("Can not access image data");{let s=e.naturalHeight,a=e.naturalWidth;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(s=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(o.tensorFormat="RGBA",void 0!==t.height&&t.height!==s)throw new Error("Image input config height doesn't match HTMLImageElement height");if(o.height=s,void 0!==t.width&&t.width!==a)throw new Error("Image input config width doesn't match HTMLImageElement width");o.width=a}else o.tensorFormat="RGBA",o.height=s,o.width=a;n.width=a,n.height=s,r.drawImage(e,0,0,a,s),i=r.getImageData(0,0,a,s).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==t.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const n=document.createElement("canvas").getContext("2d");if(null!=n){const r=e.height,s=e.width;if(n.drawImage(e,0,0,s,r),i=n.getImageData(0,0,s,r).data,void 0!==t){if(void 0!==t.height&&t.height!==r)throw new Error("Image input config height doesn't match ImageBitmap height");if(o.height=r,void 0!==t.width&&t.width!==s)throw new Error("Image input config width doesn't match ImageBitmap width");o.width=s}else o.height=r,o.width=s;return d.bufferToTensor(i,o)}throw new Error("Can not access image data")}if(a)return new Promise(((n,r)=>{const s=document.createElement("canvas"),a=s.getContext("2d");if(!e||!a)return r();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{s.width=i.width,s.height=i.height,a.drawImage(i,0,0,s.width,s.height);const e=a.getImageData(0,0,s.width,s.height);if(void 0!==t){if(void 0!==t.height&&t.height!==s.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(o.height=s.height,void 0!==t.width&&t.width!==s.width)throw new Error("Image input config width doesn't match ImageBitmap width");o.width=s.width}else o.height=s.height,o.width=s.width;n(d.bufferToTensor(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const n="RGBA";let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t){if(o=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==n)throw new Error("Image input config format must be RGBA for ImageData");o.bitmapFormat="RGBA"}else o.bitmapFormat="RGBA";if(o.height=r,o.width=s,void 0!==t){const t=document.createElement("canvas");t.width=s,t.height=r;const n=t.getContext("2d");if(null==n)throw new Error("Can not access image data");n.putImageData(e,0,0),i=n.getImageData(0,0,s,r).data}else i=e.data}}if(void 0!==i)return d.bufferToTensor(i,o);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var t,n;const r=document.createElement("canvas").getContext("2d");let s;if(null==r)throw new Error("Can not access image data");{const a=this.dims[3],i=this.dims[2],o=this.dims[1],l=void 0!==e&&void 0!==e.format?e.format:"RGB",u=void 0!==e&&void 0!==(null===(t=e.norm)||void 0===t?void 0:t.mean)?e.norm.mean:255,c=void 0!==e&&void 0!==(null===(n=e.norm)||void 0===n?void 0:n.bias)?e.norm.bias:0,d=i*a;if(void 0!==e){if(void 0!==e.height&&e.height!==i)throw new Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==a)throw new Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===o&&"RGBA"!==e.format||3===o&&"RGB"!==e.format&&"BGR"!==e.format)throw new Error("Tensor format doesn't match input tensor dims")}const h=4;let p=0,f=1,m=2,g=3,b=0,y=d,w=2*d,v=-1;"RGBA"===l?(b=0,y=d,w=2*d,v=3*d):"RGB"===l?(b=0,y=d,w=2*d):"RBG"===l&&(b=0,w=d,y=2*d),s=r.createImageData(a,i);for(let e=0;e<i*a;p+=h,f+=h,m+=h,g+=h,e++)s.data[p]=(this.data[b++]-c)*u,s.data[f]=(this.data[y++]-c)*u,s.data[m]=(this.data[w++]-c)*u,s.data[g]=-1===v?255:(this.data[v++]-c)*u}return s}reshape(e){return new d(this.type,this.data,e)}}const h=d;class p{constructor(e){this.handler=e}async run(e,t,n){const r={};let s={};if("object"!=typeof e||null===e||e instanceof h||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof h)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==i.indexOf(n)){const s=t[n];(null===s||s instanceof h)&&(e=!0,a=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else s=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(const e of this.outputNames)r[e]=null;const i=await this.handler.run(e,r,s),o={};for(const e in i)Object.hasOwnProperty.call(i,e)&&(o[e]=new h(i[e].type,i[e].data,i[e].dims));return o}static async create(e,t,n,a){let i,o={};if("string"==typeof e){if(i=e,"object"==typeof t&&null!==t)o=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,"object"==typeof t&&null!==t)o=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const r=e;let s=0,l=e.byteLength;if("object"==typeof t&&null!==t)o=t;else if("number"==typeof t){if(s=t,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(l=e.byteLength-s,"number"==typeof n){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteLength' must be an integer.");if(l<=0||s+l>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-s}].`);if("object"==typeof a&&null!==a)o=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");i=new Uint8Array(r,s,l)}}const l=(o.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),u=await(async e=>{const t=0===e.length?s:e,n=[];for(const e of t){const t=r[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(s){r||n.push({name:e,err:s}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)})(l),c=await u.createSessionHandler(i,o);return new p(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const f=p},9570:(module,__unused_webpack_exports,__webpack_require__)=>{var e;self,e=__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(e,t,n)=>{var r,s=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return O.buffer!=F&&H(O.buffer),R}function s(){return O.buffer!=F&&H(O.buffer),M}function a(){return O.buffer!=F&&H(O.buffer),L}function i(){return O.buffer!=F&&H(O.buffer),P}function o(){return O.buffer!=F&&H(O.buffer),z}var l,u,c;e=e||{},l||(l=void 0!==e?e:{}),l.ready=new Promise((function(e,t){u=e,c=t}));var d,h,p,f,m,g,b=Object.assign({},l),y="./this.program",w=(e,t)=>{throw t},v="object"==typeof window,x="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,k=l.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return l.locateFile?l.locateFile(e,S):S+e}if(_){let t;S=x?n(908).dirname(S)+"/":"//",g=()=>{m||(f=n(1384),m=n(908))},d=function(e,t){return g(),e=m.normalize(e),f.readFileSync(e,t?void 0:"utf8")},p=e=>((e=d(e,!0)).buffer||(e=new Uint8Array(e)),e),h=(e,t,n)=>{g(),e=m.normalize(e),f.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ue))throw e})),process.on("unhandledRejection",(function(e){throw e})),w=(e,t)=>{if(J())throw process.exitCode=e,t;t instanceof ue||N("exiting due to exception: "+t),process.exit(e)},l.inspect=function(){return"[Emscripten Module object]"};try{t=n(9925)}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=t.Worker}else(v||x)&&(x?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),r&&(S=r),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},x&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(6953).performance);var I=console.log.bind(console),E=console.warn.bind(console);_&&(g(),I=e=>f.writeSync(1,e+"\n"),E=e=>f.writeSync(2,e+"\n"));var A,C=l.print||I,N=l.printErr||E;Object.assign(l,b),b=null,l.thisProgram&&(y=l.thisProgram),l.quit&&(w=l.quit),l.wasmBinary&&(A=l.wasmBinary);var $=l.noExitRuntime||!1;"object"!=typeof WebAssembly&&ae("no native wasm support detected");var O,D,F,R,M,L,P,z,B=!1,V="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function U(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&V)return V.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var a=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|a);else{var i=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|a<<6|i:(7&s)<<18|a<<12|i<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r}function j(e,t){return(e>>>=0)?U(s(),e,t):""}function W(e,t,n,r){if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-s}function G(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function H(e){F=e,l.HEAP8=R=new Int8Array(e),l.HEAP16=new Int16Array(e),l.HEAP32=L=new Int32Array(e),l.HEAPU8=M=new Uint8Array(e),l.HEAPU16=new Uint16Array(e),l.HEAPU32=P=new Uint32Array(e),l.HEAPF32=new Float32Array(e),l.HEAPF64=z=new Float64Array(e)}k&&(F=l.buffer);var q=l.INITIAL_MEMORY||16777216;if(k)O=l.wasmMemory,F=l.buffer;else if(l.wasmMemory)O=l.wasmMemory;else if(!((O=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw N("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");O&&(F=O.buffer),q=F.byteLength,H(F);var Z,K=[],Y=[],X=[],Q=[];function J(){return $||!1}function ee(){var e=l.preRun.shift();K.unshift(e)}var te,ne=0,re=null,se=null;function ae(e){throw k?postMessage({cmd:"onAbort",arg:e}):l.onAbort&&l.onAbort(e),N(e="Aborted("+e+")"),B=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function ie(){return te.startsWith("data:application/octet-stream;base64,")}function oe(){var e=te;try{if(e==te&&A)return new Uint8Array(A);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ae(e)}}te="ort-wasm-threaded.wasm",ie()||(te=T(te));var le={};function ue(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function ce(e){(e=fe.Vb[e])||ae(),fe.mc(e)}function de(e){var t=fe.Cc();if(!t)return 6;fe.ac.push(t),fe.Vb[e.Ub]=t,t.Ub=e.Ub;var n={cmd:"run",start_routine:e.Ic,arg:e.zc,pthread_ptr:e.Ub};return t.$b=()=>{n.time=performance.now(),t.postMessage(n,e.Nc)},t.loaded&&(t.$b(),delete t.$b),0}function he(e){if(k)return qe(1,1,e);J()||(fe.oc(),l.onExit&&l.onExit(e),B=!0),w(e,new ue(e))}function pe(e,t){if(!t&&k)throw ge(e),"unwind";J()||k||(bt(),me(X),gt(0),rt[1].length&&st(1,10),rt[2].length&&st(2,10),fe.oc()),he(e)}var fe={Yb:[],ac:[],qc:[],Vb:{},fc:function(){k&&fe.Ec()},Pc:function(){},Ec:function(){fe.receiveObjectTransfer=fe.Gc,fe.threadInitTLS=fe.pc,fe.setExitStatus=fe.nc,$=!1},nc:function(){},oc:function(){for(var e of Object.values(fe.Vb))fe.mc(e);for(e of fe.Yb)e.terminate();fe.Yb=[]},mc:function(e){var t=e.Ub;delete fe.Vb[t],fe.Yb.push(e),fe.ac.splice(fe.ac.indexOf(e),1),e.Ub=0,_t(t)},Gc:function(){},pc:function(){fe.qc.forEach((e=>e()))},Fc:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ub&&(fe.Bc=e.Ub),n.targetThread&&n.targetThread!=pt()){var s=fe.Vb[n.Qc];s?s.postMessage(n,n.transferList):N('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Ve(n.queue):"spawnThread"===r?de(n):"cleanupThread"===r?ce(n.thread):"killThread"===r?(n=n.thread,r=fe.Vb[n],delete fe.Vb[n],r.terminate(),_t(n),fe.ac.splice(fe.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?fe.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.$b&&(e.$b(),delete e.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?N("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?l.onAbort&&l.onAbort(n.arg):r&&N("worker sent an unknown command "+r);fe.Bc=void 0},e.onerror=e=>{throw N("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:O,wasmModule:D})},yc:function(){var e=T("ort-wasm-threaded.worker.js");fe.Yb.push(new Worker(e))},Cc:function(){return 0==fe.Yb.length&&(fe.yc(),fe.Fc(fe.Yb[0])),fe.Yb.pop()}};function me(e){for(;0<e.length;)e.shift()(l)}function ge(e){if(k)return qe(2,0,e);try{pe(e)}catch(e){e instanceof ue||"unwind"==e||w(1,e)}}l.PThread=fe,l.establishStackSpace=function(){var e=pt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],Tt(t,t-e),Et(t)};var be=[];function ye(e){var t=be[e];return t||(e>=be.length&&(be.length=e+1),be[e]=t=Z.get(e)),t}l.invokeEntryPoint=function(e,t){e=ye(e)(t),J()?fe.nc(e):kt(e)};var we,ve,xe=[],_e=0,ke=0;function Se(e){this.Zb=e,this.Sb=e-24,this.xc=function(e){i()[this.Sb+4>>2>>>0]=e},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(e){i()[this.Sb+8>>2>>>0]=e},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(e){e=e?1:0,t()[(this.Sb+12|0)>>>0]=e},this.uc=function(){return 0!=t()[(this.Sb+12|0)>>>0]},this.ic=function(e){e=e?1:0,t()[(this.Sb+13|0)>>>0]=e},this.kc=function(){return 0!=t()[(this.Sb+13|0)>>>0]},this.fc=function(e,t){this.cc(0),this.xc(e),this.wc(t),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(e){i()[this.Sb+16>>2>>>0]=e},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Nt(this.bc()))return i()[this.Zb>>2>>>0];var e=this.tc();return 0!==e?e:this.Zb}}function Te(e){return mt(new Se(e).Sb)}function Ie(e,t,n,r){return k?qe(3,1,e,t,n,r):Ee(e,t,n,r)}function Ee(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return N("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return k&&0===s.length?Ie(e,t,n,r):(e={Ic:n,Ub:e,zc:r,Nc:s},k?(e.Oc="spawnThread",postMessage(e,s),0):de(e))}function Ae(e,t,n){return k?qe(4,1,e,t,n):0}function Ce(e,t){if(k)return qe(5,1,e,t)}function Ne(e,t){if(k)return qe(6,1,e,t)}function $e(e,t,n){if(k)return qe(7,1,e,t,n)}function Oe(e,t,n){return k?qe(8,1,e,t,n):0}function De(e,t){if(k)return qe(9,1,e,t)}function Fe(e,t,n){if(k)return qe(10,1,e,t,n)}function Re(e,t,n,r){if(k)return qe(11,1,e,t,n,r)}function Me(e,t,n,r){if(k)return qe(12,1,e,t,n,r)}function Le(e,t,n,r){if(k)return qe(13,1,e,t,n,r)}function Pe(e){if(k)return qe(14,1,e)}function ze(e,t){if(k)return qe(15,1,e,t)}function Be(e,t,n){if(k)return qe(16,1,e,t,n)}function Ve(e){Atomics.store(a(),e>>2,1),pt()&&xt(e),Atomics.compareExchange(a(),e>>2,1,0)}function Ue(e){return i()[e>>>2]+4294967296*a()[e+4>>>2]}function je(e,t,n,r,s,a){return k?qe(17,1,e,t,n,r,s,a):-52}function We(e,t,n,r,s,a){if(k)return qe(18,1,e,t,n,r,s,a)}function Ge(e){var n=G(e)+1,r=ft(n);return r&&W(e,t(),r,n),r}function He(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}if(k)return qe(19,1,e,t,n);var s=(new Date).getFullYear(),o=new Date(s,0,1),l=new Date(s,6,1);s=o.getTimezoneOffset();var u=l.getTimezoneOffset(),c=Math.max(s,u);a()[e>>2>>>0]=60*c,a()[t>>2>>>0]=Number(s!=u),e=r(o),t=r(l),e=Ge(e),t=Ge(t),u<s?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)}function qe(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=It();return e=e(),Et(t),e}((()=>{for(var s=At(8*n),a=s>>3,i=0;i<n;i++){var l=r[2+i];o()[a+i>>>0]=l}return vt(e,n,s,t)}))}l.executeNotifiedProxyingQueue=Ve,ve=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:k?()=>performance.now()-l.__performance_now_clock_drift:()=>performance.now();var Ze,Ke=[],Ye={};function Xe(){if(!Ze){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in Ye)void 0===Ye[e]?delete t[e]:t[e]=Ye[e];var n=[];for(e in t)n.push(e+"="+t[e]);Ze=n}return Ze}function Qe(e,n){if(k)return qe(20,1,e,n);var r=0;return Xe().forEach((function(s,a){var o=n+r;for(a=i()[e+4*a>>2>>>0]=o,o=0;o<s.length;++o)t()[(0|a++)>>>0]=s.charCodeAt(o);t()[(0|a)>>>0]=0,r+=s.length+1})),0}function Je(e,t){if(k)return qe(21,1,e,t);var n=Xe();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function et(e){return k?qe(22,1,e):52}function tt(e,t,n,r){return k?qe(23,1,e,t,n,r):52}function nt(e,t,n,r,s){return k?qe(24,1,e,t,n,r,s):70}var rt=[null,[],[]];function st(e,t){var n=rt[e];0===t||10===t?((1===e?C:N)(U(n,0)),n.length=0):n.push(t)}function at(e,t,n,r){if(k)return qe(25,1,e,t,n,r);for(var a=0,o=0;o<n;o++){var l=i()[t>>2>>>0],u=i()[t+4>>2>>>0];t+=8;for(var c=0;c<u;c++)st(e,s()[l+c>>>0]);a+=u}return i()[r>>2>>>0]=a,0}var it=0;function ot(e){return 0==e%4&&(0!=e%100||0==e%400)}var lt=[31,29,31,30,31,30,31,31,30,31,30,31],ut=[31,28,31,30,31,30,31,31,30,31,30,31];function ct(e,n,r,s){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return i(e,t,"0")}function l(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Wb;for(e=new Date(new Date(e.Xb+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(ot(e.getFullYear())?lt:ut)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),n=u(n),0>=l(t,e)?0>=l(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var d=a()[s+40>>2>>>0];for(var h in s={Lc:a()[s>>2>>>0],Kc:a()[s+4>>2>>>0],dc:a()[s+8>>2>>>0],jc:a()[s+12>>2>>>0],ec:a()[s+16>>2>>>0],Xb:a()[s+20>>2>>>0],Tb:a()[s+24>>2>>>0],Wb:a()[s+28>>2>>>0],Rc:a()[s+32>>2>>>0],Jc:a()[s+36>>2>>>0],Mc:d?j(d):""},r=j(r),d={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(h,"g"),d[h]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(h in d={"%a":function(e){return p[e.Tb].substring(0,3)},"%A":function(e){return p[e.Tb]},"%b":function(e){return f[e.ec].substring(0,3)},"%B":function(e){return f[e.ec]},"%C":function(e){return o((e.Xb+1900)/100|0,2)},"%d":function(e){return o(e.jc,2)},"%e":function(e){return i(e.jc,2," ")},"%g":function(e){return c(e).toString().substring(2)},"%G":function(e){return c(e)},"%H":function(e){return o(e.dc,2)},"%I":function(e){return 0==(e=e.dc)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ec-1;t+=(ot(e.Xb+1900)?lt:ut)[n++]);return o(e.jc+t,3)},"%m":function(e){return o(e.ec+1,2)},"%M":function(e){return o(e.Kc,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.dc&&12>e.dc?"AM":"PM"},"%S":function(e){return o(e.Lc,2)},"%t":function(){return"\t"},"%u":function(e){return e.Tb||7},"%U":function(e){return o(Math.floor((e.Wb+7-e.Tb)/7),2)},"%V":function(e){var t=Math.floor((e.Wb+7-(e.Tb+6)%7)/7);if(2>=(e.Tb+371-e.Wb-2)%7&&t++,t)53==t&&(4==(n=(e.Tb+371-e.Wb)%7)||3==n&&ot(e.Xb)||(t=1));else{t=52;var n=(e.Tb+7-e.Wb-1)%7;(4==n||5==n&&ot(e.Xb%400-1))&&t++}return o(t,2)},"%w":function(e){return e.Tb},"%W":function(e){return o(Math.floor((e.Wb+7-(e.Tb+6)%7)/7),2)},"%y":function(e){return(e.Xb+1900).toString().substring(2)},"%Y":function(e){return e.Xb+1900},"%z":function(e){var t=0<=(e=e.Jc);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),d)r.includes(h)&&(r=r.replace(new RegExp(h,"g"),d[h](s)));return h=function(e){var t=Array(G(e)+1);return W(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),h.length>n?0:(function(e,n){t().set(e,n>>>0)}(h,e),h.length-1)}fe.fc();var dt=[null,he,ge,Ie,Ae,Ce,Ne,$e,Oe,De,Fe,Re,Me,Le,Pe,ze,Be,je,We,He,Qe,Je,et,tt,nt,at],ht={b:function(e){return ft(e+24)+24},n:function(e){return(e=new Se(e)).uc()||(e.hc(!0),_e--),e.ic(!1),xe.push(e),e.sc(),e.vc()},ma:function(e){throw N("Unexpected exception thrown, this is not properly supported - aborting"),B=!0,e},x:function(){St(0);var e=xe.pop();if(e.Hc()&&!e.kc()){var t=e.Dc();t&&ye(t)(e.Zb),Te(e.Zb)}ke=0},e:function(){var e=ke;if(!e)return it=0;var t=new Se(e);t.cc(e);var n=t.bc();if(!n)return it=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ct(a,n,t.Sb+16))return it=a,e}return it=n,e},l:function(){var e=ke;if(!e)return it=0;var t=new Se(e);t.cc(e);var n=t.bc();if(!n)return it=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ct(a,n,t.Sb+16))return it=a,e}return it=n,e},h:function(){var e=ke;if(!e)return it=0;var t=new Se(e);t.cc(e);var n=t.bc();if(!n)return it=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ct(a,n,t.Sb+16))return it=a,e}return it=n,e},t:Te,M:function(){var e=xe.pop();e||ae("no exception to throw");var t=e.Zb;throw e.kc()||(xe.push(e),e.ic(!0),e.hc(!1),_e++),ke=t,t},c:function(e,t,n){throw new Se(e).fc(t,n),ke=e,_e++,e},pa:function(){return _e},Fa:function(e){yt(e,!x,1,!v),fe.pc()},T:function(e){k?postMessage({cmd:"cleanupThread",thread:e}):ce(e)},xa:Ee,j:function(e){throw ke||(ke=e),e},H:Ae,Ma:Ce,ua:Ne,wa:$e,oa:Oe,Ka:De,Ca:Fe,Ja:Re,V:Me,va:Le,sa:Pe,La:ze,ta:Be,Ta:function(){},X:function(){ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(e,t,n,r){if(e==t)setTimeout((()=>Ve(r)));else if(k)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.Vb[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(e,t){e=new Date(1e3*Ue(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},Qa:function(e,t){e=new Date(1e3*Ue(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Ra:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=s.getTimezoneOffset(),l=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=o&&l==r):0<n!=(l==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?l:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-s.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},Aa:je,Ba:We,Sa:function e(t,n,r){e.Ac||(e.Ac=!0,He(t,n,r))},y:function(){ae("")},U:function(){if(!_&&!x){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";we||(we={}),we[e]||(we[e]=1,_&&(e="warning: "+e),N(e))}},ra:function(){return 4294901760},B:ve,Ia:function(e,t,n){s().copyWithin(e>>>0,t>>>0,t+n>>>0)},F:function(){return _?n(3993).cpus().length:navigator.hardwareConcurrency},Da:function(e,t,n){Ke.length=t,n>>=3;for(var r=0;r<t;r++)Ke[r]=o()[n+r>>>0];return(0>e?le[-e-1]:dt[e]).apply(null,Ke)},qa:function(e){var t=s().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-F.byteLength+65535>>>16),H(O.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},Na:function(){throw"unwind"},Ga:Qe,Ha:Je,J:pe,I:et,S:tt,ga:nt,R:at,d:function(){return it},na:function e(r,s){e.lc||(e.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(Object(function(){var e=new Error("Cannot find module 'crypto'");throw e.code="MODULE_NOT_FOUND",e}()));return()=>t.randomBytes(1)[0]}catch(e){}return()=>ae("randomDevice")}());for(var a=0;a<s;a++)t()[(r+a|0)>>>0]=e.lc();return 0},ia:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},ja:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},K:function(e){var t=It();try{return ye(e)()}catch(e){if(Et(t),e!==e+0)throw e;St(1,0)}},f:function(e,t){var n=It();try{return ye(e)(t)}catch(e){if(Et(n),e!==e+0)throw e;St(1,0)}},P:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},Q:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},k:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},p:function(e,t,n,r){var s=It();try{return ye(e)(t,n,r)}catch(e){if(Et(s),e!==e+0)throw e;St(1,0)}},q:function(e,t,n,r,s){var a=It();try{return ye(e)(t,n,r,s)}catch(e){if(Et(a),e!==e+0)throw e;St(1,0)}},N:function(e,t,n,r,s,a){var i=It();try{return ye(e)(t,n,r,s,a)}catch(e){if(Et(i),e!==e+0)throw e;St(1,0)}},s:function(e,t,n,r,s,a){var i=It();try{return ye(e)(t,n,r,s,a)}catch(e){if(Et(i),e!==e+0)throw e;St(1,0)}},w:function(e,t,n,r,s,a,i){var o=It();try{return ye(e)(t,n,r,s,a,i)}catch(e){if(Et(o),e!==e+0)throw e;St(1,0)}},L:function(e,t,n,r,s,a,i,o){var l=It();try{return ye(e)(t,n,r,s,a,i,o)}catch(e){if(Et(l),e!==e+0)throw e;St(1,0)}},E:function(e,t,n,r,s,a,i,o,l,u,c,d){var h=It();try{return ye(e)(t,n,r,s,a,i,o,l,u,c,d)}catch(e){if(Et(h),e!==e+0)throw e;St(1,0)}},aa:function(e,t,n,r,s,a,i,o){var l=It();try{return zt(e,t,n,r,s,a,i,o)}catch(e){if(Et(l),e!==e+0)throw e;St(1,0)}},_:function(e,t,n,r,s,a,i){var o=It();try{return Ot(e,t,n,r,s,a,i)}catch(e){if(Et(o),e!==e+0)throw e;St(1,0)}},Z:function(e,t,n,r,s){var a=It();try{return Bt(e,t,n,r,s)}catch(e){if(Et(a),e!==e+0)throw e;St(1,0)}},ca:function(e,t,n,r){var s=It();try{return Lt(e,t,n,r)}catch(e){if(Et(s),e!==e+0)throw e;St(1,0)}},$:function(e){var t=It();try{return $t(e)}catch(e){if(Et(t),e!==e+0)throw e;St(1,0)}},ba:function(e,t){var n=It();try{return Pt(e,t)}catch(e){if(Et(n),e!==e+0)throw e;St(1,0)}},Y:function(e,t,n){var r=It();try{return Dt(e,t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},g:function(e){var t=It();try{ye(e)()}catch(e){if(Et(t),e!==e+0)throw e;St(1,0)}},r:function(e,t){var n=It();try{ye(e)(t)}catch(e){if(Et(n),e!==e+0)throw e;St(1,0)}},i:function(e,t,n){var r=It();try{ye(e)(t,n)}catch(e){if(Et(r),e!==e+0)throw e;St(1,0)}},ha:function(e,t,n,r){var s=It();try{ye(e)(t,n,r)}catch(e){if(Et(s),e!==e+0)throw e;St(1,0)}},m:function(e,t,n,r){var s=It();try{ye(e)(t,n,r)}catch(e){if(Et(s),e!==e+0)throw e;St(1,0)}},v:function(e,t,n,r,s){var a=It();try{ye(e)(t,n,r,s)}catch(e){if(Et(a),e!==e+0)throw e;St(1,0)}},u:function(e,t,n,r,s,a){var i=It();try{ye(e)(t,n,r,s,a)}catch(e){if(Et(i),e!==e+0)throw e;St(1,0)}},O:function(e,t,n,r,s,a,i){var o=It();try{ye(e)(t,n,r,s,a,i)}catch(e){if(Et(o),e!==e+0)throw e;St(1,0)}},A:function(e,t,n,r,s,a,i,o){var l=It();try{ye(e)(t,n,r,s,a,i,o)}catch(e){if(Et(l),e!==e+0)throw e;St(1,0)}},ka:function(e,t,n,r,s,a,i,o,l){var u=It();try{ye(e)(t,n,r,s,a,i,o,l)}catch(e){if(Et(u),e!==e+0)throw e;St(1,0)}},C:function(e,t,n,r,s,a,i,o,l,u,c){var d=It();try{ye(e)(t,n,r,s,a,i,o,l,u,c)}catch(e){if(Et(d),e!==e+0)throw e;St(1,0)}},D:function(e,t,n,r,s,a,i,o,l,u,c,d,h,p,f,m){var g=It();try{ye(e)(t,n,r,s,a,i,o,l,u,c,d,h,p,f,m)}catch(e){if(Et(g),e!==e+0)throw e;St(1,0)}},fa:function(e,t,n,r,s,a,i,o){var l=It();try{Ft(e,t,n,r,s,a,i,o)}catch(e){if(Et(l),e!==e+0)throw e;St(1,0)}},da:function(e,t,n,r,s,a,i,o,l,u,c,d){var h=It();try{Mt(e,t,n,r,s,a,i,o,l,u,c,d)}catch(e){if(Et(h),e!==e+0)throw e;St(1,0)}},ea:function(e,t,n,r,s,a){var i=It();try{Rt(e,t,n,r,s,a)}catch(e){if(Et(i),e!==e+0)throw e;St(1,0)}},o:function(e){return e},a:O||l.wasmMemory,G:function(e){it=e},la:ct,z:function(e,t,n,r){return ct(e,t,n,r)}};!function(){function e(e,t){l.asm=e.exports,fe.qc.push(l.asm.sb),Z=l.asm.ub,Y.unshift(l.asm.Va),D=t,k||(ne--,l.monitorRunDependencies&&l.monitorRunDependencies(ne),0==ne&&(null!==re&&(clearInterval(re),re=null),se&&(e=se,se=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!A&&(v||x)){if("function"==typeof fetch&&!te.startsWith("file://"))return fetch(te,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+te+"'";return e.arrayBuffer()})).catch((function(){return oe()}));if(h)return new Promise((function(e,t){h(te,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return oe()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){N("failed to asynchronously prepare wasm: "+e),ae(e)}))}var r={a:ht};if(k||(ne++,l.monitorRunDependencies&&l.monitorRunDependencies(ne)),l.instantiateWasm)try{return l.instantiateWasm(r,e)}catch(e){return N("Module.instantiateWasm callback failed with error: "+e),!1}(A||"function"!=typeof WebAssembly.instantiateStreaming||ie()||te.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(te,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return N("wasm streaming compile failed: "+e),N("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.Va).apply(null,arguments)},l._OrtInit=function(){return(l._OrtInit=l.asm.Wa).apply(null,arguments)},l._OrtCreateSessionOptions=function(){return(l._OrtCreateSessionOptions=l.asm.Xa).apply(null,arguments)},l._OrtAppendExecutionProvider=function(){return(l._OrtAppendExecutionProvider=l.asm.Ya).apply(null,arguments)},l._OrtAddSessionConfigEntry=function(){return(l._OrtAddSessionConfigEntry=l.asm.Za).apply(null,arguments)},l._OrtReleaseSessionOptions=function(){return(l._OrtReleaseSessionOptions=l.asm._a).apply(null,arguments)},l._OrtCreateSession=function(){return(l._OrtCreateSession=l.asm.$a).apply(null,arguments)},l._OrtReleaseSession=function(){return(l._OrtReleaseSession=l.asm.ab).apply(null,arguments)},l._OrtGetInputCount=function(){return(l._OrtGetInputCount=l.asm.bb).apply(null,arguments)},l._OrtGetOutputCount=function(){return(l._OrtGetOutputCount=l.asm.cb).apply(null,arguments)},l._OrtGetInputName=function(){return(l._OrtGetInputName=l.asm.db).apply(null,arguments)},l._OrtGetOutputName=function(){return(l._OrtGetOutputName=l.asm.eb).apply(null,arguments)},l._OrtFree=function(){return(l._OrtFree=l.asm.fb).apply(null,arguments)},l._OrtCreateTensor=function(){return(l._OrtCreateTensor=l.asm.gb).apply(null,arguments)},l._OrtGetTensorData=function(){return(l._OrtGetTensorData=l.asm.hb).apply(null,arguments)},l._OrtReleaseTensor=function(){return(l._OrtReleaseTensor=l.asm.ib).apply(null,arguments)},l._OrtCreateRunOptions=function(){return(l._OrtCreateRunOptions=l.asm.jb).apply(null,arguments)},l._OrtAddRunConfigEntry=function(){return(l._OrtAddRunConfigEntry=l.asm.kb).apply(null,arguments)},l._OrtReleaseRunOptions=function(){return(l._OrtReleaseRunOptions=l.asm.lb).apply(null,arguments)},l._OrtRun=function(){return(l._OrtRun=l.asm.mb).apply(null,arguments)},l._OrtEndProfiling=function(){return(l._OrtEndProfiling=l.asm.nb).apply(null,arguments)};var pt=l._pthread_self=function(){return(pt=l._pthread_self=l.asm.ob).apply(null,arguments)},ft=l._malloc=function(){return(ft=l._malloc=l.asm.pb).apply(null,arguments)},mt=l._free=function(){return(mt=l._free=l.asm.qb).apply(null,arguments)},gt=l._fflush=function(){return(gt=l._fflush=l.asm.rb).apply(null,arguments)};l.__emscripten_tls_init=function(){return(l.__emscripten_tls_init=l.asm.sb).apply(null,arguments)};var bt=l.___funcs_on_exit=function(){return(bt=l.___funcs_on_exit=l.asm.tb).apply(null,arguments)},yt=l.__emscripten_thread_init=function(){return(yt=l.__emscripten_thread_init=l.asm.vb).apply(null,arguments)};l.__emscripten_thread_crashed=function(){return(l.__emscripten_thread_crashed=l.asm.wb).apply(null,arguments)};var wt,vt=l._emscripten_run_in_main_runtime_thread_js=function(){return(vt=l._emscripten_run_in_main_runtime_thread_js=l.asm.xb).apply(null,arguments)},xt=l.__emscripten_proxy_execute_task_queue=function(){return(xt=l.__emscripten_proxy_execute_task_queue=l.asm.yb).apply(null,arguments)},_t=l.__emscripten_thread_free_data=function(){return(_t=l.__emscripten_thread_free_data=l.asm.zb).apply(null,arguments)},kt=l.__emscripten_thread_exit=function(){return(kt=l.__emscripten_thread_exit=l.asm.Ab).apply(null,arguments)},St=l._setThrew=function(){return(St=l._setThrew=l.asm.Bb).apply(null,arguments)},Tt=l._emscripten_stack_set_limits=function(){return(Tt=l._emscripten_stack_set_limits=l.asm.Cb).apply(null,arguments)},It=l.stackSave=function(){return(It=l.stackSave=l.asm.Db).apply(null,arguments)},Et=l.stackRestore=function(){return(Et=l.stackRestore=l.asm.Eb).apply(null,arguments)},At=l.stackAlloc=function(){return(At=l.stackAlloc=l.asm.Fb).apply(null,arguments)},Ct=l.___cxa_can_catch=function(){return(Ct=l.___cxa_can_catch=l.asm.Gb).apply(null,arguments)},Nt=l.___cxa_is_pointer_type=function(){return(Nt=l.___cxa_is_pointer_type=l.asm.Hb).apply(null,arguments)},$t=l.dynCall_j=function(){return($t=l.dynCall_j=l.asm.Ib).apply(null,arguments)},Ot=l.dynCall_iiiiij=function(){return(Ot=l.dynCall_iiiiij=l.asm.Jb).apply(null,arguments)},Dt=l.dynCall_jii=function(){return(Dt=l.dynCall_jii=l.asm.Kb).apply(null,arguments)},Ft=l.dynCall_viiiiij=function(){return(Ft=l.dynCall_viiiiij=l.asm.Lb).apply(null,arguments)},Rt=l.dynCall_vjji=function(){return(Rt=l.dynCall_vjji=l.asm.Mb).apply(null,arguments)},Mt=l.dynCall_viiijjjii=function(){return(Mt=l.dynCall_viiijjjii=l.asm.Nb).apply(null,arguments)},Lt=l.dynCall_iij=function(){return(Lt=l.dynCall_iij=l.asm.Ob).apply(null,arguments)},Pt=l.dynCall_ji=function(){return(Pt=l.dynCall_ji=l.asm.Pb).apply(null,arguments)},zt=l.dynCall_iiiiiij=function(){return(zt=l.dynCall_iiiiiij=l.asm.Qb).apply(null,arguments)},Bt=l.dynCall_iiij=function(){return(Bt=l.dynCall_iiij=l.asm.Rb).apply(null,arguments)};function Vt(){function e(){if(!wt&&(wt=!0,l.calledRun=!0,!B)&&(k||me(Y),u(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),!k)){if(l.postRun)for("function"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;){var e=l.postRun.shift();Q.unshift(e)}me(Q)}}if(!(0<ne))if(k)u(l),k||me(Y),postMessage({cmd:"loaded"});else{if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)ee();me(K),0<ne||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),e()}),1)):e())}}if(l.UTF8ToString=j,l.stringToUTF8=function(e,t,n){return W(e,s(),t,n)},l.lengthBytesUTF8=G,l.keepRuntimeAlive=J,l.wasmMemory=O,l.stackSave=It,l.stackRestore=Et,l.stackAlloc=At,l.ExitStatus=ue,l.PThread=fe,se=function e(){wt||Vt(),wt||(se=e)},l.preInit)for("function"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();return Vt(),e.ready});e.exports=s},932:(e,t,n)=>{var r,s=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,s,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){s=e,a=t}));var i,o,l,u,c,d,h=Object.assign({},t),p="./this.program",f=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";b?(y=g?n(908).dirname(y)+"/":"//",d=()=>{c||(u=n(1384),c=n(908))},i=function(e,t){return d(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},l=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n)=>{d(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof X))throw e})),process.on("unhandledRejection",(function(e){throw e})),f=(e,t)=>{if(_||0<V)throw process.exitCode=e,t;t instanceof X||x("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),r&&(y=r),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var w,v=t.print||console.log.bind(console),x=t.printErr||console.warn.bind(console);Object.assign(t,h),h=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(f=t.quit),t.wasmBinary&&(w=t.wasmBinary);var _=t.noExitRuntime||!1;"object"!=typeof WebAssembly&&q("no native wasm support detected");var k,S,T,I,E,A,C=!1,N="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function $(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&N)return N.decode(e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var a=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|a);else{var i=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|a<<6|i:(7&s)<<18|a<<12|i<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r}function O(e,t){return(e>>>=0)?$(I,e,t):""}function D(e,t,n,r){if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-s}function F(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function R(){var e=k.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=I=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=A=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var M,L=[],P=[],z=[],B=[],V=0;function U(){var e=t.preRun.shift();L.unshift(e)}var j,W=0,G=null,H=null;function q(e){throw t.onAbort&&t.onAbort(e),x(e="Aborted("+e+")"),C=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function Z(){return j.startsWith("data:application/octet-stream;base64,")}if(j="ort-wasm.wasm",!Z()){var K=j;j=t.locateFile?t.locateFile(K,y):y+K}function Y(){var e=j;try{if(e==j&&w)return new Uint8Array(w);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(e){q(e)}}function X(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Q(e){for(;0<e.length;)e.shift()(t)}var J=[],ee=0,te=0;function ne(e){this.Db=e,this.zb=e-24,this.Ub=function(e){A[this.zb+4>>2>>>0]=e},this.Eb=function(){return A[this.zb+4>>2>>>0]},this.Sb=function(e){A[this.zb+8>>2>>>0]=e},this.Wb=function(){return A[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(e){T[(this.zb+12|0)>>>0]=e?1:0},this.Pb=function(){return 0!=T[(this.zb+12|0)>>>0]},this.Jb=function(e){T[(this.zb+13|0)>>>0]=e?1:0},this.Lb=function(){return 0!=T[(this.zb+13|0)>>>0]},this.Rb=function(e,t){this.Fb(0),this.Ub(e),this.Sb(t),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var e=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=e-1,1===e},this.Fb=function(e){A[this.zb+16>>2>>>0]=e},this.Ob=function(){return A[this.zb+16>>2>>>0]},this.Qb=function(){if(Ae(this.Eb()))return A[this.Db>>2>>>0];var e=this.Ob();return 0!==e?e:this.Db}}function re(e){return ve(new ne(e).zb)}var se=[];function ae(e){var t=se[e];return t||(e>=se.length&&(se.length=e+1),se[e]=t=M.get(e)),t}function ie(e){var t=F(e)+1,n=we(t);return n&&D(e,T,n,t),n}var oe={};function le(){if(!ue){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in oe)void 0===oe[e]?delete t[e]:t[e]=oe[e];var n=[];for(e in t)n.push(e+"="+t[e]);ue=n}return ue}var ue,ce=[null,[],[]];function de(e,t){var n=ce[e];0===t||10===t?((1===e?v:x)($(n,0)),n.length=0):n.push(t)}var he=0;function pe(e){return 0==e%4&&(0!=e%100||0==e%400)}var fe=[31,29,31,30,31,30,31,31,30,31,30,31],me=[31,28,31,30,31,30,31,31,30,31,30,31];function ge(e,t,n,r){function s(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function a(e,t){return s(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function o(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Bb;for(e=new Date(new Date(e.Cb+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(pe(e.getFullYear())?fe:me)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=o(new Date(e.getFullYear(),0,4)),n=o(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var u=E[r+40>>2>>>0];for(var c in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:u?O(u):""},n=O(n),u={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),u[c]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(c in u={"%a":function(e){return d[e.Ab].substring(0,3)},"%A":function(e){return d[e.Ab]},"%b":function(e){return h[e.Hb].substring(0,3)},"%B":function(e){return h[e.Hb]},"%C":function(e){return a((e.Cb+1900)/100|0,2)},"%d":function(e){return a(e.Kb,2)},"%e":function(e){return s(e.Kb,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return a(e.Gb,2)},"%I":function(e){return 0==(e=e.Gb)?e=12:12<e&&(e-=12),a(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Hb-1;t+=(pe(e.Cb+1900)?fe:me)[n++]);return a(e.Kb+t,3)},"%m":function(e){return a(e.Hb+1,2)},"%M":function(e){return a(e.Zb,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.Gb&&12>e.Gb?"AM":"PM"},"%S":function(e){return a(e.$b,2)},"%t":function(){return"\t"},"%u":function(e){return e.Ab||7},"%U":function(e){return a(Math.floor((e.Bb+7-e.Ab)/7),2)},"%V":function(e){var t=Math.floor((e.Bb+7-(e.Ab+6)%7)/7);if(2>=(e.Ab+371-e.Bb-2)%7&&t++,t)53==t&&(4==(n=(e.Ab+371-e.Bb)%7)||3==n&&pe(e.Cb)||(t=1));else{t=52;var n=(e.Ab+7-e.Bb-1)%7;(4==n||5==n&&pe(e.Cb%400-1))&&t++}return a(t,2)},"%w":function(e){return e.Ab},"%W":function(e){return a(Math.floor((e.Bb+7-(e.Ab+6)%7)/7),2)},"%y":function(e){return(e.Cb+1900).toString().substring(2)},"%Y":function(e){return e.Cb+1900},"%z":function(e){var t=0<=(e=e.Yb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),u)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),u[c](r)));return c=function(e){var t=Array(F(e)+1);return D(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),c.length>t?0:(T.set(c,e>>>0),c.length-1)}var be={a:function(e){return we(e+24)+24},m:function(e){return(e=new ne(e)).Pb()||(e.Ib(!0),ee--),e.Jb(!1),J.push(e),e.Nb(),e.Qb()},ia:function(e){throw x("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,e},w:function(){ke(0);var e=J.pop();if(e.Xb()&&!e.Lb()){var t=e.Wb();t&&ae(t)(e.Db),re(e.Db)}te=0},d:function(){var e=te;if(!e)return he=0;var t=new ne(e);t.Fb(e);var n=t.Eb();if(!n)return he=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ee(a,n,t.zb+16))return he=a,e}return he=n,e},k:function(){var e=te;if(!e)return he=0;var t=new ne(e);t.Fb(e);var n=t.Eb();if(!n)return he=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ee(a,n,t.zb+16))return he=a,e}return he=n,e},g:function(){var e=te;if(!e)return he=0;var t=new ne(e);t.Fb(e);var n=t.Eb();if(!n)return he=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ee(a,n,t.zb+16))return he=a,e}return he=n,e},s:re,L:function(){var e=J.pop();e||q("no exception to throw");var t=e.Db;throw e.Lb()||(J.push(e),e.Jb(!0),e.Ib(!1),ee++),te=t,t},b:function(e,t,n){throw new ne(e).Rb(t,n),te=e,ee++,e},la:function(){return ee},i:function(e){throw te||(te=e),e},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){q("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){q("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(e,t){e=new Date(1e3*(A[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(e,t){e=new Date(1e3*(A[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},Fa:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),0,1),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=s.getTimezoneOffset(),o=Math.min(i,a);return 0>n?E[e+32>>2>>>0]=Number(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-s.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function e(t,n,r){e.Vb||(e.Vb=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}var s=(new Date).getFullYear(),a=new Date(s,0,1),i=new Date(s,6,1);s=a.getTimezoneOffset();var o=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(s,o),E[t>>2>>>0]=Number(s!=o),e=r(a),t=r(i),e=ie(e),t=ie(t),o<s?(A[n>>2>>>0]=e,A[n+4>>2>>>0]=t):(A[n>>2>>>0]=t,A[n+4>>2>>>0]=e)}(t,n,r))},B:function(){q("")},ma:function(){return 4294901760},I:b?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),xa:function(e,t,n){I.copyWithin(e>>>0,t>>>0,t+n>>>0)},G:function(e){var t=I.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var s=Math;r=Math.max(e,r),s=s.min.call(s,4294901760,r+(65536-r%65536)%65536);e:{try{k.grow(s-S.byteLength+65535>>>16),R();var a=1;break e}catch(e){}a=void 0}if(a)return!0}return!1},va:function(e,t){var n=0;return le().forEach((function(r,s){var a=t+n;for(s=A[e+4*s>>2>>>0]=a,a=0;a<r.length;++a)T[(0|s++)>>>0]=r.charCodeAt(a);T[(0|s)>>>0]=0,n+=r.length+1})),0},wa:function(e,t){var n=le();A[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),A[t>>2>>>0]=r,0},ba:function(e){_||0<V||(_e(),Q(z),xe(0),ce[1].length&&de(1,10),ce[2].length&&de(2,10)),_||0<V||(t.onExit&&t.onExit(e),C=!0),f(e,new X(e))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(e,t,n,r){for(var s=0,a=0;a<n;a++){var i=A[t>>2>>>0],o=A[t+4>>2>>>0];t+=8;for(var l=0;l<o;l++)de(e,I[i+l>>>0]);s+=o}return A[r>>2>>>0]=s,0},c:function(){return he},ja:function e(t,r){e.Mb||(e.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(b)try{var t=n(Object(function(){var e=new Error("Cannot find module 'crypto'");throw e.code="MODULE_NOT_FOUND",e}()));return()=>t.randomBytes(1)[0]}catch(e){}return()=>q("randomDevice")}());for(var s=0;s<r;s++)T[(t+s|0)>>>0]=e.Mb();return 0},ea:function(e,t,n){var r=Se();try{return ae(e)(t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},fa:function(e,t,n){var r=Se();try{return ae(e)(t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},J:function(e){var t=Se();try{return ae(e)()}catch(e){if(Te(t),e!==e+0)throw e;ke(1,0)}},e:function(e,t){var n=Se();try{return ae(e)(t)}catch(e){if(Te(n),e!==e+0)throw e;ke(1,0)}},N:function(e,t,n){var r=Se();try{return ae(e)(t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},O:function(e,t,n){var r=Se();try{return ae(e)(t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},j:function(e,t,n){var r=Se();try{return ae(e)(t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},o:function(e,t,n,r){var s=Se();try{return ae(e)(t,n,r)}catch(e){if(Te(s),e!==e+0)throw e;ke(1,0)}},p:function(e,t,n,r,s){var a=Se();try{return ae(e)(t,n,r,s)}catch(e){if(Te(a),e!==e+0)throw e;ke(1,0)}},M:function(e,t,n,r,s,a){var i=Se();try{return ae(e)(t,n,r,s,a)}catch(e){if(Te(i),e!==e+0)throw e;ke(1,0)}},r:function(e,t,n,r,s,a){var i=Se();try{return ae(e)(t,n,r,s,a)}catch(e){if(Te(i),e!==e+0)throw e;ke(1,0)}},v:function(e,t,n,r,s,a,i){var o=Se();try{return ae(e)(t,n,r,s,a,i)}catch(e){if(Te(o),e!==e+0)throw e;ke(1,0)}},K:function(e,t,n,r,s,a,i,o){var l=Se();try{return ae(e)(t,n,r,s,a,i,o)}catch(e){if(Te(l),e!==e+0)throw e;ke(1,0)}},D:function(e,t,n,r,s,a,i,o,l,u,c,d){var h=Se();try{return ae(e)(t,n,r,s,a,i,o,l,u,c,d)}catch(e){if(Te(h),e!==e+0)throw e;ke(1,0)}},X:function(e,t,n,r,s,a,i,o){var l=Se();try{return Le(e,t,n,r,s,a,i,o)}catch(e){if(Te(l),e!==e+0)throw e;ke(1,0)}},V:function(e,t,n,r,s,a,i){var o=Se();try{return Ne(e,t,n,r,s,a,i)}catch(e){if(Te(o),e!==e+0)throw e;ke(1,0)}},U:function(e,t,n,r,s){var a=Se();try{return Pe(e,t,n,r,s)}catch(e){if(Te(a),e!==e+0)throw e;ke(1,0)}},Z:function(e,t,n,r){var s=Se();try{return Re(e,t,n,r)}catch(e){if(Te(s),e!==e+0)throw e;ke(1,0)}},W:function(e){var t=Se();try{return Ce(e)}catch(e){if(Te(t),e!==e+0)throw e;ke(1,0)}},Y:function(e,t){var n=Se();try{return Me(e,t)}catch(e){if(Te(n),e!==e+0)throw e;ke(1,0)}},T:function(e,t,n){var r=Se();try{return $e(e,t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},f:function(e){var t=Se();try{ae(e)()}catch(e){if(Te(t),e!==e+0)throw e;ke(1,0)}},q:function(e,t){var n=Se();try{ae(e)(t)}catch(e){if(Te(n),e!==e+0)throw e;ke(1,0)}},h:function(e,t,n){var r=Se();try{ae(e)(t,n)}catch(e){if(Te(r),e!==e+0)throw e;ke(1,0)}},da:function(e,t,n,r){var s=Se();try{ae(e)(t,n,r)}catch(e){if(Te(s),e!==e+0)throw e;ke(1,0)}},l:function(e,t,n,r){var s=Se();try{ae(e)(t,n,r)}catch(e){if(Te(s),e!==e+0)throw e;ke(1,0)}},t:function(e,t,n,r,s){var a=Se();try{ae(e)(t,n,r,s)}catch(e){if(Te(a),e!==e+0)throw e;ke(1,0)}},u:function(e,t,n,r,s,a){var i=Se();try{ae(e)(t,n,r,s,a)}catch(e){if(Te(i),e!==e+0)throw e;ke(1,0)}},x:function(e,t,n,r,s,a,i){var o=Se();try{ae(e)(t,n,r,s,a,i)}catch(e){if(Te(o),e!==e+0)throw e;ke(1,0)}},z:function(e,t,n,r,s,a,i,o){var l=Se();try{ae(e)(t,n,r,s,a,i,o)}catch(e){if(Te(l),e!==e+0)throw e;ke(1,0)}},ga:function(e,t,n,r,s,a,i,o,l){var u=Se();try{ae(e)(t,n,r,s,a,i,o,l)}catch(e){if(Te(u),e!==e+0)throw e;ke(1,0)}},A:function(e,t,n,r,s,a,i,o,l,u,c){var d=Se();try{ae(e)(t,n,r,s,a,i,o,l,u,c)}catch(e){if(Te(d),e!==e+0)throw e;ke(1,0)}},C:function(e,t,n,r,s,a,i,o,l,u,c,d,h,p,f,m){var g=Se();try{ae(e)(t,n,r,s,a,i,o,l,u,c,d,h,p,f,m)}catch(e){if(Te(g),e!==e+0)throw e;ke(1,0)}},aa:function(e,t,n,r,s,a,i,o){var l=Se();try{Oe(e,t,n,r,s,a,i,o)}catch(e){if(Te(l),e!==e+0)throw e;ke(1,0)}},_:function(e,t,n,r,s,a,i,o,l,u,c,d){var h=Se();try{Fe(e,t,n,r,s,a,i,o,l,u,c,d)}catch(e){if(Te(h),e!==e+0)throw e;ke(1,0)}},$:function(e,t,n,r,s,a){var i=Se();try{De(e,t,n,r,s,a)}catch(e){if(Te(i),e!==e+0)throw e;ke(1,0)}},n:function(e){return e},F:function(e){he=e},ha:ge,y:function(e,t,n,r){return ge(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,k=t.asm.Ka,R(),M=t.asm.ib,P.unshift(t.asm.La),W--,t.monitorRunDependencies&&t.monitorRunDependencies(W),0==W&&(null!==G&&(clearInterval(G),G=null),H&&(e=H,H=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!w&&(m||g)){if("function"==typeof fetch&&!j.startsWith("file://"))return fetch(j,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+j+"'";return e.arrayBuffer()})).catch((function(){return Y()}));if(o)return new Promise((function(e,t){o(j,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return Y()}))}().then((function(e){return WebAssembly.instantiate(e,s)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),q(e)}))}var s={a:be};if(W++,t.monitorRunDependencies&&t.monitorRunDependencies(W),t.instantiateWasm)try{return t.instantiateWasm(s,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(w||"function"!=typeof WebAssembly.instantiateStreaming||Z()||j.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(j,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,s).then(n,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.La).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.Ma).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.Na).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.Oa).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.Pa).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.Qa).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.Ra).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.Sa).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Ta).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Ua).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm.Va).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.Wa).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.Xa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.Ya).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.Za).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm._a).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.$a).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.ab).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.bb).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.cb).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.db).apply(null,arguments)};var ye,we=t._malloc=function(){return(we=t._malloc=t.asm.eb).apply(null,arguments)},ve=t._free=function(){return(ve=t._free=t.asm.fb).apply(null,arguments)},xe=t._fflush=function(){return(xe=t._fflush=t.asm.gb).apply(null,arguments)},_e=t.___funcs_on_exit=function(){return(_e=t.___funcs_on_exit=t.asm.hb).apply(null,arguments)},ke=t._setThrew=function(){return(ke=t._setThrew=t.asm.jb).apply(null,arguments)},Se=t.stackSave=function(){return(Se=t.stackSave=t.asm.kb).apply(null,arguments)},Te=t.stackRestore=function(){return(Te=t.stackRestore=t.asm.lb).apply(null,arguments)},Ie=t.stackAlloc=function(){return(Ie=t.stackAlloc=t.asm.mb).apply(null,arguments)},Ee=t.___cxa_can_catch=function(){return(Ee=t.___cxa_can_catch=t.asm.nb).apply(null,arguments)},Ae=t.___cxa_is_pointer_type=function(){return(Ae=t.___cxa_is_pointer_type=t.asm.ob).apply(null,arguments)},Ce=t.dynCall_j=function(){return(Ce=t.dynCall_j=t.asm.pb).apply(null,arguments)},Ne=t.dynCall_iiiiij=function(){return(Ne=t.dynCall_iiiiij=t.asm.qb).apply(null,arguments)},$e=t.dynCall_jii=function(){return($e=t.dynCall_jii=t.asm.rb).apply(null,arguments)},Oe=t.dynCall_viiiiij=function(){return(Oe=t.dynCall_viiiiij=t.asm.sb).apply(null,arguments)},De=t.dynCall_vjji=function(){return(De=t.dynCall_vjji=t.asm.tb).apply(null,arguments)},Fe=t.dynCall_viiijjjii=function(){return(Fe=t.dynCall_viiijjjii=t.asm.ub).apply(null,arguments)},Re=t.dynCall_iij=function(){return(Re=t.dynCall_iij=t.asm.vb).apply(null,arguments)},Me=t.dynCall_ji=function(){return(Me=t.dynCall_ji=t.asm.wb).apply(null,arguments)},Le=t.dynCall_iiiiiij=function(){return(Le=t.dynCall_iiiiiij=t.asm.xb).apply(null,arguments)},Pe=t.dynCall_iiij=function(){return(Pe=t.dynCall_iiij=t.asm.yb).apply(null,arguments)};function ze(){function e(){if(!ye&&(ye=!0,t.calledRun=!0,!C)){if(Q(P),s(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();B.unshift(e)}Q(B)}}if(!(0<W)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)U();Q(L),0<W||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.UTF8ToString=O,t.stringToUTF8=function(e,t,n){return D(e,I,t,n)},t.lengthBytesUTF8=F,t.stackSave=Se,t.stackRestore=Te,t.stackAlloc=Ie,H=function e(){ye||ze(),ye||(H=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return ze(),e.ready});e.exports=s},4537:e=>{"use strict";e.exports=function(e,t){for(var n=new Array(arguments.length-1),r=0,s=2,a=!0;s<arguments.length;)n[r++]=arguments[s++];return new Promise((function(s,i){n[r]=function(e){if(a)if(a=!1,e)i(e);else{for(var t=new Array(arguments.length-1),n=0;n<t.length;)t[n++]=arguments[n];s.apply(null,t)}};try{e.apply(t||null,n)}catch(e){a&&(a=!1,i(e))}}))}},7419:(e,t)=>{"use strict";var n=t;n.length=function(e){var t=e.length;if(!t)return 0;for(var n=0;--t%4>1&&"="===e.charAt(t);)++n;return Math.ceil(3*e.length)/4-n};for(var r=new Array(64),s=new Array(123),a=0;a<64;)s[r[a]=a<26?a+65:a<52?a+71:a<62?a-4:a-59|43]=a++;n.encode=function(e,t,n){for(var s,a=null,i=[],o=0,l=0;t<n;){var u=e[t++];switch(l){case 0:i[o++]=r[u>>2],s=(3&u)<<4,l=1;break;case 1:i[o++]=r[s|u>>4],s=(15&u)<<2,l=2;break;case 2:i[o++]=r[s|u>>6],i[o++]=r[63&u],l=0}o>8191&&((a||(a=[])).push(String.fromCharCode.apply(String,i)),o=0)}return l&&(i[o++]=r[s],i[o++]=61,1===l&&(i[o++]=61)),a?(o&&a.push(String.fromCharCode.apply(String,i.slice(0,o))),a.join("")):String.fromCharCode.apply(String,i.slice(0,o))};var i="invalid encoding";n.decode=function(e,t,n){for(var r,a=n,o=0,l=0;l<e.length;){var u=e.charCodeAt(l++);if(61===u&&o>1)break;if(void 0===(u=s[u]))throw Error(i);switch(o){case 0:r=u,o=1;break;case 1:t[n++]=r<<2|(48&u)>>4,r=u,o=2;break;case 2:t[n++]=(15&r)<<4|(60&u)>>2,r=u,o=3;break;case 3:t[n++]=(3&r)<<6|u,o=0}}if(1===o)throw Error(i);return n-a},n.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}},9211:e=>{"use strict";function t(){this._listeners={}}e.exports=t,t.prototype.on=function(e,t,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:n||this}),this},t.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var n=this._listeners[e],r=0;r<n.length;)n[r].fn===t?n.splice(r,1):++r;return this},t.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<t.length;)t[r].fn.apply(t[r++].ctx,n)}return this}},945:e=>{"use strict";function t(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),n=new Uint8Array(t.buffer),r=128===n[3];function s(e,r,s){t[0]=e,r[s]=n[0],r[s+1]=n[1],r[s+2]=n[2],r[s+3]=n[3]}function a(e,r,s){t[0]=e,r[s]=n[3],r[s+1]=n[2],r[s+2]=n[1],r[s+3]=n[0]}function i(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],t[0]}function o(e,r){return n[3]=e[r],n[2]=e[r+1],n[1]=e[r+2],n[0]=e[r+3],t[0]}e.writeFloatLE=r?s:a,e.writeFloatBE=r?a:s,e.readFloatLE=r?i:o,e.readFloatBE=r?o:i}():function(){function t(e,t,n,r){var s=t<0?1:0;if(s&&(t=-t),0===t)e(1/t>0?0:2147483648,n,r);else if(isNaN(t))e(2143289344,n,r);else if(t>34028234663852886e22)e((s<<31|2139095040)>>>0,n,r);else if(t<11754943508222875e-54)e((s<<31|Math.round(t/1401298464324817e-60))>>>0,n,r);else{var a=Math.floor(Math.log(t)/Math.LN2);e((s<<31|a+127<<23|8388607&Math.round(t*Math.pow(2,-a)*8388608))>>>0,n,r)}}function i(e,t,n){var r=e(t,n),s=2*(r>>31)+1,a=r>>>23&255,i=8388607&r;return 255===a?i?NaN:s*(1/0):0===a?1401298464324817e-60*s*i:s*Math.pow(2,a-150)*(i+8388608)}e.writeFloatLE=t.bind(null,n),e.writeFloatBE=t.bind(null,r),e.readFloatLE=i.bind(null,s),e.readFloatBE=i.bind(null,a)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),n=new Uint8Array(t.buffer),r=128===n[7];function s(e,r,s){t[0]=e,r[s]=n[0],r[s+1]=n[1],r[s+2]=n[2],r[s+3]=n[3],r[s+4]=n[4],r[s+5]=n[5],r[s+6]=n[6],r[s+7]=n[7]}function a(e,r,s){t[0]=e,r[s]=n[7],r[s+1]=n[6],r[s+2]=n[5],r[s+3]=n[4],r[s+4]=n[3],r[s+5]=n[2],r[s+6]=n[1],r[s+7]=n[0]}function i(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],n[4]=e[r+4],n[5]=e[r+5],n[6]=e[r+6],n[7]=e[r+7],t[0]}function o(e,r){return n[7]=e[r],n[6]=e[r+1],n[5]=e[r+2],n[4]=e[r+3],n[3]=e[r+4],n[2]=e[r+5],n[1]=e[r+6],n[0]=e[r+7],t[0]}e.writeDoubleLE=r?s:a,e.writeDoubleBE=r?a:s,e.readDoubleLE=r?i:o,e.readDoubleBE=r?o:i}():function(){function t(e,t,n,r,s,a){var i=r<0?1:0;if(i&&(r=-r),0===r)e(0,s,a+t),e(1/r>0?0:2147483648,s,a+n);else if(isNaN(r))e(0,s,a+t),e(2146959360,s,a+n);else if(r>17976931348623157e292)e(0,s,a+t),e((i<<31|2146435072)>>>0,s,a+n);else{var o;if(r<22250738585072014e-324)e((o=r/5e-324)>>>0,s,a+t),e((i<<31|o/4294967296)>>>0,s,a+n);else{var l=Math.floor(Math.log(r)/Math.LN2);1024===l&&(l=1023),e(4503599627370496*(o=r*Math.pow(2,-l))>>>0,s,a+t),e((i<<31|l+1023<<20|1048576*o&1048575)>>>0,s,a+n)}}}function i(e,t,n,r,s){var a=e(r,s+t),i=e(r,s+n),o=2*(i>>31)+1,l=i>>>20&2047,u=4294967296*(1048575&i)+a;return 2047===l?u?NaN:o*(1/0):0===l?5e-324*o*u:o*Math.pow(2,l-1075)*(u+4503599627370496)}e.writeDoubleLE=t.bind(null,n,0,4),e.writeDoubleBE=t.bind(null,r,4,0),e.readDoubleLE=i.bind(null,s,0,4),e.readDoubleBE=i.bind(null,a,4,0)}(),e}function n(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function r(e,t,n){t[n]=e>>>24,t[n+1]=e>>>16&255,t[n+2]=e>>>8&255,t[n+3]=255&e}function s(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function a(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}e.exports=t(t)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},6662:e=>{"use strict";e.exports=function(e,t,n){var r=n||8192,s=r>>>1,a=null,i=r;return function(n){if(n<1||n>s)return e(n);i+n>r&&(a=e(r),i=0);var o=t.call(a,i,i+=n);return 7&i&&(i=1+(7|i)),o}}},4997:(e,t)=>{"use strict";var n=t;n.length=function(e){for(var t=0,n=0,r=0;r<e.length;++r)(n=e.charCodeAt(r))<128?t+=1:n<2048?t+=2:55296==(64512&n)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t},n.read=function(e,t,n){if(n-t<1)return"";for(var r,s=null,a=[],i=0;t<n;)(r=e[t++])<128?a[i++]=r:r>191&&r<224?a[i++]=(31&r)<<6|63&e[t++]:r>239&&r<365?(r=((7&r)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,a[i++]=55296+(r>>10),a[i++]=56320+(1023&r)):a[i++]=(15&r)<<12|(63&e[t++])<<6|63&e[t++],i>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,a)),i=0);return s?(i&&s.push(String.fromCharCode.apply(String,a.slice(0,i))),s.join("")):String.fromCharCode.apply(String,a.slice(0,i))},n.write=function(e,t,n){for(var r,s,a=n,i=0;i<e.length;++i)(r=e.charCodeAt(i))<128?t[n++]=r:r<2048?(t[n++]=r>>6|192,t[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(s=e.charCodeAt(i+1)))?(r=65536+((1023&r)<<10)+(1023&s),++i,t[n++]=r>>18|240,t[n++]=r>>12&63|128,t[n++]=r>>6&63|128,t[n++]=63&r|128):(t[n++]=r>>12|224,t[n++]=r>>6&63|128,t[n++]=63&r|128);return n-a}},3442:(e,t)=>{"use strict";t.__esModule=!0;var n=function(){function e(t){if(!t)throw new TypeError("Invalid argument; `value` has no value.");this.value=e.EMPTY,t&&e.isGuid(t)&&(this.value=t)}return e.isGuid=function(t){var n=t.toString();return t&&(t instanceof e||e.validator.test(n))},e.create=function(){return new e([e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-"))},e.createEmpty=function(){return new e("emptyguid")},e.parse=function(t){return new e(t)},e.raw=function(){return[e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-")},e.gen=function(e){for(var t="",n=0;n<e;n++)t+=(65536*(1+Math.random())|0).toString(16).substring(1);return t},e.prototype.equals=function(t){return e.isGuid(t)&&this.value===t.toString()},e.prototype.isEmpty=function(){return this.value===e.EMPTY},e.prototype.toString=function(){return this.value},e.prototype.toJSON=function(){return{value:this.value}},e.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),e.EMPTY="00000000-0000-0000-0000-000000000000",e}();t.Guid=n},3720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return _}else{if(e<=-f)return k;if(e+1>=f)return x}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));a=a.mul(h).add(o(d))}else a=(a=a.mul(s)).add(o(d))}return a.unsigned=t,a}function d(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var b=i(0,!0);n.UZERO=b;var y=i(1);n.ONE=y;var w=i(1,!0);n.UONE=w;var v=i(-1);n.NEG_ONE=v;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var _=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var k=l(0,-2147483648,!1);n.MIN_VALUE=k;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return!(1&~this.low)},S.isEven=function(){return!(1&this.low)},S.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(y)},S.neg=S.negate,S.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,h+=(p+=s+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},S.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(k))return e.isOdd()?k:g;if(e.eq(k))return this.isOdd()?k:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,w=0;return y+=(w+=i*p)>>>16,b+=(y+=a*p)>>>16,y&=65535,b+=(y+=i*h)>>>16,f+=(b+=s*p)>>>16,b&=65535,f+=(b+=a*h)>>>16,b&=65535,f+=(b+=i*c)>>>16,f+=n*p+s*h+a*c+i*u,l((y&=65535)<<16|(w&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return w;a=b}else{if(this.eq(k))return e.eq(y)||e.eq(v)?k:e.eq(k)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:v:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(k))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(s);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=y),a=a.add(h),s=s.sub(p)}return a},S.div=S.divide,S.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return l(~this.low,~this.high,this.unsigned)},S.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},1446:(e,t,n)=>{"use strict";var r,s,a,i=n(2100),o=i.Reader,l=i.Writer,u=i.util,c=i.roots.default||(i.roots.default={});c.onnx=((a={}).Version=(r={},(s=Object.create(r))[r[0]="_START_VERSION"]=0,s[r[1]="IR_VERSION_2017_10_10"]=1,s[r[2]="IR_VERSION_2017_10_30"]=2,s[r[3]="IR_VERSION_2017_11_3"]=3,s[r[4]="IR_VERSION_2019_1_22"]=4,s[r[5]="IR_VERSION"]=5,s),a.AttributeProto=function(){function e(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=u.Long?u.Long.fromBits(0,0,!1):0,e.prototype.s=u.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.floats=u.emptyArray,e.prototype.ints=u.emptyArray,e.prototype.strings=u.emptyArray,e.prototype.tensors=u.emptyArray,e.prototype.graphs=u.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.f&&e.hasOwnProperty("f")&&t.uint32(21).float(e.f),null!=e.i&&e.hasOwnProperty("i")&&t.uint32(24).int64(e.i),null!=e.s&&e.hasOwnProperty("s")&&t.uint32(34).bytes(e.s),null!=e.t&&e.hasOwnProperty("t")&&c.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),null!=e.g&&e.hasOwnProperty("g")&&c.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),null!=e.floats&&e.floats.length){t.uint32(58).fork();for(var n=0;n<e.floats.length;++n)t.float(e.floats[n]);t.ldelim()}if(null!=e.ints&&e.ints.length){for(t.uint32(66).fork(),n=0;n<e.ints.length;++n)t.int64(e.ints[n]);t.ldelim()}if(null!=e.strings&&e.strings.length)for(n=0;n<e.strings.length;++n)t.uint32(74).bytes(e.strings[n]);if(null!=e.tensors&&e.tensors.length)for(n=0;n<e.tensors.length;++n)c.onnx.TensorProto.encode(e.tensors[n],t.uint32(82).fork()).ldelim();if(null!=e.graphs&&e.graphs.length)for(n=0;n<e.graphs.length;++n)c.onnx.GraphProto.encode(e.graphs[n],t.uint32(90).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(106).string(e.docString),null!=e.type&&e.hasOwnProperty("type")&&t.uint32(160).int32(e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&t.uint32(170).string(e.refAttrName),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.AttributeProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.name=e.string();break;case 21:r.refAttrName=e.string();break;case 13:r.docString=e.string();break;case 20:r.type=e.int32();break;case 2:r.f=e.float();break;case 3:r.i=e.int64();break;case 4:r.s=e.bytes();break;case 5:r.t=c.onnx.TensorProto.decode(e,e.uint32());break;case 6:r.g=c.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&s))for(var a=e.uint32()+e.pos;e.pos<a;)r.floats.push(e.float());else r.floats.push(e.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.ints.push(e.int64());else r.ints.push(e.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(e.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(c.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!u.isString(e.name))return"name: string expected";if(null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&!u.isString(e.refAttrName))return"refAttrName: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!u.isString(e.docString))return"docString: string expected";if(null!=e.type&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=e.f&&e.hasOwnProperty("f")&&"number"!=typeof e.f)return"f: number expected";if(null!=e.i&&e.hasOwnProperty("i")&&!(u.isInteger(e.i)||e.i&&u.isInteger(e.i.low)&&u.isInteger(e.i.high)))return"i: integer|Long expected";if(null!=e.s&&e.hasOwnProperty("s")&&!(e.s&&"number"==typeof e.s.length||u.isString(e.s)))return"s: buffer expected";if(null!=e.t&&e.hasOwnProperty("t")&&(n=c.onnx.TensorProto.verify(e.t)))return"t."+n;if(null!=e.g&&e.hasOwnProperty("g")&&(n=c.onnx.GraphProto.verify(e.g)))return"g."+n;if(null!=e.floats&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if("number"!=typeof e.floats[t])return"floats: number[] expected"}if(null!=e.ints&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(u.isInteger(e.ints[t])||e.ints[t]&&u.isInteger(e.ints[t].low)&&u.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(null!=e.strings&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&"number"==typeof e.strings[t].length||u.isString(e.strings[t])))return"strings: buffer[] expected"}if(null!=e.tensors&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(n=c.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+n}if(null!=e.graphs&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t){var n;if(n=c.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.AttributeProto)return e;var t=new c.onnx.AttributeProto;switch(null!=e.name&&(t.name=String(e.name)),null!=e.refAttrName&&(t.refAttrName=String(e.refAttrName)),null!=e.docString&&(t.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10}if(null!=e.f&&(t.f=Number(e.f)),null!=e.i&&(u.Long?(t.i=u.Long.fromValue(e.i)).unsigned=!1:"string"==typeof e.i?t.i=parseInt(e.i,10):"number"==typeof e.i?t.i=e.i:"object"==typeof e.i&&(t.i=new u.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),null!=e.s&&("string"==typeof e.s?u.base64.decode(e.s,t.s=u.newBuffer(u.base64.length(e.s)),0):e.s.length&&(t.s=e.s)),null!=e.t){if("object"!=typeof e.t)throw TypeError(".onnx.AttributeProto.t: object expected");t.t=c.onnx.TensorProto.fromObject(e.t)}if(null!=e.g){if("object"!=typeof e.g)throw TypeError(".onnx.AttributeProto.g: object expected");t.g=c.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var n=0;n<e.floats.length;++n)t.floats[n]=Number(e.floats[n])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],n=0;n<e.ints.length;++n)u.Long?(t.ints[n]=u.Long.fromValue(e.ints[n])).unsigned=!1:"string"==typeof e.ints[n]?t.ints[n]=parseInt(e.ints[n],10):"number"==typeof e.ints[n]?t.ints[n]=e.ints[n]:"object"==typeof e.ints[n]&&(t.ints[n]=new u.LongBits(e.ints[n].low>>>0,e.ints[n].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],n=0;n<e.strings.length;++n)"string"==typeof e.strings[n]?u.base64.decode(e.strings[n],t.strings[n]=u.newBuffer(u.base64.length(e.strings[n])),0):e.strings[n].length&&(t.strings[n]=e.strings[n])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],n=0;n<e.tensors.length;++n){if("object"!=typeof e.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[n]=c.onnx.TensorProto.fromObject(e.tensors[n])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],n=0;n<e.graphs.length;++n){if("object"!=typeof e.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[n]=c.onnx.GraphProto.fromObject(e.graphs[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),t.defaults){if(n.name="",n.f=0,u.Long){var r=new u.Long(0,0,!1);n.i=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.i=t.longs===String?"0":0;t.bytes===String?n.s="":(n.s=[],t.bytes!==Array&&(n.s=u.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.type=t.enums===String?"UNDEFINED":0,n.refAttrName=""}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.f&&e.hasOwnProperty("f")&&(n.f=t.json&&!isFinite(e.f)?String(e.f):e.f),null!=e.i&&e.hasOwnProperty("i")&&("number"==typeof e.i?n.i=t.longs===String?String(e.i):e.i:n.i=t.longs===String?u.Long.prototype.toString.call(e.i):t.longs===Number?new u.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),null!=e.s&&e.hasOwnProperty("s")&&(n.s=t.bytes===String?u.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),null!=e.t&&e.hasOwnProperty("t")&&(n.t=c.onnx.TensorProto.toObject(e.t,t)),null!=e.g&&e.hasOwnProperty("g")&&(n.g=c.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){n.floats=[];for(var s=0;s<e.floats.length;++s)n.floats[s]=t.json&&!isFinite(e.floats[s])?String(e.floats[s]):e.floats[s]}if(e.ints&&e.ints.length)for(n.ints=[],s=0;s<e.ints.length;++s)"number"==typeof e.ints[s]?n.ints[s]=t.longs===String?String(e.ints[s]):e.ints[s]:n.ints[s]=t.longs===String?u.Long.prototype.toString.call(e.ints[s]):t.longs===Number?new u.LongBits(e.ints[s].low>>>0,e.ints[s].high>>>0).toNumber():e.ints[s];if(e.strings&&e.strings.length)for(n.strings=[],s=0;s<e.strings.length;++s)n.strings[s]=t.bytes===String?u.base64.encode(e.strings[s],0,e.strings[s].length):t.bytes===Array?Array.prototype.slice.call(e.strings[s]):e.strings[s];if(e.tensors&&e.tensors.length)for(n.tensors=[],s=0;s<e.tensors.length;++s)n.tensors[s]=c.onnx.TensorProto.toObject(e.tensors[s],t);if(e.graphs&&e.graphs.length)for(n.graphs=[],s=0;s<e.graphs.length;++s)n.graphs[s]=c.onnx.GraphProto.toObject(e.graphs[s],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.type&&e.hasOwnProperty("type")&&(n.type=t.enums===String?c.onnx.AttributeProto.AttributeType[e.type]:e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&(n.refAttrName=e.refAttrName),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t}(),e}(),a.ValueInfoProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.type&&e.hasOwnProperty("type")&&c.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(26).string(e.docString),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ValueInfoProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.name=e.string();break;case 2:r.type=c.onnx.TypeProto.decode(e,e.uint32());break;case 3:r.docString=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!u.isString(e.name))return"name: string expected";if(null!=e.type&&e.hasOwnProperty("type")){var t=c.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return null!=e.docString&&e.hasOwnProperty("docString")&&!u.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.ValueInfoProto)return e;var t=new c.onnx.ValueInfoProto;if(null!=e.name&&(t.name=String(e.name)),null!=e.type){if("object"!=typeof e.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=c.onnx.TypeProto.fromObject(e.type)}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.name="",n.type=null,n.docString=""),null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.type&&e.hasOwnProperty("type")&&(n.type=c.onnx.TypeProto.toObject(e.type,t)),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.NodeProto=function(){function e(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.input=u.emptyArray,e.prototype.output=u.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=u.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.input&&e.input.length)for(var n=0;n<e.input.length;++n)t.uint32(10).string(e.input[n]);if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)t.uint32(18).string(e.output[n]);if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(26).string(e.name),null!=e.opType&&e.hasOwnProperty("opType")&&t.uint32(34).string(e.opType),null!=e.attribute&&e.attribute.length)for(n=0;n<e.attribute.length;++n)c.onnx.AttributeProto.encode(e.attribute[n],t.uint32(42).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(58).string(e.domain),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.NodeProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(e.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(e.string());break;case 3:r.name=e.string();break;case 4:r.opType=e.string();break;case 7:r.domain=e.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(c.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:r.docString=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!u.isString(e.input[t]))return"input: string[] expected"}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!u.isString(e.output[t]))return"output: string[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!u.isString(e.name))return"name: string expected";if(null!=e.opType&&e.hasOwnProperty("opType")&&!u.isString(e.opType))return"opType: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!u.isString(e.domain))return"domain: string expected";if(null!=e.attribute&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var n=c.onnx.AttributeProto.verify(e.attribute[t]);if(n)return"attribute."+n}}return null!=e.docString&&e.hasOwnProperty("docString")&&!u.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.NodeProto)return e;var t=new c.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var n=0;n<e.input.length;++n)t.input[n]=String(e.input[n])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n)t.output[n]=String(e.output[n])}if(null!=e.name&&(t.name=String(e.name)),null!=e.opType&&(t.opType=String(e.opType)),null!=e.domain&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],n=0;n<e.attribute.length;++n){if("object"!=typeof e.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[n]=c.onnx.AttributeProto.fromObject(e.attribute[n])}}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.input=[],n.output=[],n.attribute=[]),t.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),e.input&&e.input.length){n.input=[];for(var r=0;r<e.input.length;++r)n.input[r]=e.input[r]}if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=e.output[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.opType&&e.hasOwnProperty("opType")&&(n.opType=e.opType),e.attribute&&e.attribute.length)for(n.attribute=[],r=0;r<e.attribute.length;++r)n.attribute[r]=c.onnx.AttributeProto.toObject(e.attribute[r],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.ModelProto=function(){function e(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.irVersion=u.Long?u.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=u.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=u.Long?u.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=u.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.irVersion&&e.hasOwnProperty("irVersion")&&t.uint32(8).int64(e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&t.uint32(18).string(e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&t.uint32(26).string(e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(34).string(e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&t.uint32(40).int64(e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&c.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),null!=e.opsetImport&&e.opsetImport.length)for(var n=0;n<e.opsetImport.length;++n)c.onnx.OperatorSetIdProto.encode(e.opsetImport[n],t.uint32(66).fork()).ldelim();if(null!=e.metadataProps&&e.metadataProps.length)for(n=0;n<e.metadataProps.length;++n)c.onnx.StringStringEntryProto.encode(e.metadataProps[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ModelProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.irVersion=e.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:r.producerName=e.string();break;case 3:r.producerVersion=e.string();break;case 4:r.domain=e.string();break;case 5:r.modelVersion=e.int64();break;case 6:r.docString=e.string();break;case 7:r.graph=c.onnx.GraphProto.decode(e,e.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&!(u.isInteger(e.irVersion)||e.irVersion&&u.isInteger(e.irVersion.low)&&u.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(null!=e.opsetImport&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(n=c.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+n}if(null!=e.producerName&&e.hasOwnProperty("producerName")&&!u.isString(e.producerName))return"producerName: string expected";if(null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&!u.isString(e.producerVersion))return"producerVersion: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!u.isString(e.domain))return"domain: string expected";if(null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&!(u.isInteger(e.modelVersion)||e.modelVersion&&u.isInteger(e.modelVersion.low)&&u.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!u.isString(e.docString))return"docString: string expected";if(null!=e.graph&&e.hasOwnProperty("graph")&&(n=c.onnx.GraphProto.verify(e.graph)))return"graph."+n;if(null!=e.metadataProps&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.ModelProto)return e;var t=new c.onnx.ModelProto;if(null!=e.irVersion&&(u.Long?(t.irVersion=u.Long.fromValue(e.irVersion)).unsigned=!1:"string"==typeof e.irVersion?t.irVersion=parseInt(e.irVersion,10):"number"==typeof e.irVersion?t.irVersion=e.irVersion:"object"==typeof e.irVersion&&(t.irVersion=new u.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var n=0;n<e.opsetImport.length;++n){if("object"!=typeof e.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[n]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n])}}if(null!=e.producerName&&(t.producerName=String(e.producerName)),null!=e.producerVersion&&(t.producerVersion=String(e.producerVersion)),null!=e.domain&&(t.domain=String(e.domain)),null!=e.modelVersion&&(u.Long?(t.modelVersion=u.Long.fromValue(e.modelVersion)).unsigned=!1:"string"==typeof e.modelVersion?t.modelVersion=parseInt(e.modelVersion,10):"number"==typeof e.modelVersion?t.modelVersion=e.modelVersion:"object"==typeof e.modelVersion&&(t.modelVersion=new u.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),null!=e.docString&&(t.docString=String(e.docString)),null!=e.graph){if("object"!=typeof e.graph)throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=c.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],n=0;n<e.metadataProps.length;++n){if("object"!=typeof e.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[n]=c.onnx.StringStringEntryProto.fromObject(e.metadataProps[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.opsetImport=[],n.metadataProps=[]),t.defaults){if(u.Long){var r=new u.Long(0,0,!1);n.irVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.irVersion=t.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",u.Long?(r=new u.Long(0,0,!1),n.modelVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.modelVersion=t.longs===String?"0":0,n.docString="",n.graph=null}if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&("number"==typeof e.irVersion?n.irVersion=t.longs===String?String(e.irVersion):e.irVersion:n.irVersion=t.longs===String?u.Long.prototype.toString.call(e.irVersion):t.longs===Number?new u.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&(n.producerName=e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&(n.producerVersion=e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&("number"==typeof e.modelVersion?n.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:n.modelVersion=t.longs===String?u.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new u.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&(n.graph=c.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){n.opsetImport=[];for(var s=0;s<e.opsetImport.length;++s)n.opsetImport[s]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[s],t)}if(e.metadataProps&&e.metadataProps.length)for(n.metadataProps=[],s=0;s<e.metadataProps.length;++s)n.metadataProps[s]=c.onnx.StringStringEntryProto.toObject(e.metadataProps[s],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.StringStringEntryProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.key&&e.hasOwnProperty("key")&&t.uint32(10).string(e.key),null!=e.value&&e.hasOwnProperty("value")&&t.uint32(18).string(e.value),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.StringStringEntryProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.key=e.string();break;case 2:r.value=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.key&&e.hasOwnProperty("key")&&!u.isString(e.key)?"key: string expected":null!=e.value&&e.hasOwnProperty("value")&&!u.isString(e.value)?"value: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.StringStringEntryProto)return e;var t=new c.onnx.StringStringEntryProto;return null!=e.key&&(t.key=String(e.key)),null!=e.value&&(t.value=String(e.value)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.key="",n.value=""),null!=e.key&&e.hasOwnProperty("key")&&(n.key=e.key),null!=e.value&&e.hasOwnProperty("value")&&(n.value=e.value),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.TensorAnnotation=function(){function e(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=u.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&t.uint32(10).string(e.tensorName),null!=e.quantParameterTensorNames&&e.quantParameterTensorNames.length)for(var n=0;n<e.quantParameterTensorNames.length;++n)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n],t.uint32(18).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorAnnotation;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.tensorName=e.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorName&&e.hasOwnProperty("tensorName")&&!u.isString(e.tensorName))return"tensorName: string expected";if(null!=e.quantParameterTensorNames&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var n=c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(n)return"quantParameterTensorNames."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorAnnotation)return e;var t=new c.onnx.TensorAnnotation;if(null!=e.tensorName&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var n=0;n<e.quantParameterTensorNames.length;++n){if("object"!=typeof e.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[n]=c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.quantParameterTensorNames=[]),t.defaults&&(n.tensorName=""),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&(n.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.GraphProto=function(){function e(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.node=u.emptyArray,e.prototype.name="",e.prototype.initializer=u.emptyArray,e.prototype.docString="",e.prototype.input=u.emptyArray,e.prototype.output=u.emptyArray,e.prototype.valueInfo=u.emptyArray,e.prototype.quantizationAnnotation=u.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.node&&e.node.length)for(var n=0;n<e.node.length;++n)c.onnx.NodeProto.encode(e.node[n],t.uint32(10).fork()).ldelim();if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(18).string(e.name),null!=e.initializer&&e.initializer.length)for(n=0;n<e.initializer.length;++n)c.onnx.TensorProto.encode(e.initializer[n],t.uint32(42).fork()).ldelim();if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(82).string(e.docString),null!=e.input&&e.input.length)for(n=0;n<e.input.length;++n)c.onnx.ValueInfoProto.encode(e.input[n],t.uint32(90).fork()).ldelim();if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)c.onnx.ValueInfoProto.encode(e.output[n],t.uint32(98).fork()).ldelim();if(null!=e.valueInfo&&e.valueInfo.length)for(n=0;n<e.valueInfo.length;++n)c.onnx.ValueInfoProto.encode(e.valueInfo[n],t.uint32(106).fork()).ldelim();if(null!=e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n=0;n<e.quantizationAnnotation.length;++n)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.GraphProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break;case 2:r.name=e.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 10:r.docString=e.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.node&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(n=c.onnx.NodeProto.verify(e.node[t]))return"node."+n}if(null!=e.name&&e.hasOwnProperty("name")&&!u.isString(e.name))return"name: string expected";if(null!=e.initializer&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(n=c.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+n}if(null!=e.docString&&e.hasOwnProperty("docString")&&!u.isString(e.docString))return"docString: string expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.input[t]))return"input."+n}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.output[t]))return"output."+n}if(null!=e.valueInfo&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+n}if(null!=e.quantizationAnnotation&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var n;if(n=c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.GraphProto)return e;var t=new c.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var n=0;n<e.node.length;++n){if("object"!=typeof e.node[n])throw TypeError(".onnx.GraphProto.node: object expected");t.node[n]=c.onnx.NodeProto.fromObject(e.node[n])}}if(null!=e.name&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],n=0;n<e.initializer.length;++n){if("object"!=typeof e.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[n]=c.onnx.TensorProto.fromObject(e.initializer[n])}}if(null!=e.docString&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],n=0;n<e.input.length;++n){if("object"!=typeof e.input[n])throw TypeError(".onnx.GraphProto.input: object expected");t.input[n]=c.onnx.ValueInfoProto.fromObject(e.input[n])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n){if("object"!=typeof e.output[n])throw TypeError(".onnx.GraphProto.output: object expected");t.output[n]=c.onnx.ValueInfoProto.fromObject(e.output[n])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],n=0;n<e.valueInfo.length;++n){if("object"!=typeof e.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[n]=c.onnx.ValueInfoProto.fromObject(e.valueInfo[n])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],n=0;n<e.quantizationAnnotation.length;++n){if("object"!=typeof e.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[n]=c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),t.defaults&&(n.name="",n.docString=""),e.node&&e.node.length){n.node=[];for(var r=0;r<e.node.length;++r)n.node[r]=c.onnx.NodeProto.toObject(e.node[r],t)}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),e.initializer&&e.initializer.length)for(n.initializer=[],r=0;r<e.initializer.length;++r)n.initializer[r]=c.onnx.TensorProto.toObject(e.initializer[r],t);if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.input&&e.input.length)for(n.input=[],r=0;r<e.input.length;++r)n.input[r]=c.onnx.ValueInfoProto.toObject(e.input[r],t);if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=c.onnx.ValueInfoProto.toObject(e.output[r],t);if(e.valueInfo&&e.valueInfo.length)for(n.valueInfo=[],r=0;r<e.valueInfo.length;++r)n.valueInfo[r]=c.onnx.ValueInfoProto.toObject(e.valueInfo[r],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[r],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.TensorProto=function(){function e(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dims=u.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=u.emptyArray,e.prototype.int32Data=u.emptyArray,e.prototype.stringData=u.emptyArray,e.prototype.int64Data=u.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=u.newBuffer([]),e.prototype.externalData=u.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=u.emptyArray,e.prototype.uint64Data=u.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.dims&&e.dims.length){t.uint32(10).fork();for(var n=0;n<e.dims.length;++n)t.int64(e.dims[n]);t.ldelim()}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&t.uint32(16).int32(e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&c.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),null!=e.floatData&&e.floatData.length){for(t.uint32(34).fork(),n=0;n<e.floatData.length;++n)t.float(e.floatData[n]);t.ldelim()}if(null!=e.int32Data&&e.int32Data.length){for(t.uint32(42).fork(),n=0;n<e.int32Data.length;++n)t.int32(e.int32Data[n]);t.ldelim()}if(null!=e.stringData&&e.stringData.length)for(n=0;n<e.stringData.length;++n)t.uint32(50).bytes(e.stringData[n]);if(null!=e.int64Data&&e.int64Data.length){for(t.uint32(58).fork(),n=0;n<e.int64Data.length;++n)t.int64(e.int64Data[n]);t.ldelim()}if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(66).string(e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&t.uint32(74).bytes(e.rawData),null!=e.doubleData&&e.doubleData.length){for(t.uint32(82).fork(),n=0;n<e.doubleData.length;++n)t.double(e.doubleData[n]);t.ldelim()}if(null!=e.uint64Data&&e.uint64Data.length){for(t.uint32(90).fork(),n=0;n<e.uint64Data.length;++n)t.uint64(e.uint64Data[n]);t.ldelim()}if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(98).string(e.docString),null!=e.externalData&&e.externalData.length)for(n=0;n<e.externalData.length;++n)c.onnx.StringStringEntryProto.encode(e.externalData[n],t.uint32(106).fork()).ldelim();return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&t.uint32(112).int32(e.dataLocation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&s))for(var a=e.uint32()+e.pos;e.pos<a;)r.dims.push(e.int64());else r.dims.push(e.int64());break;case 2:r.dataType=e.int32();break;case 3:r.segment=c.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.floatData.push(e.float());else r.floatData.push(e.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.int32Data.push(e.int32());else r.int32Data.push(e.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(e.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.int64Data.push(e.int64());else r.int64Data.push(e.int64());break;case 8:r.name=e.string();break;case 12:r.docString=e.string();break;case 9:r.rawData=e.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:r.dataLocation=e.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.doubleData.push(e.double());else r.doubleData.push(e.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.uint64Data.push(e.uint64());else r.uint64Data.push(e.uint64());break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dims&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(u.isInteger(e.dims[t])||e.dims[t]&&u.isInteger(e.dims[t].low)&&u.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&!u.isInteger(e.dataType))return"dataType: integer expected";if(null!=e.segment&&e.hasOwnProperty("segment")&&(n=c.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+n;if(null!=e.floatData&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if("number"!=typeof e.floatData[t])return"floatData: number[] expected"}if(null!=e.int32Data&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!u.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(null!=e.stringData&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&"number"==typeof e.stringData[t].length||u.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(null!=e.int64Data&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(u.isInteger(e.int64Data[t])||e.int64Data[t]&&u.isInteger(e.int64Data[t].low)&&u.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!u.isString(e.name))return"name: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!u.isString(e.docString))return"docString: string expected";if(null!=e.rawData&&e.hasOwnProperty("rawData")&&!(e.rawData&&"number"==typeof e.rawData.length||u.isString(e.rawData)))return"rawData: buffer expected";if(null!=e.externalData&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+n}}if(null!=e.dataLocation&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=e.doubleData&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if("number"!=typeof e.doubleData[t])return"doubleData: number[] expected"}if(null!=e.uint64Data&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(u.isInteger(e.uint64Data[t])||e.uint64Data[t]&&u.isInteger(e.uint64Data[t].low)&&u.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto)return e;var t=new c.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var n=0;n<e.dims.length;++n)u.Long?(t.dims[n]=u.Long.fromValue(e.dims[n])).unsigned=!1:"string"==typeof e.dims[n]?t.dims[n]=parseInt(e.dims[n],10):"number"==typeof e.dims[n]?t.dims[n]=e.dims[n]:"object"==typeof e.dims[n]&&(t.dims[n]=new u.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber())}if(null!=e.dataType&&(t.dataType=0|e.dataType),null!=e.segment){if("object"!=typeof e.segment)throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=c.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],n=0;n<e.floatData.length;++n)t.floatData[n]=Number(e.floatData[n])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],n=0;n<e.int32Data.length;++n)t.int32Data[n]=0|e.int32Data[n]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],n=0;n<e.stringData.length;++n)"string"==typeof e.stringData[n]?u.base64.decode(e.stringData[n],t.stringData[n]=u.newBuffer(u.base64.length(e.stringData[n])),0):e.stringData[n].length&&(t.stringData[n]=e.stringData[n])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],n=0;n<e.int64Data.length;++n)u.Long?(t.int64Data[n]=u.Long.fromValue(e.int64Data[n])).unsigned=!1:"string"==typeof e.int64Data[n]?t.int64Data[n]=parseInt(e.int64Data[n],10):"number"==typeof e.int64Data[n]?t.int64Data[n]=e.int64Data[n]:"object"==typeof e.int64Data[n]&&(t.int64Data[n]=new u.LongBits(e.int64Data[n].low>>>0,e.int64Data[n].high>>>0).toNumber())}if(null!=e.name&&(t.name=String(e.name)),null!=e.docString&&(t.docString=String(e.docString)),null!=e.rawData&&("string"==typeof e.rawData?u.base64.decode(e.rawData,t.rawData=u.newBuffer(u.base64.length(e.rawData)),0):e.rawData.length&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],n=0;n<e.externalData.length;++n){if("object"!=typeof e.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[n]=c.onnx.StringStringEntryProto.fromObject(e.externalData[n])}}switch(e.dataLocation){case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],n=0;n<e.doubleData.length;++n)t.doubleData[n]=Number(e.doubleData[n])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],n=0;n<e.uint64Data.length;++n)u.Long?(t.uint64Data[n]=u.Long.fromValue(e.uint64Data[n])).unsigned=!0:"string"==typeof e.uint64Data[n]?t.uint64Data[n]=parseInt(e.uint64Data[n],10):"number"==typeof e.uint64Data[n]?t.uint64Data[n]=e.uint64Data[n]:"object"==typeof e.uint64Data[n]&&(t.uint64Data[n]=new u.LongBits(e.uint64Data[n].low>>>0,e.uint64Data[n].high>>>0).toNumber(!0))}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),t.defaults&&(n.dataType=0,n.segment=null,n.name="",t.bytes===String?n.rawData="":(n.rawData=[],t.bytes!==Array&&(n.rawData=u.newBuffer(n.rawData))),n.docString="",n.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){n.dims=[];for(var r=0;r<e.dims.length;++r)"number"==typeof e.dims[r]?n.dims[r]=t.longs===String?String(e.dims[r]):e.dims[r]:n.dims[r]=t.longs===String?u.Long.prototype.toString.call(e.dims[r]):t.longs===Number?new u.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber():e.dims[r]}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&(n.dataType=e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&(n.segment=c.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(n.floatData=[],r=0;r<e.floatData.length;++r)n.floatData[r]=t.json&&!isFinite(e.floatData[r])?String(e.floatData[r]):e.floatData[r];if(e.int32Data&&e.int32Data.length)for(n.int32Data=[],r=0;r<e.int32Data.length;++r)n.int32Data[r]=e.int32Data[r];if(e.stringData&&e.stringData.length)for(n.stringData=[],r=0;r<e.stringData.length;++r)n.stringData[r]=t.bytes===String?u.base64.encode(e.stringData[r],0,e.stringData[r].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[r]):e.stringData[r];if(e.int64Data&&e.int64Data.length)for(n.int64Data=[],r=0;r<e.int64Data.length;++r)"number"==typeof e.int64Data[r]?n.int64Data[r]=t.longs===String?String(e.int64Data[r]):e.int64Data[r]:n.int64Data[r]=t.longs===String?u.Long.prototype.toString.call(e.int64Data[r]):t.longs===Number?new u.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber():e.int64Data[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&(n.rawData=t.bytes===String?u.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(n.doubleData=[],r=0;r<e.doubleData.length;++r)n.doubleData[r]=t.json&&!isFinite(e.doubleData[r])?String(e.doubleData[r]):e.doubleData[r];if(e.uint64Data&&e.uint64Data.length)for(n.uint64Data=[],r=0;r<e.uint64Data.length;++r)"number"==typeof e.uint64Data[r]?n.uint64Data[r]=t.longs===String?String(e.uint64Data[r]):e.uint64Data[r]:n.uint64Data[r]=t.longs===String?u.Long.prototype.toString.call(e.uint64Data[r]):t.longs===Number?new u.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0):e.uint64Data[r];if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.externalData&&e.externalData.length)for(n.externalData=[],r=0;r<e.externalData.length;++r)n.externalData[r]=c.onnx.StringStringEntryProto.toObject(e.externalData[r],t);return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&(n.dataLocation=t.enums===String?c.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t}(),e.Segment=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.begin=u.Long?u.Long.fromBits(0,0,!1):0,e.prototype.end=u.Long?u.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.begin&&e.hasOwnProperty("begin")&&t.uint32(8).int64(e.begin),null!=e.end&&e.hasOwnProperty("end")&&t.uint32(16).int64(e.end),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto.Segment;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.begin=e.int64();break;case 2:r.end=e.int64();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.begin&&e.hasOwnProperty("begin")&&!(u.isInteger(e.begin)||e.begin&&u.isInteger(e.begin.low)&&u.isInteger(e.begin.high))?"begin: integer|Long expected":null!=e.end&&e.hasOwnProperty("end")&&!(u.isInteger(e.end)||e.end&&u.isInteger(e.end.low)&&u.isInteger(e.end.high))?"end: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto.Segment)return e;var t=new c.onnx.TensorProto.Segment;return null!=e.begin&&(u.Long?(t.begin=u.Long.fromValue(e.begin)).unsigned=!1:"string"==typeof e.begin?t.begin=parseInt(e.begin,10):"number"==typeof e.begin?t.begin=e.begin:"object"==typeof e.begin&&(t.begin=new u.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber())),null!=e.end&&(u.Long?(t.end=u.Long.fromValue(e.end)).unsigned=!1:"string"==typeof e.end?t.end=parseInt(e.end,10):"number"==typeof e.end?t.end=e.end:"object"==typeof e.end&&(t.end=new u.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults){if(u.Long){var r=new u.Long(0,0,!1);n.begin=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.begin=t.longs===String?"0":0;u.Long?(r=new u.Long(0,0,!1),n.end=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.end=t.longs===String?"0":0}return null!=e.begin&&e.hasOwnProperty("begin")&&("number"==typeof e.begin?n.begin=t.longs===String?String(e.begin):e.begin:n.begin=t.longs===String?u.Long.prototype.toString.call(e.begin):t.longs===Number?new u.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber():e.begin),null!=e.end&&e.hasOwnProperty("end")&&("number"==typeof e.end?n.end=t.longs===String?String(e.end):e.end:n.end=t.longs===String?u.Long.prototype.toString.call(e.end):t.longs===Number?new u.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber():e.end),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),e}(),a.TensorShapeProto=function(){function e(e){if(this.dim=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dim=u.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.dim&&e.dim.length)for(var n=0;n<e.dim.length;++n)c.onnx.TensorShapeProto.Dimension.encode(e.dim[n],t.uint32(10).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto;e.pos<n;){var s=e.uint32();s>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&s)}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dim&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var n=c.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(n)return"dim."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto)return e;var t=new c.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var n=0;n<e.dim.length;++n){if("object"!=typeof e.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[n]=c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dim=[]),e.dim&&e.dim.length){n.dim=[];for(var r=0;r<e.dim.length;++r)n.dim[r]=c.onnx.TensorShapeProto.Dimension.toObject(e.dim[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.Dimension=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.dimValue=u.Long?u.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:u.oneOfGetter(t=["dimValue","dimParam"]),set:u.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&t.uint32(8).int64(e.dimValue),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&t.uint32(18).string(e.dimParam),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(26).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto.Dimension;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.dimValue=e.int64();break;case 2:r.dimParam=e.string();break;case 3:r.denotation=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";var t={};if(null!=e.dimValue&&e.hasOwnProperty("dimValue")&&(t.value=1,!(u.isInteger(e.dimValue)||e.dimValue&&u.isInteger(e.dimValue.low)&&u.isInteger(e.dimValue.high))))return"dimValue: integer|Long expected";if(null!=e.dimParam&&e.hasOwnProperty("dimParam")){if(1===t.value)return"value: multiple values";if(t.value=1,!u.isString(e.dimParam))return"dimParam: string expected"}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!u.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto.Dimension)return e;var t=new c.onnx.TensorShapeProto.Dimension;return null!=e.dimValue&&(u.Long?(t.dimValue=u.Long.fromValue(e.dimValue)).unsigned=!1:"string"==typeof e.dimValue?t.dimValue=parseInt(e.dimValue,10):"number"==typeof e.dimValue?t.dimValue=e.dimValue:"object"==typeof e.dimValue&&(t.dimValue=new u.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber())),null!=e.dimParam&&(t.dimParam=String(e.dimParam)),null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&("number"==typeof e.dimValue?n.dimValue=t.longs===String?String(e.dimValue):e.dimValue:n.dimValue=t.longs===String?u.Long.prototype.toString.call(e.dimValue):t.longs===Number?new u.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber():e.dimValue,t.oneofs&&(n.value="dimValue")),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&(n.dimParam=e.dimParam,t.oneofs&&(n.value="dimParam")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e}(),a.TypeProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.tensorType=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:u.oneOfGetter(t=["tensorType"]),set:u.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&c.onnx.TypeProto.Tensor.encode(e.tensorType,t.uint32(10).fork()).ldelim(),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(50).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.tensorType=c.onnx.TypeProto.Tensor.decode(e,e.uint32());break;case 6:r.denotation=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorType&&e.hasOwnProperty("tensorType")){var t=c.onnx.TypeProto.Tensor.verify(e.tensorType);if(t)return"tensorType."+t}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!u.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto)return e;var t=new c.onnx.TypeProto;if(null!=e.tensorType){if("object"!=typeof e.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");t.tensorType=c.onnx.TypeProto.Tensor.fromObject(e.tensorType)}return null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&(n.tensorType=c.onnx.TypeProto.Tensor.toObject(e.tensorType,t),t.oneofs&&(n.value="tensorType")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.Tensor=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.elemType&&e.hasOwnProperty("elemType")&&t.uint32(8).int32(e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&c.onnx.TensorShapeProto.encode(e.shape,t.uint32(18).fork()).ldelim(),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto.Tensor;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.elemType=e.int32();break;case 2:r.shape=c.onnx.TensorShapeProto.decode(e,e.uint32());break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.elemType&&e.hasOwnProperty("elemType")&&!u.isInteger(e.elemType))return"elemType: integer expected";if(null!=e.shape&&e.hasOwnProperty("shape")){var t=c.onnx.TensorShapeProto.verify(e.shape);if(t)return"shape."+t}return null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto.Tensor)return e;var t=new c.onnx.TypeProto.Tensor;if(null!=e.elemType&&(t.elemType=0|e.elemType),null!=e.shape){if("object"!=typeof e.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");t.shape=c.onnx.TensorShapeProto.fromObject(e.shape)}return t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.elemType=0,n.shape=null),null!=e.elemType&&e.hasOwnProperty("elemType")&&(n.elemType=e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&(n.shape=c.onnx.TensorShapeProto.toObject(e.shape,t)),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e}(),a.OperatorSetIdProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.domain="",e.prototype.version=u.Long?u.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(10).string(e.domain),null!=e.version&&e.hasOwnProperty("version")&&t.uint32(16).int64(e.version),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.OperatorSetIdProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.domain=e.string();break;case 2:r.version=e.int64();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.domain&&e.hasOwnProperty("domain")&&!u.isString(e.domain)?"domain: string expected":null!=e.version&&e.hasOwnProperty("version")&&!(u.isInteger(e.version)||e.version&&u.isInteger(e.version.low)&&u.isInteger(e.version.high))?"version: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.OperatorSetIdProto)return e;var t=new c.onnx.OperatorSetIdProto;return null!=e.domain&&(t.domain=String(e.domain)),null!=e.version&&(u.Long?(t.version=u.Long.fromValue(e.version)).unsigned=!1:"string"==typeof e.version?t.version=parseInt(e.version,10):"number"==typeof e.version?t.version=e.version:"object"==typeof e.version&&(t.version=new u.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults)if(n.domain="",u.Long){var r=new u.Long(0,0,!1);n.version=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.version=t.longs===String?"0":0;return null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.version&&e.hasOwnProperty("version")&&("number"==typeof e.version?n.version=t.longs===String?String(e.version):e.version:n.version=t.longs===String?u.Long.prototype.toString.call(e.version):t.longs===Number?new u.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a),e.exports=c},2100:(e,t,n)=>{"use strict";e.exports=n(9482)},9482:(e,t,n)=>{"use strict";var r=t;function s(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=s,s()},1408:(e,t,n)=>{"use strict";e.exports=l;var r,s=n(9693),a=s.LongBits,i=s.utf8;function o(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function l(e){this.buf=e,this.pos=0,this.len=e.length}var u,c="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new l(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new l(e);throw Error("illegal buffer")},d=function(){return s.Buffer?function(e){return(l.create=function(e){return s.Buffer.isBuffer(e)?new r(e):c(e)})(e)}:c};function h(){var e=new a(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw o(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw o(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function p(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function f(){if(this.pos+8>this.len)throw o(this,8);return new a(p(this.buf,this.pos+=4),p(this.buf,this.pos+=4))}l.create=d(),l.prototype._slice=s.Array.prototype.subarray||s.Array.prototype.slice,l.prototype.uint32=(u=4294967295,function(){if(u=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return u;if(u=(u|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return u;if(u=(u|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return u;if(u=(u|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return u;if(u=(u|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return u;if((this.pos+=5)>this.len)throw this.pos=this.len,o(this,10);return u}),l.prototype.int32=function(){return 0|this.uint32()},l.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)},l.prototype.bool=function(){return 0!==this.uint32()},l.prototype.fixed32=function(){if(this.pos+4>this.len)throw o(this,4);return p(this.buf,this.pos+=4)},l.prototype.sfixed32=function(){if(this.pos+4>this.len)throw o(this,4);return 0|p(this.buf,this.pos+=4)},l.prototype.float=function(){if(this.pos+4>this.len)throw o(this,4);var e=s.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},l.prototype.double=function(){if(this.pos+8>this.len)throw o(this,4);var e=s.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},l.prototype.bytes=function(){var e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw o(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,n):t===n?new this.buf.constructor(0):this._slice.call(this.buf,t,n)},l.prototype.string=function(){var e=this.bytes();return i.read(e,0,e.length)},l.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw o(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw o(this)}while(128&this.buf[this.pos++]);return this},l.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},l._configure=function(e){r=e,l.create=d(),r._configure();var t=s.Long?"toLong":"toNumber";s.merge(l.prototype,{int64:function(){return h.call(this)[t](!1)},uint64:function(){return h.call(this)[t](!0)},sint64:function(){return h.call(this).zzDecode()[t](!1)},fixed64:function(){return f.call(this)[t](!0)},sfixed64:function(){return f.call(this)[t](!1)}})}},593:(e,t,n)=>{"use strict";e.exports=a;var r=n(1408);(a.prototype=Object.create(r.prototype)).constructor=a;var s=n(9693);function a(e){r.call(this,e)}a._configure=function(){s.Buffer&&(a.prototype._slice=s.Buffer.prototype.slice)},a.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},a._configure()},5054:e=>{"use strict";e.exports={}},5994:(e,t,n)=>{"use strict";t.Service=n(7948)},7948:(e,t,n)=>{"use strict";e.exports=s;var r=n(9693);function s(e,t,n){if("function"!=typeof e)throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(n)}(s.prototype=Object.create(r.EventEmitter.prototype)).constructor=s,s.prototype.rpcCall=function e(t,n,s,a,i){if(!a)throw TypeError("request must be specified");var o=this;if(!i)return r.asPromise(e,o,t,n,s,a);if(o.rpcImpl)try{return o.rpcImpl(t,n[o.requestDelimited?"encodeDelimited":"encode"](a).finish(),(function(e,n){if(e)return o.emit("error",e,t),i(e);if(null!==n){if(!(n instanceof s))try{n=s[o.responseDelimited?"decodeDelimited":"decode"](n)}catch(e){return o.emit("error",e,t),i(e)}return o.emit("data",n,t),i(null,n)}o.end(!0)}))}catch(e){return o.emit("error",e,t),void setTimeout((function(){i(e)}),0)}else setTimeout((function(){i(Error("already ended"))}),0)},s.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(e,t,n)=>{"use strict";e.exports=s;var r=n(9693);function s(e,t){this.lo=e>>>0,this.hi=t>>>0}var a=s.zero=new s(0,0);a.toNumber=function(){return 0},a.zzEncode=a.zzDecode=function(){return this},a.length=function(){return 1};var i=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(e){if(0===e)return a;var t=e<0;t&&(e=-e);var n=e>>>0,r=(e-n)/4294967296>>>0;return t&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new s(n,r)},s.from=function(e){if("number"==typeof e)return s.fromNumber(e);if(r.isString(e)){if(!r.Long)return s.fromNumber(parseInt(e,10));e=r.Long.fromString(e)}return e.low||e.high?new s(e.low>>>0,e.high>>>0):a},s.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,n=~this.hi>>>0;return t||(n=n+1>>>0),-(t+4294967296*n)}return this.lo+4294967296*this.hi},s.prototype.toLong=function(e){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var o=String.prototype.charCodeAt;s.fromHash=function(e){return e===i?a:new s((o.call(e,0)|o.call(e,1)<<8|o.call(e,2)<<16|o.call(e,3)<<24)>>>0,(o.call(e,4)|o.call(e,5)<<8|o.call(e,6)<<16|o.call(e,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},s.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},s.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}},9693:function(e,t,n){"use strict";var r=t;function s(e,t,n){for(var r=Object.keys(t),s=0;s<r.length;++s)void 0!==e[r[s]]&&n||(e[r[s]]=t[r[s]]);return e}function a(e){function t(e,n){if(!(this instanceof t))return new t(e,n);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),n&&s(this,n)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},r.isString=function(e){return"string"==typeof e||e instanceof String},r.isObject=function(e){return e&&"object"==typeof e},r.isset=r.isSet=function(e,t){var n=e[t];return!(null==n||!e.hasOwnProperty(t))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var e=r.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(e){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(e){return"number"==typeof e?r.Buffer?r._Buffer_allocUnsafe(e):new r.Array(e):r.Buffer?r._Buffer_from(e):"undefined"==typeof Uint8Array?e:new Uint8Array(e)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(e){return e?r.LongBits.from(e).toHash():r.LongBits.zeroHash},r.longFromHash=function(e,t){var n=r.LongBits.fromHash(e);return r.Long?r.Long.fromBits(n.lo,n.hi,t):n.toNumber(Boolean(t))},r.merge=s,r.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},r.newError=a,r.ProtocolError=a("ProtocolError"),r.oneOfGetter=function(e){for(var t={},n=0;n<e.length;++n)t[e[n]]=1;return function(){for(var e=Object.keys(this),n=e.length-1;n>-1;--n)if(1===t[e[n]]&&void 0!==this[e[n]]&&null!==this[e[n]])return e[n]}},r.oneOfSetter=function(e){return function(t){for(var n=0;n<e.length;++n)e[n]!==t&&delete this[e[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var e=r.Buffer;e?(r._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,n){return new e(t,n)},r._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(e,t,n)=>{"use strict";e.exports=d;var r,s=n(9693),a=s.LongBits,i=s.base64,o=s.utf8;function l(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}function u(){}function c(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function d(){this.len=0,this.head=new l(u,0,0),this.tail=this.head,this.states=null}var h=function(){return s.Buffer?function(){return(d.create=function(){return new r})()}:function(){return new d}};function p(e,t,n){t[n]=255&e}function f(e,t){this.len=e,this.next=void 0,this.val=t}function m(e,t,n){for(;e.hi;)t[n++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=127&e.lo|128,e.lo=e.lo>>>7;t[n++]=e.lo}function g(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}d.create=h(),d.alloc=function(e){return new s.Array(e)},s.Array!==Array&&(d.alloc=s.pool(d.alloc,s.Array.prototype.subarray)),d.prototype._push=function(e,t,n){return this.tail=this.tail.next=new l(e,t,n),this.len+=t,this},f.prototype=Object.create(l.prototype),f.prototype.fn=function(e,t,n){for(;e>127;)t[n++]=127&e|128,e>>>=7;t[n]=e},d.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new f((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},d.prototype.int32=function(e){return e<0?this._push(m,10,a.fromNumber(e)):this.uint32(e)},d.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},d.prototype.uint64=function(e){var t=a.from(e);return this._push(m,t.length(),t)},d.prototype.int64=d.prototype.uint64,d.prototype.sint64=function(e){var t=a.from(e).zzEncode();return this._push(m,t.length(),t)},d.prototype.bool=function(e){return this._push(p,1,e?1:0)},d.prototype.fixed32=function(e){return this._push(g,4,e>>>0)},d.prototype.sfixed32=d.prototype.fixed32,d.prototype.fixed64=function(e){var t=a.from(e);return this._push(g,4,t.lo)._push(g,4,t.hi)},d.prototype.sfixed64=d.prototype.fixed64,d.prototype.float=function(e){return this._push(s.float.writeFloatLE,4,e)},d.prototype.double=function(e){return this._push(s.float.writeDoubleLE,8,e)};var b=s.Array.prototype.set?function(e,t,n){t.set(e,n)}:function(e,t,n){for(var r=0;r<e.length;++r)t[n+r]=e[r]};d.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(p,1,0);if(s.isString(e)){var n=d.alloc(t=i.length(e));i.decode(e,n,0),e=n}return this.uint32(t)._push(b,t,e)},d.prototype.string=function(e){var t=o.length(e);return t?this.uint32(t)._push(o.write,t,e):this._push(p,1,0)},d.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new l(u,0,0),this.len=0,this},d.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new l(u,0,0),this.len=0),this},d.prototype.ldelim=function(){var e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=t,this.len+=n),this},d.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t},d._configure=function(e){r=e,d.create=h(),r._configure()}},3155:(e,t,n)=>{"use strict";e.exports=a;var r=n(1173);(a.prototype=Object.create(r.prototype)).constructor=a;var s=n(9693);function a(){r.call(this)}function i(e,t,n){e.length<40?s.utf8.write(e,t,n):t.utf8Write?t.utf8Write(e,n):t.write(e,n)}a._configure=function(){a.alloc=s._Buffer_allocUnsafe,a.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&"set"===s.Buffer.prototype.set.name?function(e,t,n){t.set(e,n)}:function(e,t,n){if(e.copy)e.copy(t,n,0,e.length);else for(var r=0;r<e.length;)t[n++]=e[r++]}},a.prototype.bytes=function(e){s.isString(e)&&(e=s._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(a.writeBytesBuffer,t,e),this},a.prototype.string=function(e){var t=s.Buffer.byteLength(e);return this.uint32(t),t&&this._push(i,t,e),this},a._configure()},7714:(e,t,n)=>{"use strict";t.R=void 0;const r=n(6919),s=n(7448);t.R=new class{async init(){}async createSessionHandler(e,t){const n=new r.Session(t);return await n.loadModel(e),new s.OnnxjsSessionHandler(n)}}},4200:(e,t,n)=>{"use strict";t.c8=t.rX=void 0;const r=n(1670),s=n(5381),a=n(2157),i=n(2306);t.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const e="undefined"==typeof navigator?(0,s.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,a.initWasm)()}async createSessionHandler(e,t){const n=new i.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(e,t),Promise.resolve(n)}}},6018:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),s(n(1670),t);const a=n(1670);{const e=n(7714).R;(0,a.registerBackend)("webgl",e,-10)}{const e=n(4200).c8;(0,a.registerBackend)("cpu",e,10),(0,a.registerBackend)("wasm",e,10),(0,a.registerBackend)("xnnpack",e,9)}},246:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7778:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const r=n(1446),s=n(9395),a=n(9162),i=n(2517);var o=s.onnxruntime.experimental.fbs;class l{constructor(e){if(this._attributes=new Map,null!=e){for(const t of e)t instanceof r.onnx.AttributeProto?this._attributes.set(t.name,[l.getValue(t),l.getType(t)]):t instanceof o.Attribute&&this._attributes.set(t.name(),[l.getValue(t),l.getType(t)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,t,n){this._attributes.set(e,[n,t])}delete(e){this._attributes.delete(e)}getFloat(e,t){return this.get(e,"float",t)}getInt(e,t){return this.get(e,"int",t)}getString(e,t){return this.get(e,"string",t)}getTensor(e,t){return this.get(e,"tensor",t)}getFloats(e,t){return this.get(e,"floats",t)}getInts(e,t){return this.get(e,"ints",t)}getStrings(e,t){return this.get(e,"strings",t)}getTensors(e,t){return this.get(e,"tensors",t)}get(e,t,n){const r=this._attributes.get(e);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${e}`)}if(r[1]!==t)throw new Error(`type mismatch: expected ${t} but got ${r[1]}`);return r[0]}static getType(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();switch(t){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[t]}`)}}static getValue(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();if(t===r.onnx.AttributeProto.AttributeType.GRAPH||t===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(e);if(t===r.onnx.AttributeProto.AttributeType.INT&&i.LongUtil.isLong(n))return i.LongUtil.longToNumber(n);if(t===r.onnx.AttributeProto.AttributeType.INTS){const e=n,t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];t[n]=i.LongUtil.longToNumber(r)}return t}if(t===r.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof r.onnx.AttributeProto?a.Tensor.fromProto(n):a.Tensor.fromOrtTensor(n);if(t===r.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof r.onnx.AttributeProto)return n.map((e=>a.Tensor.fromProto(e)));if(e instanceof o.Attribute)return n.map((e=>a.Tensor.fromOrtTensor(e)))}if(t===r.onnx.AttributeProto.AttributeType.STRING&&e instanceof r.onnx.AttributeProto){const e=n;return(0,i.decodeUtf8String)(e)}return t===r.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof r.onnx.AttributeProto?n.map(i.decodeUtf8String):n}static getValueNoCheck(e){return e instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case r.onnx.AttributeProto.AttributeType.INT:return e.i;case r.onnx.AttributeProto.AttributeType.STRING:return e.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case r.onnx.AttributeProto.AttributeType.INTS:return e.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case o.AttributeType.FLOAT:return e.f();case o.AttributeType.INT:return e.i();case o.AttributeType.STRING:return e.s();case o.AttributeType.TENSOR:return e.t();case o.AttributeType.GRAPH:return e.g();case o.AttributeType.FLOATS:return e.floatsArray();case o.AttributeType.INTS:{const t=[];for(let n=0;n<e.intsLength();n++)t.push(e.ints(n));return t}case o.AttributeType.STRINGS:{const t=[];for(let n=0;n<e.stringsLength();n++)t.push(e.strings(n));return t}case o.AttributeType.TENSORS:{const t=[];for(let n=0;n<e.tensorsLength();n++)t.push(e.tensors(n));return t}default:throw new Error(`unsupported attribute type: ${o.AttributeType[e.type()]}`)}}}t.Attribute=l},7091:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const r=n(5038),s=new Map;async function a(e){const n=t.backend;if(void 0!==n[e]&&function(e){const t=e;return"initialize"in t&&"function"==typeof t.initialize&&"createSessionHandler"in t&&"function"==typeof t.createSessionHandler&&"dispose"in t&&"function"==typeof t.dispose}(n[e])){const t=n[e];let r=t.initialize();if("object"==typeof r&&"then"in r&&(r=await r),r)return s.set(e,t),t}}t.backend={webgl:new r.WebGLBackend},t.resolveBackend=async function e(t){if(!t)return e(["webgl"]);{const e="string"==typeof t?[t]:t;for(const t of e){const e=s.get(t);if(e)return e;const n=await a(t);if(n)return n}}throw new Error("no available backend to use")}},5038:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const r=n(1670),s=n(6231),a=n(6416),i=n(7305);t.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(e){r.env.webgl.contextId=e}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){r.env.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(e){r.env.webgl.textureCacheMode=e}get pack(){return r.env.webgl.pack}set pack(e){r.env.webgl.pack=e}get async(){return r.env.webgl.async}set async(e){r.env.webgl.async=e}initialize(){try{return this.glContext=(0,i.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),s.Logger.setWithEnv(r.env),s.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return s.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new a.WebGLSessionHandler(this,e)}dispose(){this.glContext.dispose()}}},5107:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const r=n(2517),s=n(8520),a=n(5060),i=n(7859),o=n(9390);class l extends s.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new s.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new s.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},i="getOutputCoords";switch(t.length){case 0:r[i]=this.getOutputScalarCoords();break;case 1:r[i]=this.getOutputPacked1DCoords(t,n);break;case 2:r[i]=this.getOutputPacked2DCoords(t,n);break;case 3:r[i]=this.getOutputPacked3DCoords(t,n);break;default:r[i]=this.getOutputPackedNDCoords(t,n)}const o=`\n      void setOutput(vec4 val) {\n        ${(0,a.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return r.floatTextureSetRGBA=new s.GlslLibRoutine(o),r}getUnpackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},i="getOutputCoords";switch(t.length){case 0:r[i]=this.getOutputScalarCoords();break;case 1:r[i]=this.getOutputUnpacked1DCoords(t,n);break;case 2:r[i]=this.getOutputUnpacked2DCoords(t,n);break;case 3:r[i]=this.getOutputUnpacked3DCoords(t,n);break;case 4:r[i]=this.getOutputUnpacked4DCoords(t,n);break;case 5:r[i]=this.getOutputUnpacked5DCoords(t,n);break;case 6:r[i]=this.getOutputUnpacked6DCoords(t,n);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}const o=`\n        void setOutput(float val) {\n          ${(0,a.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return r.floatTextureSetR=new s.GlslLibRoutine(o),r}getOutputScalarCoords(){return new s.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(e,t){const n=t;let r="";return 1===n[0]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new s.GlslLibRoutine(r)):1===n[1]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new s.GlslLibRoutine(r)):(r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new s.GlslLibRoutine(r))}getOutputPacked2DCoords(e,t){let n="";if(r.ArrayUtil.arraysEqual(e,t))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `,new s.GlslLibRoutine(n);const a=t,i=Math.ceil(e[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${a[0]}, ${a[1]}));\n\n          int index = resTexRC.y * ${a[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${i}) * 2;\n          int c = 2 * (index / ${i});\n\n          return ivec2(r, c);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputPacked3DCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[2]/2),a=r*Math.ceil(e[1]/2),i=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${a};\n          index -= b * ${a};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;return new s.GlslLibRoutine(i)}getOutputPackedNDCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[e.length-1]/2),a=r*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,l=`b${t}, `+l;const u=`\n      ivec${e.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${o}\n\n        int b = index / ${a};\n        index -= b * ${a};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${e.length}(${l});\n      }\n    `;return new s.GlslLibRoutine(u)}getOutputUnpacked1DCoords(e,t){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;return new s.GlslLibRoutine(n)}getOutputUnpacked2DCoords(e,t){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${e[1]};\n          int c = index - r * ${e[1]};\n          return ivec2(r, c);\n        }\n      `;return new s.GlslLibRoutine(n)}getOutputUnpacked3DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d"],o=a.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${o}\n          return ivec3(r, c, d);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputUnpacked4DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d","d2"],o=a.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${o}\n          return ivec4(r, c, d, d2);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputUnpacked5DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d","d2","d3"],o=a.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${o}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputUnpacked6DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d","d2","d3","d4"],o=a.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${o}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new s.GlslLibRoutine(n)}getCommonUtilFuncs(){const e={};let t="uvFromFlat";e[t]=new s.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),t="packedUVfrom1D",e[t]=new s.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom2D",e[t]=new s.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom3D",e[t]=new s.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="sampleTexture";const n=(0,a.getGlsl)(this.context.glContext.version);return e[t]=new s.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),e}getInputsSamplingSnippets(){const e={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const s=this.context.inputTextureLayouts[r],a=(0,o.generateShaderFuncNameFromInputSamplerName)(n);s.isPacked?e[a]=this.getPackedSamplerFromInput(a,n,s):e[a]=this.getUnpackedSamplerFromInput(a,n,s);const i=(0,o.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);s.unpackedShape.length<=t.unpackedShape.length&&(s.isPacked?e[i]=this.getPackedSamplerAtOutputCoords(i,s,t,n):e[i]=this.getUnpackedSamplerAtOutputCoords(i,s,t,n))})),e}getPackedSamplerAtOutputCoords(e,t,n,a){const i=t.unpackedShape,l=n.unpackedShape,u=a,c=(0,o.generateShaderFuncNameFromInputSamplerName)(u),d=i.length,h=l.length,p=r.BroadcastUtil.getBroadcastDims(i,l),f=(0,o.getCoordsDataType)(h),m=h-d;let g;const b=(0,o.getGlChannels)();g=0===d?"":h<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${b[e+m]} = 0;`)).join("\n");let y="";y=h<2&&d>0?"coords":i.map(((e,t)=>`coords.${b[t+m]}`)).join(", ");let w="return outputValue;";const v=1===r.ShapeUtil.size(i),x=1===r.ShapeUtil.size(l);if(1!==d||v||x){if(v&&!x)w=1===h?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(p.length){const e=d-2,t=d-1;p.indexOf(e)>-1&&p.indexOf(t)>-1?w="return vec4(outputValue.x);":p.indexOf(e)>-1?w="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":p.indexOf(t)>-1&&(w="return vec4(outputValue.xx, outputValue.zz);")}}else w="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const _=`\n      vec4 ${e}() {\n        ${f} coords = getOutputCoords();\n        \n        int lastDim = coords.${b[h-1]};\n        coords.${b[h-1]} = coords.${b[h-2]};\n        coords.${b[h-2]} = lastDim;\n      \n        ${g}\n        vec4 outputValue = ${c}(${y});\n        ${w}\n      }\n    `;return new s.GlslLibRoutine(_,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,t,n,a){const i=[n.width,n.height],l=[t.width,t.height],u=t.unpackedShape.length,c=n.unpackedShape.length,d=t.unpackedShape,h=n.unpackedShape,p=(0,o.generateShaderFuncNameFromInputSamplerName)(a);if(u===c&&r.ArrayUtil.arraysEqual(l,i)){const t=`\n          float ${e}() {\n            return sampleTexture(${a}, TexCoords);\n          }\n        `;return new s.GlslLibRoutine(t,["coordinates.sampleTexture"])}const f=(0,o.getCoordsDataType)(c),m=r.BroadcastUtil.getBroadcastDims(d,h),g=c-u;let b;const y=(0,o.getGlChannels)();b=0===u?"":c<2&&m.length>=1?"coords = 0;":m.map((e=>`coords.${y[e+g]} = 0;`)).join("\n");let w="";w=c<2&&u>0?"coords":t.unpackedShape.map(((e,t)=>`coords.${y[t+g]}`)).join(", ");const v=`\n        float ${e}() {\n          ${f} coords = getOutputCoords();\n          ${b}\n          return ${p}(${w});\n        }\n      `;return new s.GlslLibRoutine(v,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,t,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,t);case 1:return this.getPackedSampler1D(e,t,n);case 2:return this.getPackedSampler2D(e,t,n);case 3:return this.getPackedSampler3D(e,t,n);default:return this.getPackedSamplerND(e,t,n)}}getUnpackedSamplerFromInput(e,t,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(e,t,n);case 1:return this.getUnpackedSampler1D(e,t,n);case 2:return this.getUnpackedSampler2D(e,t,n);case 3:return this.getUnpackedSampler3D(e,t,n);case 4:return this.getUnpackedSampler4D(e,t,n);case 5:return this.getUnpackedSampler5D(e,t,n);case 6:return this.getUnpackedSampler6D(e,t,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(e,t){const n=`\n          vec4 ${e}() {\n            return ${(0,a.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);\n          }\n        `;return new s.GlslLibRoutine(n)}getPackedSampler1D(e,t,n){const r=[n.width,n.height],i=[r[1],r[0]],o=(0,a.getGlsl)(this.context.glContext.version),l=`vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }`;return new s.GlslLibRoutine(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,t,n){const i=n.unpackedShape,o=[n.width,n.height],l=(0,a.getGlsl)(this.context.glContext.version),u=o[0],c=o[1];if(null!=o&&r.ArrayUtil.arraysEqual(i,o)){const n=`vec4 ${e}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${u}.0);\n        return ${l.texture2D}(${t}, uv);\n      }`;return new s.GlslLibRoutine(n)}const d=o,h=Math.ceil(i[1]/2),p=`vec4 ${e}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d[1]}, ${d[0]}, ${h}, row, col);\n      return ${l.texture2D}(${t}, uv);\n    }`;return new s.GlslLibRoutine(p,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,t,n){const r=n.unpackedShape,i=[n.width,n.height],l=[i[0],i[1]],u=(0,a.getGlsl)(this.context.glContext.version);if(1===r[0]){const a=r.slice(1),i=[1,2],l=(0,o.squeezeInputShape)(r,a),u=["b","row","col"],c=JSON.parse(JSON.stringify(n));c.unpackedShape=l;const d=this.getPackedSamplerFromInput(e,t,c),h=`${d.routineBody}\n      vec4 ${e}(int b, int row, int col) {\n        return ${e}(${(0,o.getSqueezedParams)(u,i)});\n      } `;return new s.GlslLibRoutine(h,d.dependencies)}const c=l[0],d=l[1],h=Math.ceil(r[2]/2),p=`vec4 ${e}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${d}, ${c}, ${h*Math.ceil(r[1]/2)}, ${h}, b, row, col);\n      return ${u.texture2D}(${t}, uv);}`;return new s.GlslLibRoutine(p,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,t,n){const r=n.unpackedShape,i=r.length,o=[n.width,n.height],l=(0,a.getGlsl)(this.context.glContext.version),u=[o[0],o[1]],c=u[1],d=u[0],h=Math.ceil(r[i-1]/2);let p=h*Math.ceil(r[i-2]/2),f="int b, int row, int col",m=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let e=2;e<i-1;e++)f=`int b${e}, `+f,p*=r[i-e-1],m=`b${e} * ${p} + `+m;const g=`vec4 ${e}(${f}) {\n      int index = ${m};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});\n      return ${l.texture2D}(${t}, uv);\n    }`;return new s.GlslLibRoutine(g)}getUnpackedSamplerScalar(e,t,n){const[r,a]=[n.width,n.height];if(1===r&&1===a){const n=`\n          float ${e}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}const i=`\n        float ${e}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${a});\n          vec2 uv = uvFromFlat(${r}, ${a}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,t,n){const r=n.width,a=n.height;if(1===a&&1===r){const n=`\n        float ${e}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===a){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===r){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${a}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}const i=`\n        float ${e}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${a}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,t,n){const a=n.unpackedShape,l=[n.height,n.width];if(null!=l&&r.ArrayUtil.arraysEqual(a,l)){const n=`\n          float ${e}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${l[1]}.0, ${l[0]}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}const{newShape:u,keptDims:c}=(0,i.squeezeShape)(a),d=u;if(d.length<a.length){const r=(0,o.squeezeInputShape)(a,d),i=JSON.parse(JSON.stringify(n));i.unpackedShape=r;const l=["col","row"],u=`\n          ${this.getUnpackedSamplerFromInput(e,t,i).routineBody}\n          float ${e}(int row, int col) {\n            return ${e}(${(0,o.getSqueezedParams)(l,c)});\n          }\n        `;return new s.GlslLibRoutine(u,["coordinates.sampleTexture"])}const h=l[1],p=l[0];if(1===p){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${h}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${a[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===h){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${h}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${a[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const f=`\n        float ${e}(int row, int col) {\n          int index = col * ${a[1]} + row;\n          vec2 uv = uvFromFlat(${h}, ${p}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,t,n){const r=n.unpackedShape,a=r[1]*r[2],l=r[2],{newShape:u,keptDims:c}=(0,i.squeezeShape)(r),d=u;if(d.length<r.length){const a=(0,o.squeezeInputShape)(r,d),i=["batch","col","row"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=a;const u=this.getUnpackedSamplerFromInput(e,t,l),h=c.reverse(),p=`\n          ${u.routineBody}\n          float ${e}(int batch, int row, int col) {\n            return ${e}(${(0,o.getSqueezedParams)(i,h)});\n          }\n        `;return new s.GlslLibRoutine(p,u.dependencies)}const h=`\n          float ${e}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${a} + col * ${l} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;return new s.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,t,n){const r=n.unpackedShape,a=r[3],i=r[2]*a,o=`\n        float ${e}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1]*i} + col * ${i} +\n              depth2 * ${a} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(o,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,t,n){const r=n.unpackedShape,a=r[4],l=r[3]*a,u=r[2]*l,c=r[1]*u,{newShape:d,keptDims:h}=(0,i.squeezeShape)(r);if(d.length<r.length){const a=(0,o.squeezeInputShape)(r,d),i=["row","col","depth","depth2","depth3"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=a;const u=`\n          ${this.getUnpackedSamplerFromInput(e,t,l).routineBody}\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\n            return ${e}(${(0,o.getSqueezedParams)(i,h)});\n          }\n        `;return new s.GlslLibRoutine(u,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const p=`\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth3 * ${a} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(p,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,t,n){const r=n.unpackedShape,a=r[5],l=r[4]*a,u=r[3]*l,c=r[2]*u,d=r[1]*c,{newShape:h,keptDims:p}=(0,i.squeezeShape)(r);if(h.length<r.length){const a=(0,o.squeezeInputShape)(r,h),i=["row","col","depth","depth2","depth3","depth4"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=a;const u=`\n            ${this.getUnpackedSamplerFromInput(e,t,l).routineBody}\n            float ${e}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${e}(${(0,o.getSqueezedParams)(i,p)});\n            }\n          `;return new s.GlslLibRoutine(u,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const f=`\n          float ${e}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${d} + col * ${c} + depth * ${u} +\n            depth2 * ${l} + depth3 * ${a} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const e=this.context.outputTextureLayout,t=e.shape.length,n=e.strides,r=e.width,a=e.height,i=[];for(let e=0;e<t-1;++e)i.push(`\n        c[${e}] = offset / ${n[e]};`),i.push(`\n        offset -= c[${e}] * ${n[e]};`);i.push(`\n        c[${t-1}] = offset;`);const o=`\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${a});\n        ${i.join("")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${i.join("")}\n      }\n    `;return{toVec:new s.GlslLibRoutine(o,["coordinates.coordsToOffset"])}}valueFrom(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const r=this.context.inputTextureLayouts[n],a=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let i=`_${t}`;e[i]=new s.GlslLibRoutine(this.getValueFromSingle(t,a,r.width,r.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",e[i]=new s.GlslLibRoutine(this.getValueFromSingle(t,a,r.width,r.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),e}getValueFromSingle(e,t,n,r,s){let i=`_${e}`;return s&&(i+="_T"),`\n        float ${i}(int m[${t}]) {\n          int offset = indicesToOffset${i}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${(0,a.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(e,t,n,r,s){let i=`_${e}_Pack`;return s&&(i+="_T"),`\n        vec4 ${i}(int m[${t}]) {\n          int offset = indicesToOffset_${e}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${(0,a.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords);\n        }\n        `}}t.CoordsGlslLib=l},8520:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(n=t.FunctionType||(t.FunctionType={}))[n.ValueBased=0]="ValueBased",n[n.Positional=1]="Positional",t.GlslContext=class{constructor(e,t,n,r){this.glContext=e,this.programInfo=t,this.inputTextureLayouts=n,this.outputTextureLayout=r}},t.GlslLib=class{constructor(e){this.context=e}},t.GlslLibRoutine=class{constructor(e,t){this.routineBody=e,this.dependencies=t}},t.GlslLibRoutineNode=class{constructor(e,t,n){this.name=e,this.dependencies=n||[],t&&(this.routineBody=t)}addDependency(e){e&&this.dependencies.push(e)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(e){if(!e||0===e.length)return[];if(1===e.length)return e;const t=new Set,n=new Set,r=new Array;return this.createOrderedNodes(e,t,n,r),r}static createOrderedNodes(e,t,n,r){for(let s=0;s<e.length;++s)this.dfsTraverse(e[s],t,n,r)}static dfsTraverse(e,t,n,r){if(!e||n.has(e.name))return;if(t.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");t.add(e.name);const s=e.dependencies;if(s&&s.length>0)for(let e=0;e<s.length;++e)this.dfsTraverse(s[e],t,n,r);r.push(e),n.add(e.name),t.delete(e.name)}}},7341:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const r=n(8520);class s extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const e=s.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const e=s.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const e=new ArrayBuffer(4),t=new Uint32Array(e),n=new Uint8Array(e);if(t[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=s},9894:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const r=n(8520),s=n(5060);class a extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const e=(0,s.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}t.FragColorGlslLib=a},2848:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const n=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(e){const t={};let r;for(;null!==(r=n.exec(e));){const e=r[3].split(",").map((e=>{const t=e.trim().split(" ");return t&&2===t.length?{type:t[0],name:t[1]}:null})).filter((e=>null!==e));t[r[2]]={params:e,body:r[4]}}for(const n in t){const s="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",n),a=new RegExp(s,"gm");for(;null!==(r=a.exec(e));){const s=r[1],a=r[2],i=r[3].split(","),o=s?`${s} ${a};`:"";let l=t[n].body,u="";t[n].params.forEach(((e,t)=>{e&&(u+=`${e.type} ${e.name} = ${i[t]};\n`)})),l=`${u}\n ${l}`,l=l.replace("return",`${a} = `);const c=`\n      ${o}\n      {\n        ${l}\n      }\n      `;e=e.replace(r[0],c)}}return e.replace(n,"")}},8879:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const r=n(8520),s=n(2848),a=n(5483),i=n(5060);t.GlslPreprocessor=class{constructor(e,t,n,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(e,t,n,s),Object.keys(a.glslRegistry).forEach((e=>{const t=new a.glslRegistry[e](this.context);this.libs[e]=t}));const i=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const t=this.libs[e].getFunctions();for(const n in t){const s=e+"."+n;let a;i[s]?(a=i[s],a.routineBody=t[n].routineBody):(a=new r.GlslLibRoutineNode(s,t[n].routineBody),i[s]=a);const o=t[n].dependencies;if(o)for(let e=0;e<o.length;++e)if(i[o[e]])a.addDependency(i[o[e]]);else{const t=new r.GlslLibRoutineNode(o[e]);i[o[e]]=t,a.addDependency(t)}}}}preprocess(){const e=this.context.programInfo;let t=e.shaderSource;return this.context.programInfo.hasMain||(t=`${t}\n      ${(0,i.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),t=(0,s.replaceInlines)(t),`${(0,i.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames,e.variables)}\n    ${this.getImports(t)}\n    ${t}`}getImports(e){const t=this.selectGlslLibRoutinesToBeIncluded(e);if(0===t.length)return"";let n="";for(let e=0;e<t.length;++e){if(!t[e].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${t[e].name}`);n+=t[e].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(e){const t=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(".")[1];-1!==e.indexOf(r)&&t.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(t)}getUniforms(e,t){const n=[];if(e)for(const t of e)n.push(`uniform sampler2D ${t};`);if(t)for(const e of t)n.push(`uniform ${e.type} ${e.name}${e.arrayLength?`[${e.arrayLength}]`:""};`);return n.join("\n")}}},5483:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const r=n(5107),s=n(7341),a=n(9894),i=n(2655),o=n(3891);t.glslRegistry={encoding:s.EncodingGlslLib,fragcolor:a.FragColorGlslLib,vec:o.VecGlslLib,shapeUtils:i.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const r=n(8520);class s extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((n,s)=>{const a=this.context.inputTextureLayouts[s].unpackedShape;if(a.length<=e){const s=a.length,i=e-s,o=`bcastIndices_${n}`;let l="";for(let e=0;e<s;++e)l+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${i+e}]), ${a[e]}.0) );\n          `;const u=`\n        void ${o} (int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${l}\n        }\n        `;t[o]=new r.GlslLibRoutine(u)}})),t}bcastMatmulIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((n,s)=>{const a=this.context.inputTextureLayouts[s].shape;if(!(a.length<2||a.length>e)){const s=a.length,i=e-s,o=`bcastMatmulIndices_${n}`;let l="";for(let e=0;e<s-2;++e)l+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${i+e}]), ${a[e]}.0) );\n          `;const u=`\n        void ${o}(int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${l}\n          realIndices[${s-1}] = bcastedIndices[${e-1}];\n          realIndices[${s-2}] = bcastedIndices[${e-2}];\n        }\n        `;t[o]=new r.GlslLibRoutine(u)}})),t}indicesToOffset(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const a=this.context.inputTextureLayouts[n].shape,i=this.context.inputTextureLayouts[n].strides,o=a.length;let l=`indicesToOffset_${t}`;e[l]=new r.GlslLibRoutine(s.indexToOffsetSingle(l,o,i)),l=`indicesToOffset_${t}_T`,e[l]=new r.GlslLibRoutine(s.indexToOffsetSingle(l,o,i.slice().reverse()))})),e}static indexToOffsetSingle(e,t,n){let r="";for(let e=t-1;e>=0;--e)r+=`\n        offset += indices[${e}] * ${n[e]};\n        `;return`\n      int ${e}(int indices[${t}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const a=this.context.inputTextureLayouts[n].shape,i=this.context.inputTextureLayouts[n].strides,o=a.length;let l=`offsetToIndices_${t}`;e[l]=new r.GlslLibRoutine(s.offsetToIndicesSingle(l,o,i)),l=`offsetToIndices_${t}_T`,e[l]=new r.GlslLibRoutine(s.offsetToIndicesSingle(l,o,i.slice().reverse()))})),e}static offsetToIndicesSingle(e,t,n){const r=[];for(let e=0;e<t-1;++e)r.push(`\n      indices[${e}] = offset / ${n[e]};`),r.push(`\n        offset -= indices[${e}] * ${n[e]};`);return r.push(`\n      indices[${t-1}] = offset;`),`\n      void ${e}(int offset, out int indices[${t}]) {\n        ${r.join("")}\n      }\n      `}incrementIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const s=this.context.inputTextureLayouts[n].shape,a=s.length,i=`incrementIndices_${t}`;let o="";for(let e=0;e<a;++e)o+=`\n        shape[${e}] = ${s[e]};`;const l=`\n        void ${i}(int axis, out int indices[${a}]) {\n          int shape[${a}];\n          ${o};\n          for(int i = ${a} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;e[i]=new r.GlslLibRoutine(l)})),e}}t.ShapeUtilsGlslLib=s},5060:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const n={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function s(e){return 1===e?n:r}t.getGlsl=s,t.getVertexShaderSource=function(e){const t=s(e);return`${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},t.getFragShaderPreamble=function(e){const t=s(e);return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},t.getDefaultFragShaderMain=function(e,t){return`\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${s(e).output} = result;\n  }\n  `}},3891:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const r=n(8520);class s extends r.GlslLib{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const e=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const s in t){const a=`${s}Vec`;let i="";for(let n=0;n<e;++n)i+=`\n          dest[${n}] ${t[s]} src[${n}];\n          `;const o=`\n        void ${a}(int src[${e}], out int dest[${e}]) {\n          ${i}\n        }\n        `;n[a]=new r.GlslLibRoutine(o)}return n}copyVec(){const e=this.context.outputTextureLayout.shape.length;let t="";for(let n=0;n<e;++n)t+=`\n        dest[${n}] = src[${n}];\n        `;const n=`\n      void copyVec(int src[${e}], out int dest[${e}]) {\n        ${t}\n      }\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index =${e} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;t+=`\n        else\n            m[${e-1}] = value;\n        `;const n=`\n      void setVecItem(out int m[${e}], int index, int value) {\n        ${t}\n      }\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index = ${e} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;t+=`\n        else\n            return m[${e-1}];\n        `;const n=`\n      int getVecItem(int m[${e}], int index) {\n        ${t}\n      }\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}t.VecGlslLib=s},8316:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const r=n(6231),s=n(9162),a=n(2517),i=n(2403),o=n(7019),l=n(8710),u=n(5611),c=n(4057),d=n(2039);t.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,c.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let r=0;r<e.inputNames.length;++r)n[r]=this.getOrCreateTextureData(t[r],e.inputTypes[r]);const r=((e,t)=>{const n=t.map((e=>`${e.unpackedShape.join(",")};${e.width}x${e.height}`)).join("_");let r=e.name;return e.cacheHint&&(r+="["+e.cacheHint+"]"),r+=":"+n,r})(e,n);let s=this.session.programManager.getArtifact(r);const a=s?s.programInfo:"function"==typeof e.get?e.get():e,i=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,a.output.dims,a.output.textureType),o=this.createTextureData(i,a.output.type);return s||(s=this.session.programManager.build(a,n,o),this.session.programManager.setArtifact(r,s)),this.runProgram(s,n,o),o}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,n){for(let n=0;n<t.length;++n)if(!!t[n].isPacked!=(e.programInfo.inputTypes[n]===d.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(e.programInfo.output.textureType===d.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,n)}getOrCreateTextureData(e,t){let n=this.getTextureData(e.dataId,t===d.TextureType.packed);if(!n&&(n=this.getTextureData(e.dataId,t!==d.TextureType.packed),n))return t===d.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===d.TextureType.packedLastDimension){const n=1,r=4,s=e.dims;if(4===s.length){const a=[s[0],Math.ceil(s[1]*s[2]*s[3]/r)],i=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,a,t);let o=e.numberData;if(s[1]*s[2]*s[3]%r!=0){const t=s[0],a=s[1]*s[2]*s[3],i=Math.ceil(a*n/r)*r;o=new Float32Array(t*i);for(let r=0;r<t;++r){const t=r*a,s=r*i+r%n*a;o.set(e.numberData.subarray(t,t+a),s)}}return this.createTextureData(i,e.type,o,e,1)}}if(t===d.TextureType.packed){const t=(0,c.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),r=this.createTextureData(t,e.type,e.numberData,e,1);n=this.pack(r)}else n=this.createTextureData(r,e.type,e.numberData,e,1)}return n}createTextureDataFromLayoutBindTensor(e,t,n,r){return this.createTextureData(e,t,n,r,1)}createTextureData(e,t,n,s,a){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const i=this.session.textureManager.createTextureFromLayout(t,e,n,a);return this.createTextureDataFromTexture(e,t,i,s)}reshapeUnpacked(e,t){const n=this.getOrCreateTextureData(e,d.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:a.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}reshapePacked(e,t){const n=this.getOrCreateTextureData(e,d.TextureType.packed);if((0,o.isReshapeCheap)(e.dims,t)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:a.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}const r=(0,o.processDims3D)(e.dims),s=(0,o.processDims3D)(t),i=this.reshapePacked(e,r),l=this.run((0,o.createPackedReshape3DProgramInfoLoader)(this,i,s),[i]);return this.reshapePacked(l,t)}cast(e,t){const n=this.getOrCreateTextureData(e,d.TextureType.unpacked);return this.createTextureDataFromTexture(n,t,n.texture).tensor}createTextureDataFromTexture(e,t,n,r,a){const i=Object.assign(Object.assign({},e),{tensor:r||new s.Tensor(e.unpackedShape,t,(e=>this.readTexture(i)),(async e=>this.readTextureAsync(i)),void 0,a),texture:n});return this.setTextureData(i.tensor.dataId,i,e.isPacked),i}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,l.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,l.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,i.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,u.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},1640:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const i=n(2898),o=a(n(7839)),l=n(4196),u=n(2069),c=n(8138),d=n(9663),h=n(5193),p=n(7992),f=n(1253),m=n(4776),g=n(6572),b=n(3346),y=n(5623),w=n(2870),v=n(2143),x=n(4939),_=n(718),k=n(2268),S=n(8117),T=n(2278),I=n(5524),E=n(5975),A=n(3933),C=n(6558),N=n(5723),$=n(3738),O=a(n(4909)),D=n(8428),F=n(9793);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",O.abs],["Acos","","7+",O.acos],["Add","","7+",o.add],["And","","7+",o.and],["Asin","","7+",O.asin],["Atan","","7+",O.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",i.batchNormalization,i.parseBatchNormalizationAttributes],["Cast","","6+",l.cast,l.parseCastAttributes],["Ceil","","6+",O.ceil],["Clip","","6-10",O.clip,O.parseClipAttributes],["Clip","","11+",O.clipV11],["Concat","","4+",u.concat,u.parseConcatAttributes],["Conv","","1+",c.conv,c.parseConvAttributes],["ConvTranspose","","1+",d.convTranspose,d.parseConvTransposeAttributes],["Cos","","7+",O.cos],["Div","","7+",o.div],["Dropout","","7+",O.identity],["DepthToSpace","","1+",h.depthToSpace,h.parseDepthToSpaceAttributes],["Equal","","7+",o.equal],["Elu","","6+",O.elu,O.parseEluAttributes],["Exp","","6+",O.exp],["Flatten","","1+",p.flatten,p.parseFlattenAttributes],["Floor","","6+",O.floor],["FusedConv","com.microsoft","1+",c.conv,c.parseConvAttributes],["Gather","","1+",f.gather,f.parseGatherAttributes],["Gemm","","7-10",m.gemm,m.parseGemmAttributesV7],["Gemm","","11+",m.gemm,m.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",o.greater],["Identity","","1+",O.identity],["ImageScaler","","1+",g.imageScaler,g.parseImageScalerAttributes],["InstanceNormalization","","6+",b.instanceNormalization,b.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",O.leakyRelu,O.parseLeakyReluAttributes],["Less","","7+",o.less],["Log","","6+",O.log],["MatMul","","1+",y.matMul,y.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",o.mul],["Neg","","6+",O.neg],["Not","","1+",O.not],["Or","","7+",o.or],["Pad","","2-10",w.padV2,w.parsePadAttributesV2],["Pad","","11+",w.padV11,w.parsePadAttributesV11],["Pow","","7+",o.pow],["PRelu","","7+",o.pRelu],["ReduceLogSum","","1+",x.reduceLogSum,x.parseReduceAttributes],["ReduceMax","","1+",x.reduceMax,x.parseReduceAttributes],["ReduceMean","","1+",x.reduceMean,x.parseReduceAttributes],["ReduceMin","","1+",x.reduceMin,x.parseReduceAttributes],["ReduceProd","","1+",x.reduceProd,x.parseReduceAttributes],["ReduceSum","","1-12",x.reduceSum,x.parseReduceAttributes],["ReduceSumSquare","","1+",x.reduceLogSumSquare,x.parseReduceAttributes],["Relu","","6+",O.relu],["Reshape","","5+",_.reshape],["Resize","","10",k.resize,k.parseResizeAttributesV10],["Resize","","11+",k.resize,k.parseResizeAttributesV11],["Shape","","1+",S.shape],["Sigmoid","","6+",O.sigmoid],["Sin","","7+",O.sin],["Slice","","10+",T.sliceV10],["Slice","","1-9",T.slice,T.parseSliceAttributes],["Softmax","","1-12",I.softmax,I.parseSoftmaxAttributes],["Softmax","","13+",I.softmaxV13,I.parseSoftmaxAttributesV13],["Split","","2-12",E.split,E.parseSplitAttributes],["Sqrt","","6+",O.sqrt],["Squeeze","","1-12",A.squeeze,A.parseSqueezeAttributes],["Squeeze","","13+",A.squeezeV13],["Sub","","7+",o.sub],["Sum","","6+",C.sum],["Tan","","7+",O.tan],["Tanh","","6+",O.tanh],["Tile","","6+",N.tile],["Transpose","","1+",$.transpose,$.parseTransposeAttributes],["Upsample","","7-8",F.upsample,F.parseUpsampleAttributesV7],["Upsample","","9",F.upsample,F.parseUpsampleAttributesV9],["Unsqueeze","","1-12",D.unsqueeze,D.parseUnsqueezeAttributes],["Unsqueeze","","13+",D.unsqueezeV13],["Xor","","7+",o.xor]]},2898:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const r=n(246),s=n(5060),a=n(2039),i={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};t.batchNormalization=(e,t,n)=>(l(t),[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>o(e,t,n)}),t)]),t.parseBatchNormalizationAttributes=e=>{const t=e.attributes.getFloat("epsilon",1e-5),n=e.attributes.getFloat("momentum",.9),s=e.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:t,momentum:n,spatial:s})};const o=(e,t,n)=>{const r=(0,s.getGlsl)(e.session.backend.glContext.version),o=t[0].dims.length,[l,u]=e.calculateTextureWidthAndHeight(t[1].dims,a.TextureType.unpacked),c=`\n  float process(int[${o}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${l}, ${u});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},i),{output:{dims:t[0].dims,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:c})},l=e=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs.");const t=e[0],n=e[1],r=e[2],s=e[3],a=e[4];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==s.dims.length||1!==a.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1]||s.dims[0]!==t.dims[1]||a.dims[0]!==t.dims[1])throw new Error("invalid input shape.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==s.type&&"float64"!==s.type||"float32"!==a.type&&"float64"!==a.type)throw new Error("invalid input tensor types.")}},7839:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const r=n(2517),s=n(8520),a=n(5060),i=n(2039);function o(){const e="add_";return{body:`\n  float ${e}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function l(){const e="div_";return{body:`\n  float ${e}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function u(){const e="mul_";return{body:`\n  float ${e}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function c(){const e="sub_";return{body:`\n  float ${e}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function d(){const e="equal_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function h(){const e="greater_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function p(){const e="less_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function f(){const e="and_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function m(){const e="or_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function g(){const e="xor_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function b(){return function(e){const t=`${e}_`;return{body:`\n  float ${t}(float a, float b) {\n    return ${e}(a, b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return ${e}(v1, v2);\n  }\n  `,name:t,type:s.FunctionType.ValueBased}}("pow")}function y(){const e="prelu_";return{body:`\n  float ${e}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}t.glslAdd=o,t.glslDiv=l,t.glslMul=u,t.glslSub=c,t.glslEqual=d,t.glslGreater=h,t.glslLess=p,t.glslAnd=f,t.glslOr=m,t.glslXor=g,t.glslPow=b,t.glslPRelu=y;const w=(e,t,n,r=t[0].type,s)=>{const a=e.session.pack?i.TextureType.packed:i.TextureType.unpacked;return{name:n.name,inputNames:["A","B"],inputTypes:[a,a],cacheHint:s,get:()=>v(e,t,n,r)}},v=(e,t,n,s=t[0].type)=>{const o=e.session.pack?i.TextureType.packed:i.TextureType.unpacked,l=!r.ShapeUtil.areEqual(t[0].dims,t[1].dims);let u=t[0].dims;const c=e.session.pack;if(l){const i=r.BroadcastUtil.calcShape(t[0].dims,t[1].dims,!1);if(!i)throw new Error("Can't perform binary op on the given tensors");u=i;const l=u.length,d=0!==t[0].dims.length?t[0].dims.length:1,h=0!==t[1].dims.length?t[1].dims.length:1,p=0!==t[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",f=0!==t[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",m=(0,a.getGlsl)(e.session.backend.glContext.version),g=c?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${m.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${l}]) {\n        int aindices[${d}];\n        int bindices[${h}];\n        ${p}\n        ${f}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:u,type:s,textureType:o},shaderSource:g,hasMain:c}}const d=(0,a.getGlsl)(e.session.backend.glContext.version),h=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${d.texture2D}(A, TexCoords);\n      vec4 v2 = ${d.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${d.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:t[0].dims,type:s,textureType:o},shaderSource:h,hasMain:!0}};t.add=(e,t)=>[e.run(w(e,t,o()),t)],t.and=(e,t)=>[e.run(w(e,t,f(),"bool"),t)],t.div=(e,t)=>[e.run(w(e,t,l()),t)],t.equal=(e,t)=>[e.run(w(e,t,d(),"bool"),t)],t.greater=(e,t)=>[e.run(w(e,t,h(),"bool"),t)],t.less=(e,t)=>[e.run(w(e,t,p(),"bool"),t)],t.mul=(e,t)=>[e.run(w(e,t,u()),t)],t.or=(e,t)=>[e.run(w(e,t,m(),"bool"),t)],t.pow=(e,t)=>[e.run(w(e,t,b()),t)],t.pRelu=(e,t)=>[e.run(w(e,t,y()),t)],t.sub=(e,t)=>[e.run(w(e,t,c()),t)],t.xor=(e,t)=>[e.run(w(e,t,g(),"bool"),t)]},4196:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const r=n(2517);t.cast=(e,t,n)=>(s(t),[e.cast(t[0],n)]),t.parseCastAttributes=e=>r.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt("to"));const s=e=>{if(!e||1!==e.length)throw new Error("Cast requires 1 input.");if("string"===e[0].type)throw new Error("Invalid input type.")}},1163:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827);t.createPackedConcatProgramInfoLoader=(e,t,n)=>{const l=(u=t.length,c=n.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:u},((e,t)=>`X${t}`)),inputTypes:Array(u).fill(s.TextureType.packed),cacheHint:c});var u,c;return Object.assign(Object.assign({},l),{get:()=>((e,t,n,l)=>{const u=n[0].dims.slice();if(l>=u.length||l<-1*u.length)throw new Error("axis specified for concat doesn't match input dimensionality");l<0&&(l=u.length+l);const c=u.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<u.length;e++)if(e===l)c[l]+=t[e];else if(u[e]!==t[e])throw new Error("non concat dimensions must match")}const d=c.length,h=(0,i.getChannels)("coords",d),p=(0,a.getCoordsDataType)(d),f=(0,i.unpackFromChannel)(),m=n.map((e=>e.dims)),g=(0,a.getGlChannels)(d),b=new Array(m.length-1);b[0]=m[0][l];for(let e=1;e<b.length;e++)b[e]=b[e-1]+m[e][l];const y=g[l],w=g.slice(-2),v=g.join();let x=`if (${y} < ${b[0]}) {\n        return getChannel(\n            getX0(${v}), vec2(${w.join()}));\n        }`;for(let e=1;e<b.length;e++){const t=b[e-1];x+=`\n            if (${y} < ${b[e]}  && ${y} >= ${b[e-1]}) {\n              return getChannel(\n                getX${e}(${o(g,y,t)}),\n                vec2(${o(w,y,t)}));\n            }`}const _=b.length,k=b[b.length-1];x+=`\n            return getChannel(\n              getX${_}(${o(g,y,k)}),\n              vec2(${o(w,y,k)}));`;const S=(0,r.getGlsl)(e.session.backend.glContext.version),T=`\n          ${f}\n          float getValue(${g.map((e=>"int "+e))}) {\n            ${x}\n          }\n\n          void main() {\n            ${p} coords = getOutputCoords();\n            int lastDim = coords.${g[d-1]};\n            coords.${g[d-1]} = coords.${g[d-2]};\n            coords.${g[d-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${h}), 0., 0., 0.);\n\n            ${h[d-1]} = ${h[d-1]} + 1;\n            if (${h[d-1]} < ${c[d-1]}) {\n              result.g = getValue(${h});\n            }\n\n            ${h[d-2]} = ${h[d-2]} + 1;\n            if (${h[d-2]} < ${c[d-2]}) {\n              result.a = getValue(${h});\n            }\n\n            ${h[d-1]} = ${h[d-1]} - 1;\n            if (${h[d-2]} < ${c[d-2]} &&\n                ${h[d-1]} < ${c[d-1]}) {\n              result.b = getValue(${h});\n            }\n            ${S.output} = result;\n          }\n        `;return Object.assign(Object.assign({},t),{output:{dims:c,type:n[0].type,textureType:s.TextureType.packed},shaderSource:T,hasMain:!0})})(e,l,t,n.axis)})};const o=(e,t,n)=>{const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}},2069:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=n(246),s=n(2039),a=n(1163);t.concat=(e,t,n)=>(d(t),e.session.pack&&t[0].dims.length>1?[e.run((0,a.createPackedConcatProgramInfoLoader)(e,t,n),t)]:[e.run(i(e,t,n),t)]);const i=(e,t,n)=>{const r=(a=t.length,i=n.cacheKey,{name:"Concat",inputNames:Array.from({length:a},((e,t)=>`X${t}`)),inputTypes:Array(a).fill(s.TextureType.unpacked),cacheHint:i});var a,i;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const a=n[0].dims.slice();if(r>=a.length||r<-1*a.length)throw new Error("axis specified for concat doesn't match input dimensionality");r<0&&(r=a.length+r);const i=a.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<a.length;e++)if(e===r)i[r]+=t[e];else if(a[e]!==t[e])throw new Error("non concat dimensions must match")}const d=i.length,h=new Array(n.length);let p=0;for(let e=0;e<h.length;++e)p+=n[e].dims[r],h[e]=p;let f="";f=n.length<5?o(h):l(h);const m=`\n        ${u(n.length,d)}\n        ${c(h)}\n        ${f}\n        float process(int indices[${d}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},t),{output:{dims:i,type:n[0].type,textureType:s.TextureType.unpacked},shaderSource:m})})(0,r,t,n.axis)})},o=e=>`int getTextureWhereDataResides(int index) {\n      ${e.map(((e,t)=>`if(index<${e}) {return ${t};}\n`)).join("")}\n    }`,l=e=>o(e),u=(e,t)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let t=0;t<e;++t)0===t?n.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`):t===e-1?n.push(`\telse { return _X${t}(indices); }`):n.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);return n.push("\t}"),n.join("\n")},c=e=>{const t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<e.length;++n)0===n?t.push(`\tif (index == ${n}) { return ${e[n]}; }`):n===e.length-1?t.push(`\telse { return ${e[n]}; }`):t.push(`\telse if (index == ${n}) { return ${e[n]}; }`);return t.push("\t}"),t.join("\n")};t.parseConcatAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const d=e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].type,n=e[0].dims.length;if("string"===t)throw new Error("string tensor is not supported yet");for(const r of e){if(r.type!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}}},4770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(6231),s=n(5060),a=n(2039),i=n(8138),o=n(2823);t.createUnpackedGroupedConvProgramInfoLoader=(e,t,n)=>{const l=(u=t.length>2,c=n.cacheKey,{name:"GroupedConv",inputNames:u?["X","W","Bias"]:["X","W"],inputTypes:u?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:c});var u,c;return Object.assign(Object.assign({},l),{get:()=>((e,t,n,l)=>{const u=t.length>2?"value += getBias(output_channel);":"",c=t[0].dims.slice(),d=t[1].dims.slice(),h=d[0]/l.group;r.Logger.verbose("GroupedConv",`autpPad:${l.autoPad}, dilations:${l.dilations}, group:${l.group}, kernelShape:${l.kernelShape}, pads:${l.pads}, strides:${l.strides}`);const p=(0,i.calculateOutputShape)(c,d,l.dilations,l.pads,l.strides),f=(0,s.getGlsl)(e.session.backend.glContext.version),{activationFunction:m,applyActivation:g}=(0,o.getActivationSnippet)(l),b=`\n  const ivec2 strides = ivec2(${l.strides[0]}, ${l.strides[1]});\n  const ivec2 pads = ivec2(${l.pads[0]}, ${l.pads[1]});\n  ${m}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${h};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${d[1]}; wInChannel++) {\n      int input_channel = group_id * ${d[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${d[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${l.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${c[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${d[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${l.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${c[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${u}\n    ${g}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:p,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:b,hasMain:!0})})(e,t,l,n)})}},1386:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const r=n(8138),s=n(8555),a=n(708);t.conv2DPackedPointwise=(e,t,n)=>{const s=t[0].dims,i=t[1].dims,o=(0,r.calculateOutputShape)(s,i,n.dilations,n.pads,n.strides),l=e.reshapePacked(t[0],[s[1],s[2]*s[3]]),u=e.reshapePacked(t[1],[i[0],i[1]]),c=t.length>2?[u,l,t[2]]:[u,l],d=e.run((0,a.createPackedMatmulProgramInfoLoader)(e,c,n),c);return e.reshapePacked(d,o)},t.conv2DPacked=(e,t,n)=>{const i=t[0].dims,o=t[1].dims,l=(0,r.calculateOutputShape)(i,o,n.dilations,n.pads,n.strides),u=e.run((0,s.createPackedIm2ColProgramInfoLoader)(e,t[0],t[1],l,n),[t[0]]),c=e.reshapePacked(t[1],[o[0],o[1]*o[2]*o[3]]),d=3===t.length?[c,u,t[2]]:[c,u],h=e.run((0,a.createPackedMatmulProgramInfoLoader)(e,d,n),d);return e.reshapePacked(h,l)}},9663:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const r=n(246),s=n(5060),a=n(2039),i=n(2823),o=(e,t,n,r,s,a)=>(e-1)*t+n+(r-1)*s+1-a,l=(e,t,n,r,s)=>{const a=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=a,n[s]=e-a):"SAME_LOWER"===t&&(n[r]=e-a,n[s]=a)};t.convTranspose=(e,t,n)=>(h(t,n),u(e,t,n));const u=(e,t,n)=>{const r=d(n,t);return[c(e,t,r)]},c=(e,t,n)=>e.run(((e,t,n)=>{const r=(o=t.length>2,l=n.cacheKey,{name:"ConvTranspose",inputNames:o?["X","W","B"]:["X","W"],inputTypes:o?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:l});var o,l;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const o=t.length>2?"getB(output_channel)":"0.0",l=t[0].dims,u=t[1].dims,c=u[1],d=u[0]/r.group,h=[t[0].dims[0],t[1].dims[1]*r.group,...r.outputShape],p=(0,s.getGlsl)(e.session.backend.glContext.version),{activationFunction:f,applyActivation:m}=(0,i.getActivationSnippet)(r),g=`\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\n  ${f}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${c};\n    int wOutChannel = output_channel - group_id * ${c};\n\n    float value = ${o};\n    for (int inChannelOffset = 0; inChannelOffset < ${d}; inChannelOffset++) {\n      int input_channel = group_id * ${d} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${u[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${u[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${l[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${l[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${m}\n    ${p.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:h,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:g,hasMain:!0})})(e,t,r,n)})})(e,t,n),t),d=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice(),s=e.outputShape.slice();((e,t,n,r,s,a,i,u)=>{const c=e.length-2,d=0===u.length;for(let h=0;h<c;++h){const p=d?e[h+2]*a[h]:u[h],f=o(e[h+2],a[h],s[h],t[h],n[h],p);l(f,r,s,h,h+c),d&&u.push(a[h]*(e[h+2]-1)+i[h]+(t[h]-1)*n[h]+1-s[h]-s[h+c])}})(t[0].dims,n,e.dilations,e.autoPad,r,e.strides,e.outputPadding,s);const a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,outputShape:s,cacheKey:e.cacheKey}),a};t.parseConvTransposeAttributes=e=>{const t=e.attributes,n=(0,i.parseInternalActivationAttributes)(t),s=t.getString("auto_pad","NOTSET"),a=t.getInts("dilations",[1,1]),o=t.getInt("group",1),l=t.getInts("kernel_shape",[]),u=t.getInts("output_padding",[0,0]),c=t.getInts("output_shape",[]),d=t.getInts("pads",[0,0,0,0]),h=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:a,group:o,kernelShape:l,outputPadding:u,outputShape:c,pads:d,strides:h},n))};const h=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const r=n(246),s=n(2517),a=n(4770),i=n(1386),o=n(9828),l=n(2823),u=n(3248),c=n(5623);t.calculateOutputShape=(e,t,n,r,s)=>{const a=e[0],i=e.slice(2),o=i.length,l=t[0],u=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=i.map(((e,t)=>e+r[t]+r[t+o])).map(((e,t)=>Math.floor((e-u[t]+s[t])/s[t])));return[a,l].concat(...c)},t.conv=(e,t,n)=>(m(t,n),d(e,t,n));const d=(e,t,n)=>{const r=f(n,t),s=e.session.pack,o=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[e.run((0,a.createUnpackedGroupedConvProgramInfoLoader)(e,t,r),t)]:o&&s?[h(e,t,r)]:s&&4===t[0].dims.length&&1===t[0].dims[0]&&!o?[(0,i.conv2DPacked)(e,t,r)]:[p(e,t,r)]},h=(e,n,r)=>{const s=n[0].dims,a=n[1].dims,i=(0,t.calculateOutputShape)(s,a,r.dilations,r.pads,r.strides),o=e.reshapeUnpacked(n[0],[s[1],s[2]*s[3]]),l=e.reshapeUnpacked(n[1],[a[0],a[1]]),u=n.length>2?[l,o,n[2]]:[l,o],d=e.run((0,c.createMatmulProgramInfoLoader)(u,r),u);return e.reshapeUnpacked(d,i)},p=(e,n,r)=>{const s=n[0].dims,a=n[1].dims,i=(0,t.calculateOutputShape)(s,a,r.dilations,r.pads,r.strides),l=e.run((0,u.createIm2ColProgramInfoLoader)(e,n[0],n[1],i,r),[n[0]]),c=3===n.length?[l,n[1],n[2]]:[l,n[1]];return e.run((0,o.createDotProductProgramInfoLoader)(e,n,i,r),c)},f=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice();s.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.autoPad);const a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),a};t.parseConvAttributes=e=>{const t=e.attributes,n=(0,l.parseInternalActivationAttributes)(t),s=t.getString("auto_pad","NOTSET"),a=t.getInts("dilations",[1,1]),i=t.getInt("group",1),o=t.getInts("kernel_shape",[]),u=t.getInts("pads",[0,0,0,0]),c=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:a,group:i,kernelShape:o,pads:u,strides:c},n))};const m=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("Conv input(bias) should be float tensor")}},5193:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const r=n(3738);t.depthToSpace=(e,t,n)=>{s(t);const a=n.blocksize,i=a*a,o="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],l="DCR"===n.mode?[t[0].dims[0],a,a,t[0].dims[1]/i,t[0].dims[2],t[0].dims[3]]:[t[0].dims[0],t[0].dims[1]/i,a,a,t[0].dims[2],t[0].dims[3]],u=e.reshapeUnpacked(t[0],l),c={perm:o,cacheKey:`${o}`},[d]=(0,r.transpose)(e,[u],c),h=[t[0].dims[0],t[0].dims[1]/i,t[0].dims[2]*a,t[0].dims[3]*a];return[e.reshapeUnpacked(d,h)]},t.parseDepthToSpaceAttributes=e=>{const t=e.attributes.getInt("blocksize");if(t<1)throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);const n=e.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:t}};const s=e=>{if(1!==e.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if("string"===e[0].type||4!==e[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const r=n(2517),s=n(5060),a=n(2039),i=n(2823),o=n(3248);t.createDotProductProgramInfoLoader=(e,t,n,l)=>{const u=((e,t)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[a.TextureType.unpacked,a.TextureType.packedLastDimension,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.packedLastDimension],cacheKey:t.activationCacheKey}))(t.length>2,l);return Object.assign(Object.assign({},u),{get:()=>((e,t,n,l,u)=>{const c=n[0].dims,d=n[1].dims,h=[d[0],Math.ceil(c[1]*d[2]*d[3]/4)],p=(0,o.calculateIm2ColDims)(c,d,l),[f,m]=e.calculateTextureWidthAndHeight(h,a.TextureType.packedLastDimension),g=r.ShapeUtil.computeStrides(p),[b,y]=e.calculateTextureWidthAndHeight(p,a.TextureType.packedLastDimension),w=l.length,v=n.length<3?"0.0":"_B(b)",x=Math.ceil(c[1]*d[2]*d[3]/4),{activationFunction:_,applyActivation:k}=(0,i.getActivationSnippet)(u),S=(0,s.getGlsl)(e.session.backend.glContext.version),T=`\n${_}\nfloat process(int indices[${w}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${g[0]} + im2col[1] * ${g[1]} + im2col[2] * ${g[2]};\n  int kernelOffset = indices[1] * ${h[1]};\n  float value = ${v};\n  for (int i = 0; i < ${x}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${f}, ${m});\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${k}\n  return value;\n}`;return Object.assign(Object.assign({},t),{output:{dims:l,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:T})})(e,u,t,n,l)})}},7992:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const r=n(2517);t.flatten=(e,t,n)=>{s(t,n);const a=r.ShapeUtil.flattenShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],a)]},t.parseFlattenAttributes=e=>e.attributes.getInt("axis",1);const s=(e,t)=>{if(!e||1!==e.length)throw new Error("Flatten requires 1 input.");const n=e[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(t<-n||t>n)throw new Error("Invalid axis");if("string"===e[0].type)throw new Error("string tensor is not supported.")}},2823:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const r=n(2517),s=n(4909);t.getActivationSnippet=function(e){let t;switch(e.activation){case"Relu":t=(0,s.glslRelu)();break;case"Sigmoid":t=(0,s.glslSigmoid)();break;case"Clip":t=(0,s.glslClip)(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=t.name;return{activationFunction:t.body,applyActivation:`value = ${n}_(value);`}},t.parseInternalActivationAttributes=e=>{const t=e.getString("activation","");if("Clip"===t){const[n,s]=e.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:t,clipMax:s,clipMin:n,activationCacheKey:`${t}:${n},${s}`}}return{activation:t,activationCacheKey:t}}},1253:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const r=n(246),s=n(782),a=n(2517),i=n(2039);t.gather=(e,t,n)=>(u(t,n.axis),[e.run(l(e,t,n),t)]),t.parseGatherAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",0)});const o={name:"Gather",inputNames:["A","B"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked]},l=(e,t,n)=>{const r=Object.assign(Object.assign({},o),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const s=n[0].dims.slice(),o=n[1].dims.slice(),l=new Array(s.length+o.length-1);r=a.ShapeUtil.normalizeAxis(r,s.length);const u=[];for(let e=0;e<l.length;e++)e<r?(l[e]=s[e],u.push(`inputIdx[${e}] = outputIdx[${e}];`)):e<r+o.length?(l[e]=o[e-r],u.push(`indexDataIdx[${e-r}] = outputIdx[${e}];`)):(l[e]=s[e-o.length+1],u.push(`inputIdx[${e-o.length+1}] = outputIdx[${e}];`));const c=`\n      float process(int outputIdx[${l.length||1}]) {\n        int inputIdx[${s.length}];\n        int indexDataIdx[${o.length||1}];\n        indexDataIdx[0] = 0;\n        ${u.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${s[r]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:l,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:c})})(0,r,t,n.axis)})},u=(e,t)=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.");const n=e[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(t<-n||t>n-1)throw new Error("Invalid axis.");if(-1===s.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invaid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invaid input type.")}},4776:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const r=n(246),s=n(2517),a=n(2039);t.gemm=(e,t,n)=>(u(t,n),[e.run(o(t,n),t)]);const i=(e,t)=>{const n=0!==e.attributes.getInt("transA",0),s=0!==e.attributes.getInt("transB",0),a=e.attributes.getFloat("alpha",1),i=e.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:s,alpha:a,beta:i,isOptionalC:t})};t.parseGemmAttributesV7=e=>i(e,!1),t.parseGemmAttributesV11=e=>i(e,!0);const o=(e,t)=>{const n={name:"Gemm",inputNames:3===e.length?["A","B","C"]:["A","B"],inputTypes:3===e.length?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],key:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>l(n,e,t)})},l=(e,t,n)=>{const r=t[0].dims.slice(),i=t[1].dims.slice(),[o,l]=s.GemmUtil.getShapeOfGemmResult(r,n.transA,i,n.transB,3===t.length?t[2].dims:void 0),u=[o,l];if(!u)throw new Error("Can't use gemm on the given tensors");let c=r[r.length-1],d="";n.transA&&(c=r[0]),n.transA&&n.transB?d="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?d="value += _A_T(a) * _B(b);":!n.transA&&n.transB?d="value += _A(a) * _B_T(b);":n.transA||n.transB||(d="value += _A(a) * _B(b);");const h=u.length,p=`\n      float process(int indices[${h}]) {\n          int a[${h}];\n          int b[${h}];\n          ${3===t.length?`int c[${t[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===t.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${c}; ++k) {\n              a[${h-1}] = k;\n              b[${h-2}] = k;\n              ${d}\n          }\n\n          value = value * alpha;\n          ${3===t.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:u,type:t[0].type,textureType:a.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:p})},u=(e,t)=>{if(!e)throw new Error("Input is missing");if(t.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!t.isOptionalC&&3!==e.length)throw new Error("Gemm requires 3 inputs");if(3===e.length&&1!==e[2].dims.length&&2!==e[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type||3===e.length&&"float32"!==e[2].type&&"float64"!==e[2].type)throw new Error("Invalid input type.");if(e[0].type!==e[1].type||3===e.length&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}},8555:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const r=n(5060),s=n(2039),a=n(2827);t.createPackedIm2ColProgramInfoLoader=(e,t,n,i,o)=>{const l=(u=o.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[s.TextureType.packed],cacheHint:u});var u;return Object.assign(Object.assign({},l),{get:()=>((e,t,n,i,o,l)=>{const u=n.dims,c=i.dims,d=o.length,h=[c[1]*c[2]*c[3],o[2]*o[3]],p=c[2]*c[3],f=(0,a.unpackFromChannel)(),m=(0,r.getGlsl)(e.session.backend.glContext.version);let g="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)g+=`\n            blockIndex = rc.x + ${t};\n            pos = rc.y + ${e};\n\n            if(blockIndex < ${h[1]} && pos < ${h[0]}) {\n              offsetY = int(blockIndex / (${o[d-1]})) * ${l.strides[0]} -\n                ${l.pads[0]};\n              d0 = offsetY + ${l.dilations[0]} * (imod(pos, ${p}) / ${c[2]});\n\n              if(d0 < ${u[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${o[d-1]}) * ${l.strides[1]} -\n                  ${l.pads[1]};\n                d1 = offsetX + ${l.dilations[1]} * imod(imod(pos, ${p}), ${c[2]});\n\n                if(d1 < ${u[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${p}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*e+t}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const b=`\n      ${f}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${g}\n          ${m.output} = result;\n      }\n            `;return Object.assign(Object.assign({},t),{output:{dims:h,type:n.type,textureType:s.TextureType.packed},shaderSource:b,hasMain:!0})})(e,l,t,n,i,o)})}},3248:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const r=n(2039);t.createIm2ColProgramInfoLoader=(e,n,s,a,i)=>{const o=(l=i.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:l});var l;return Object.assign(Object.assign({},o),{get:()=>((e,n,s,a,i,o)=>{const l=s.dims,u=a.dims,c=i.length,d=(0,t.calculateIm2ColDims)(l,u,i,4),h=`\n        const int XC = ${l[1]};\n        const int XH = ${l[2]};\n        const int XW = ${l[3]};\n        const int KH = ${o.kernelShape[0]};\n        const int KW = ${o.kernelShape[1]};\n        const int dilationH = ${o.dilations[0]};\n        const int dilationW = ${o.dilations[1]};\n        const int strideH = ${o.strides[0]};\n        const int strideW = ${o.strides[1]};\n        const int padH = ${o.pads[0]};\n        const int padW = ${o.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${c}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${l.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},n),{output:{dims:d,type:s.type,textureType:r.TextureType.packedLastDimension},shaderSource:h})})(0,o,n,s,a,i)})},t.calculateIm2ColDims=(e,t,n,r=4)=>[n[0],n[2],n[3],Math.ceil(e[1]*t[2]*t[3]/r)]},6572:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const r=n(246),s=n(2039);t.imageScaler=(e,t,n)=>(l(t),[e.run(i(e,t,n),t)]),t.parseImageScalerAttributes=e=>{const t=e.attributes.getFloat("scale"),n=e.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:t,bias:n})};const a={name:"ImageScaler",inputNames:["X"],inputTypes:[s.TextureType.unpacked]},i=(e,t,n)=>{const r=Object.assign(Object.assign({},a),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const a=n[0].dims.slice(),i=a.length,l=`\n      ${o(r.bias.length)}\n      float process(int indices[${i}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:n[0].type,textureType:s.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:r.bias.length,data:r.bias},{name:"scale",type:"float",data:r.scale}],shaderSource:l})})(0,r,t,n)})},o=e=>{const t=[`float getBias(float bias[${e}], int channel) {`];for(let n=0;n<e;++n)0===n?t.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===e-1?t.push(`\telse { return bias[${n}]; }`):t.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return t.push("\t}"),t.join("\n")},l=e=>{if(!e||1!==e.length)throw new Error("ImageScaler requires 1 input.");if(4!==e[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")}},3346:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const r=n(5060),s=n(2039);t.instanceNormalization=(e,t,n)=>{u(t);const r=e.run(i(t[0]),t);return[e.run(l(e,t[0],n,r.dims),[t[0],r,t[1],t[2]])]},t.parseInstanceNormalizationAttributes=e=>e.attributes.getFloat("epsilon",1e-5);const a={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[s.TextureType.unpacked]},i=e=>Object.assign(Object.assign({},a),{get:()=>((e,t)=>{const n=t.dims.slice(),r=n[1],a=n[2]*n[3],i=[n[0],r],o=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${a});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${a});\n\n        return v;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:i,type:t.type,textureType:s.TextureType.packedLastDimension},shaderSource:o})})(a,e)}),o={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[s.TextureType.unpacked,s.TextureType.packedLastDimension,s.TextureType.unpacked,s.TextureType.unpacked]},l=(e,t,n,a)=>{const i=Object.assign(Object.assign({},o),{cacheHint:`${n}`});return Object.assign(Object.assign({},i),{get:()=>((e,t,n,a,i)=>{const o=(0,r.getGlsl)(e.session.backend.glContext.version),[l,u]=e.calculateTextureWidthAndHeight(i,s.TextureType.packedLastDimension),[c,d]=[l/4,u],h=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${c}, ${d});\n        return ${o.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:s.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:a}],shaderSource:h})})(e,i,t,n,a)})},u=e=>{if(!e||3!==e.length)throw new Error("InstanceNormalization requires 3 inputs.");const t=e[0],n=e[1],r=e[2];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type)throw new Error("Invalid input type.");if(4!==e[0].dims.length)throw new Error("Only support 4-D input shape.")}},708:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const r=n(2517),s=n(5060),a=n(2039),i=n(9390),o=n(2823),l=n(5623);t.createPackedMatmulProgramInfoLoader=(e,t,n)=>{const u=(c=t.length>2,d=n.activationCacheKey,{name:"MatMul (packed)",inputNames:c?["A","B","Bias"]:["A","B"],inputTypes:c?[a.TextureType.packed,a.TextureType.packed,a.TextureType.packed]:[a.TextureType.packed,a.TextureType.packed],cacheHint:d});var c,d;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const c=n.length>2,d=c?"value += getBiasForMatmul();":"",h=n[0].dims,p=n[1].dims,f=r.BroadcastUtil.calcShape(h,p,!0),m=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!f)throw new Error("Can't use matmul on the given tensors");const g=h[h.length-1],b=Math.ceil(g/2),y=h.length,w=p.length,v=(0,s.getGlsl)(e.session.backend.glContext.version),x=(0,i.getCoordsDataType)(f.length),_=f.length,k=(0,i.getGlChannels)(),{activationFunction:S,applyActivation:T}=(0,o.getActivationSnippet)(u),I=c?`${(0,l.getBiasForMatmul)(x,k,n[2].dims,f,!0)}`:"",E=m?`${function(e,t,n,s){let a=[],i=[];const o=n[0].dims,l=n[1].dims,u=o.length,c=l.length,d=s.length,h=d-u,p=d-c;a=o.map(((e,n)=>`coords.${t[n+h]}`)),a[u-1]="i*2",a.join(", "),i=l.map(((e,n)=>`coords.${t[n+p]}`)),i[c-2]="i*2",i.join(", ");const f=r.BroadcastUtil.getBroadcastDims(o,s),m=r.BroadcastUtil.getBroadcastDims(l,s),g=f.map((e=>`coords.${t[e+h]} = 0;`)).join("\n"),b=m.map((e=>`coords.${t[e+p]} = 0;`)).join("\n"),y=`int lastDim = coords.${t[d-1]};\n  coords.${t[d-1]} = coords.${t[d-2]};\n  coords.${t[d-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${g}\n  vec4 outputValue = getA(${a});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getB(${i});\n  return outputValue;\n}`}(x,k,n,f)}`:"",A=m?"getAAtOutCoordsMatmul(i)":`getA(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`rc.${e[t-2]}, i*2`,n}(k,y)})`,C=m?"getBAtOutCoordsMatmul(i)":`getB(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`i*2, rc.${e[t-1]}`,n}(k,w)})`,N=`\n            ${E}\n            ${I}\n            ${S}\n            void main() {\n              ${m?"":`${x} rc =\n          getOutputCoords(); int lastDim = rc.${k[_-1]}; rc.${k[_-1]} =\n          rc.${k[_-2]}; rc.${k[_-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${b}; i++) {\n                vec4 a = ${A};\n                vec4 b = ${C};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${d}\n              ${T}\n              ${v.output} = value;\n            }`;return Object.assign(Object.assign({},t),{output:{dims:f,type:n[0].type,textureType:a.TextureType.packed},shaderSource:N,hasMain:!0})})(e,u,t,n)})}},5623:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const r=n(2517),s=n(2039),a=n(9390),i=n(2823),o=n(708);function l(e,t){const n=(o=e.length>2,l=t.activationCacheKey,{name:"MatMul",inputNames:o?["A","B","Bias"]:["A","B"],inputTypes:o?[s.TextureType.unpacked,s.TextureType.unpacked,s.TextureType.unpacked]:[s.TextureType.unpacked,s.TextureType.unpacked],cacheHint:l});var o,l;return Object.assign(Object.assign({},n),{get:()=>function(e,t,n){const o=t[0].dims,l=t[1].dims,u=r.BroadcastUtil.calcShape(o,l,!0);if(!u)throw new Error("Can't use matmul on the given tensors");const d=(0,a.getCoordsDataType)(u.length),h=(0,a.getGlChannels)(),{activationFunction:p,applyActivation:f}=(0,i.getActivationSnippet)(n),m=t.length>2,g=m?"value += getBiasForMatmul();":"",b=m?`${c(d,h,t[2].dims,u,!1)}`:"",y=u.length,w=o.length,v=l.length,x=`\n    ${p}\n    ${b}\n    float process(int indices[${y}]) {\n        int a[${w}];\n        int b[${v}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${o[o.length-1]}; ++k) {\n            a[${w-1}] = k;\n            b[${v-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${g}\n        ${f}\n        return value;\n    }`;return Object.assign(Object.assign({},e),{output:{dims:u,type:t[0].type,textureType:s.TextureType.unpacked},shaderSource:x})}(n,e,t)})}t.matMul=(e,t,n)=>(u(t),e.session.pack?[e.run((0,o.createPackedMatmulProgramInfoLoader)(e,t,n),t)]:[e.run(l(t,n),t)]),t.parseMatMulAttributes=e=>(0,i.parseInternalActivationAttributes)(e.attributes),t.createMatmulProgramInfoLoader=l;const u=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type)throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function c(e,t,n,s,a){let i="";const o=n.length,l=s.length,u=l-o;i=l<2&&o>0?"coords":n.map(((e,n)=>`coords.${t[n+u]}`)).join(", ");const c=r.BroadcastUtil.getBroadcastDims(n,s).map((e=>`coords.${t[e+u]} = 0;`)).join("\n");let d="vec4(outputValue.xx, outputValue.yy)";return 1===r.ShapeUtil.size(n)&&(d="vec4(outputValue.x)"),a?`\nvec4 getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  vec4 outputValue = getBias(${i});\n  return ${d};\n}`:`\nfloat getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  return getBias(coords.x);\n}`}t.getBiasForMatmul=c},2403:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827),o={name:"pack",inputNames:["A"],inputTypes:[s.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(e,t)=>Object.assign(Object.assign({},o),{get:()=>((e,t)=>{const n=(0,r.getGlsl)(e.session.backend.glContext.version),l=t.dims,u=l.length,c=t.dims.length,d=(0,a.getCoordsDataType)(c),h=(0,i.getChannels)("rc",c),p=(f=c,m=h,g=l[l.length-2],b=l[l.length-1],0===f||1===f?"":`\n    int r = ${m[f-2]};\n    int c = ${m[f-1]};\n    int rp1 = ${m[f-2]} + 1;\n    int cp1 = ${m[f-1]} + 1;\n    bool rEdge = rp1 >= ${b};\n    bool cEdge = cp1 >= ${g};\n    `);var f,m,g,b;let y;y=0===u?[1,1]:1===u?[l[0],1]:[l[c-1],l[c-2]];const w=function(e,t,n){if(0===e)return"false";if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s-e+2]}`,s<e-1&&(r+="||");return r}(c,y,h),v=function(e,t){const n=e.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;let r="";if(n>2)for(let e=0;e<n-2;++e)r+=`${t[e]},`;return`getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(l,h),x=`\n        void main() {\n          ${d} rc = getOutputCoords();\n\n          if(${w}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${p}\n\n            ${n.output} = vec4(${v});\n          }\n        }\n      `;return Object.assign(Object.assign({},o),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:s.TextureType.packed},shaderSource:x})})(e,t)})},2827:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const r=n(9390);function s(e,t){return(0,r.getGlChannels)(t).map((t=>`${e}.${t}`))}t.getVecChannels=s,t.getChannels=function(e,t){return 1===t?[e]:s(e,t)},t.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},2870:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const r=n(246),s=n(2517),a=n(5060),i=n(2039),o={name:"Pad",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.padV2=(e,t,n)=>(c(t),[e.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),t)]),t.parsePadAttributesV2=e=>{const t=e.attributes.getString("mode","constant"),n=e.attributes.getFloat("value",0),s=e.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:t,value:n,pads:s})},t.padV11=(e,n,r)=>{d(n);const s=l(e,n,r);return(0,t.padV2)(e,[n[0]],s)},t.parsePadAttributesV11=e=>e.attributes.getString("mode","constant");const l=(e,t,n)=>{if(!e.session.isInitializer(t[1].dataId)||t.length>=3&&!e.session.isInitializer(t[2].dataId))throw new Error("dynamic pad attributes are not allowed");const s=Array.from(t[1].integerData),a=t.length>=3?t[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:s,value:a})},u=(e,t,n)=>{const r=s.ShapeUtil.padShape(t.dims.slice(),n.pads),a=r.length,o=`\n      ${h(e,t,n)}\n      float process(int[${a}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[i.TextureType.unpacked],output:{dims:r,type:t.type,textureType:i.TextureType.unpacked},shaderSource:o}},c=e=>{if(!e||1!==e.length)throw new Error("Pad requires 1 input");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},d=e=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==e[1].type)throw new Error("Invalid input type.");if(e.length>=3&&"string"===e[2].type)throw new Error("Invalid input type.")},h=(e,t,n)=>{const r=(0,a.getGlsl)(e.session.backend.glContext.version),[o,l]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),u=s.ShapeUtil.computeStrides(t.dims);switch(n.mode){case"constant":return p(r,t.dims,u,o,l,n.pads,n.value);case"reflect":return f(r,t.dims,u,o,l,n.pads);case"edge":return m(r,t.dims,u,o,l,n.pads);default:throw new Error("Invalid mode")}},p=(e,t,n,r,s,a,i)=>{const o=t.length;let l="";for(let e=o-1;e>=0;--e)l+=`\n        k = m[${e}] - ${a[e]};\n        if (k < 0)  return constant;\n        if (k >= ${t[e]}) return constant;\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${o}]) {\n        const float constant = float(${i});\n        int offset = 0;\n        int k = 0;\n        ${l}\n        vec2 coords = offsetToCoords(offset, ${r}, ${s});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},f=(e,t,n,r,s,a)=>{const i=t.length;let o="";for(let e=i-1;e>=0;--e)o+=`\n        k = m[${e}] - ${a[e]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(t[e]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[e]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${i}]) {\n        int offset = 0;\n        int k = 0;\n        ${o}\n        vec2 coords = offsetToCoords(offset, ${r}, ${s});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},m=(e,t,n,r,s,a)=>{const i=t.length;let o="";for(let e=i-1;e>=0;--e)o+=`\n        k = m[${e}] - ${a[e]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[e]}) k = ${t[e]-1};\n        offset += k * ${n[e]};\n      `;return`\n      float padA(int m[${i}]) {\n        int offset = 0;\n        int k = 0;\n        ${o}\n        vec2 coords = offsetToCoords(offset, ${r}, ${s});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `}},2143:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const r=n(246),s=n(2517),a=n(2039);t.averagePool=(e,t,n)=>{d(t);const r={name:"AveragePool",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>i(t,r,!1,n)}),t)]},t.parseAveragePoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),s=0!==e.attributes.getInt("count_include_pad",0),a=e.attributes.getInts("kernel_shape"),i=e.attributes.getInts("strides",[]),o=e.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:s,kernelShape:a,strides:i,pads:o})};const i=(e,t,n,r)=>{const[i,o]=l(e,r,n),u=s.ShapeUtil.size(i.kernelShape);let c="";i.countIncludePad?c+=`value /= float(${u});`:c+=`value /= float(${u} - pad);`;const d=`\n        ${h(e[0].dims,i,"value += _X(x);",c,"0.0")}\n      `;return Object.assign(Object.assign({},t),{output:{dims:o,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:d})};t.globalAveragePool=(e,t,n)=>{d(t);const r={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[e.run(Object.assign(Object.assign({},r),{get:()=>i(t,r,!0,n)}),t)]},t.parseGlobalAveragePoolAttributes=e=>{const t=0!==e.attributes.getInt("count_include_pad",0);return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:t,kernelShape:[],strides:[],pads:[]})},t.maxPool=(e,t,n)=>{d(t);const r={name:"MaxPool",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>o(t,r,!1,n)}),t)]},t.parseMaxPoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInts("kernel_shape"),a=e.attributes.getInts("strides",[]),i=e.attributes.getInts("pads",[]),o=e.attributes.getInt("storage_order",0),l=e.attributes.getInts("dilations",[]);if(0!==o)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:!1,kernelShape:s,strides:a,pads:i,storageOrder:o,dilations:l})};const o=(e,t,n,r)=>{const[s,i]=l(e,r,n),o=`\n      ${h(e[0].dims,s,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},t),{output:{dims:i,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:o})},l=(e,t,n)=>{const r=e[0].dims.slice(),a=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),o=t.strides.slice(),l=a?t.dilations.slice():[],u=t.pads.slice();s.PoolConvUtil.adjustPoolAttributes(n,r,i,o,l,u);const c=s.PoolConvUtil.computePoolOutputShape(n,r,o,l,i,u,t.autoPad),d=Object.assign({},t);return a?Object.assign(d,{kernelShape:i,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(d,{kernelShape:i,strides:o,pads:u,cacheKey:t.cacheKey}),[d,c]},u={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},c={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[a.TextureType.unpacked]};t.globalMaxPool=(e,t)=>(d(t),[e.run(Object.assign(Object.assign({},c),{get:()=>o(t,c,!0,u)}),t)]);const d=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},h=(e,t,n,r,a)=>{const i=e.length;if(t.kernelShape.length<=2){const s=t.kernelShape[t.kernelShape.length-1],o=t.strides[t.strides.length-1],l=t.pads[t.pads.length/2-1],u=t.pads[t.pads.length-1],c=e[i-1];let d="",h="",p="";if(d=l+u!==0?`\n          for (int i = 0; i < ${s}; i++) {\n            x[${i} - 1] = indices[${i} - 1] * ${o} - ${l} + i;\n            if (x[${i} - 1] < 0 || x[${i} - 1] >= ${c}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${s}; i++) {\n            x[${i} - 1] = indices[${i} - 1] * ${o} - ${l} + i;\n            ${n}\n          }`,2===t.kernelShape.length){const n=t.kernelShape[t.kernelShape.length-2],r=t.strides[t.strides.length-2],a=t.pads[t.pads.length/2-2],o=t.pads[t.pads.length-2],l=e[i-2];h=a+o!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${i} - 2] = indices[${i} - 2] * ${r} - ${a} + j;\n              if (x[${i} - 2] < 0 || x[${i} - 2] >= ${l}) {\n                pad+= ${s};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${i} - 2] = indices[${i} - 2] * ${r} - ${a} + j;\n            `,p="\n          }\n        "}return`\n        float process(int indices[${i}]) {\n          int x[${i}];\n          copyVec(indices, x);\n\n          float value = ${a};\n          int pad = 0;\n          ${h}\n          ${d}\n          ${p}\n          ${r}\n          return value;\n        }\n      `}{const o=s.ShapeUtil.size(t.kernelShape),l=s.ShapeUtil.computeStrides(t.kernelShape),u=l.length,c=t.pads.length,d=f(u),h=p(e,"inputDims"),m=p(t.pads,"pads"),g=p(l,"kernelStrides"),b=p(t.strides,"strides");let y="";return y=t.pads.reduce(((e,t)=>e+t))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `,`\n        ${d}\n        float process(int indices[${i}]) {\n          int x[${i}];\n          copyVec(indices, x);\n          int offset[${u}];\n          int pads[${c}];\n          int inputDims[${i}];\n          int kernelStrides[${u}];\n          int strides[${u}];\n          ${m}\n          ${h}\n          ${b}\n          ${g}\n\n          float value = ${a};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${o}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${i} - ${u}; j < ${i}; j++) {\n              x[j] = indices[j] * strides[j - ${i} + ${u}]\n                + offset[j - ${i} + ${u}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `}},p=(e,t)=>{let n="";for(let r=0;r<e.length;r++)n+=`\n      ${t}[${r}] = ${e[r]};\n    `;return n},f=e=>`\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\n    if (${e} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${e} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${e} - 1] = offset;\n  }`},4939:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const r=n(246),s=n(782),a=n(2517),i=n(2039),o=(e,t,n,r,s)=>{u(t);const a={name:r,inputNames:["A"],inputTypes:[i.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>l(e,t,n,r,s,a)}),t)]};t.parseReduceAttributes=e=>{const t=e.attributes.getInts("axes",[]),n=1===e.attributes.getInt("keepdims",1);return(0,r.createAttributeWithCacheKey)({axes:t,keepDims:n})};const l=(e,t,n,r,s,o)=>{const l=[],u=t[0].dims.length||1,c=[],d=a.ShapeUtil.normalizeAxes(n.axes,t[0].dims.length),h=s(t,d);let p=h[1];for(let e=0;e<t[0].dims.length;e++)d.indexOf(e)>=0||0===d.length?(n.keepDims&&l.push(1),p=`\n          for(int j${e} = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\n            inputIdx[${e}] = j${e};\n            ${p}\n          }`):(c.push(`inputIdx[${e}] = outputIdx[${l.length}];`),l.push(t[0].dims[e]));const f=`\n      float process(int outputIdx[${l.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${u}];      // addressing input data\n        ${c.join("\n")}\n        ${h[0]}       // init ops for reduce max/min\n        ${p}\n        ${h[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},o),{output:{dims:l,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:f})},u=e=>{if(!e||1!==e.length)throw new Error("Reduce op requires 1 input.");if(-1===s.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.reduceSum=(e,t,n)=>o(e,t,n,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),t.reduceMean=(e,t,n)=>o(e,t,n,"ReduceMean",((e,t)=>{let n=1;for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&(n*=e[0].dims[r]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]})),t.reduceMax=(e,t,n)=>o(e,t,n,"ReduceMax",((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),t.reduceMin=(e,t,n)=>o(e,t,n,"ReduceMin",((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),t.reduceProd=(e,t,n)=>o(e,t,n,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),t.reduceLogSum=(e,t,n)=>o(e,t,n,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),t.reduceLogSumSquare=(e,t,n)=>o(e,t,n,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7019:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const r=n(2517),s=n(5060),a=n(2039),i=n(2827);t.createPackedReshape3DProgramInfoLoader=(e,t,n)=>{const o=(e=>({name:"Reshape (packed)",inputTypes:[a.TextureType.packed],inputNames:["A"],cacheHint:`${e}`}))(n);return Object.assign(Object.assign({},o),{get:()=>((e,t,n,o)=>{const l=t.dims,u=o;let c="";for(let e=0;e<4;e++){let t="";switch(e){case 0:t="outputCoords = rc;";break;case 1:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:t="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}c+=`\n        ${t}\n        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${e>0?"}":""}\n      `}const d=(0,s.getGlsl)(e.session.backend.glContext.version),h=`\n      ${function(e){const t=r.ShapeUtil.computeStrides(e),n=["b","r","c"],s="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map(((e,r)=>`int ${n[r]} = ${s} / ${e}; ${r===t.length-1?`int ${n[r+1]} = ${s} - ${n[r]} * ${e}`:`index -= ${n[r]} * ${e}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(l)}\n      ${function(e){const t=r.ShapeUtil.computeStrides(e);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`}(u)}\n      ${(0,i.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${u[2]};\n        int cols = ${u[1]};\n\n        ${c}\n        ${d.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:u,type:t.type,textureType:a.TextureType.packed},shaderSource:h,hasMain:!0})})(e,t,o,n)})},t.processDims3D=function(e){if(0===e.length)return[1,1,1];let t=1;for(let n=0;n<e.length-2;++n)t*=e[n];return[t,e.length>1?e[e.length-2]:1,e[e.length-1]]},t.isReshapeCheap=function(e,t){let n=!1;return n=0===e.length||0===t.length||(e.length<2||t.length<2?e[e.length-1]===t[t.length-1]:e[e.length-1]===t[t.length-1]&&e[e.length-2]===t[t.length-2]),n}},718:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const r=n(2517);t.reshape=(e,t)=>{const n=r.ShapeUtil.calculateReshapedDims(t[0].dims,t[1].integerData);return e.session.pack?[e.reshapePacked(t[0],n)]:[e.reshapeUnpacked(t[0],n)]}},2268:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827),o=n(9793),l={name:"Resize",inputNames:["A"],inputTypes:[s.TextureType.packed]};t.resize=(e,t,n)=>((0,o.validateInputs)(t,n),[e.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>u(e,t,n)}),t)]),t.parseResizeAttributesV10=e=>(0,o.parseUpsampleAttributes)(e,10),t.parseResizeAttributesV11=e=>(0,o.parseUpsampleAttributes)(e,11);const u=(e,t,n)=>{const o=(0,r.getGlsl)(e.session.backend.glContext.version),[u,d]=c(t,n);if(u.every((e=>1===e))&&"tf_crop_and_resize"!==n.coordinateTransformMode)return Object.assign(Object.assign({},l),{output:{dims:d,type:t[0].type,textureType:s.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${o.texture2D}(X, TexCoords);\n                    ${o.output} = v;\n                }`});const h=d.length;if(h<2)throw new Error(`output dimension should be at least 2, but got ${h}`);const p=d[h-2],f=d[h-1],m=t[0].dims;if(h!==m.length)throw new Error(`output dimension should match input ${m.length}, but got ${h}`);const g=m[h-2],b=m[h-1],y=u[h-2],w=u[h-1];let v="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":v="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":v="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":v=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${f}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${p}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${f}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${p}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":v=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${f}.0 - 1.0, ${p}.0 - 1.0, ${f}.0 - 1.0,\n                            ${p}.0 - 1.0);\n                        vec4 original = vec4(${b}.0 - 1.0, ${g}.0 - 1.0, ${b}.0 - 1.0,\n                            ${g}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const x=(0,a.getCoordsDataType)(h),_=`\n            const vec2 inputWH = vec2(${g}.0, ${b}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${w}), float(${y}), float(${w}));\n            ${(0,i.unpackFromChannel)()}\n            ${v}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${x} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${p-1};\n                bool hasNextCol = rc.z < ${f-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${o.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},l),{output:{dims:d,type:t[0].type,textureType:s.TextureType.packed},hasMain:!0,shaderSource:_})},c=(e,t)=>{const n=e[0].dims;let r,s=t.scales;if(0===s.length){const a=e[t.scalesInputIdx];if(a&&0!==a.size){if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=d(a,t.mode,t.isResize)}else{const a=e[t.sizesInputIdx];if(!a||0===a.size)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(a.integerData),s=h(r,n,t.mode,t.isResize)}}else if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const a=r||n.map(((e,t)=>Math.floor(e*s[t])));return[s,a]},d=(e,t,n)=>{const r=Array.from(e.floatData);return(0,o.scalesValidation)(r,t,n),r},h=(e,t,n,r)=>{const s=t.length,a=new Array(s);for(let n=0,r=s;n<r;n++)if(0===t[n]){if(0!==e[n])throw new Error("Input dim is zero but required output dim is non-zero.");a[n]=1}else a[n]=e[n]/t[n];return(0,o.scalesValidation)(a,n,r),a}},8117:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const r=n(9162);t.shape=(e,t)=>(s(t),[new r.Tensor([t[0].dims.length],"int32",void 0,void 0,new Int32Array(t[0].dims))]);const s=e=>{if(!e||1!==e.length)throw new Error("Shape requires 1 input.")}},2278:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const r=n(246),s=n(782),a=n(2517),i=n(2039),o={name:"Slice",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.slice=(e,t,n)=>(u(t),[e.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>l(e,t[0],n)}),t)]),t.parseSliceAttributes=e=>{const t=e.attributes.getInts("starts"),n=e.attributes.getInts("ends"),s=e.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:t,ends:n,axes:s})};const l=(e,t,n)=>{const r=0===n.axes.length?t.dims.slice(0).map(((e,t)=>t)):n.axes,s=a.ShapeUtil.normalizeAxes(r,t.dims.length),l=n.starts.map(((e,n)=>e>t.dims[s[n]]-1?t.dims[s[n]]:a.ShapeUtil.normalizeAxis(e,t.dims[s[n]]))),u=n.ends.map(((e,n)=>e>t.dims[s[n]]-1?t.dims[s[n]]:a.ShapeUtil.normalizeAxis(e,t.dims[s[n]]))),c=t.dims.slice(),d=[];for(let e=0;e<s.length;e++)c[s[e]]=u[e]-l[e],l[e]>0&&d.push(`outputIdx[${s[e]}] += ${l[e]};`);const h=`\n      float process(int outputIdx[${c.length}]) {\n        ${d.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},o),{output:{dims:c,type:t.type,textureType:i.TextureType.unpacked},shaderSource:h})},u=e=>{if(!e||1!==e.length)throw new Error("Slice requires 1 input.");if(-1===s.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.sliceV10=(e,t)=>{d(t);const n=c(e,t);return[e.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>l(e,t[0],n)}),[t[0]])]};const c=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some((e=>1!==e)))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(t[1].integerData),r=Array.from(t[2].integerData),s=t.length>=4?Array.from(t[3].integerData):[];return{starts:n,ends:r,axes:s,cacheKey:`${s};${n};${r}`}},d=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if("int32"!==e[1].type||1!==e[1].dims.length)throw new Error("Invalid input type.");if("int32"!==e[2].type||1!==e[2].dims.length)throw new Error("Invalid input type.");if(e.length>=4&&("int32"!==e[3].type||1!==e[3].dims.length))throw new Error("Invalid input type.");if(e.length>=5&&("int32"!==e[4].type||1!==e[4].dims.length))throw new Error("Invalid input type.")}},5524:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const r=n(246),s=n(2517),a=n(5060),i=n(2039),o=n(3738),l={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[i.TextureType.unpacked]},u={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked]},c={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]};t.softmax=(e,t,n)=>{m(t);const r=t[0].dims.slice(),a=s.ShapeUtil.normalizeAxis(n.axis,r.length),i=s.ShapeUtil.sizeToDimension(r,a),o=s.ShapeUtil.sizeFromDimension(r,a);return d(e,t,n,i,o)},t.parseSoftmaxAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",-1)}),t.softmaxV13=(e,t,n)=>{m(t);const a=t[0].dims.slice(),i=s.ShapeUtil.normalizeAxis(n.axis,a.length),l=a.length,u=i!==l-1,c=[];let h,p=[],f=[];u&&(p=Array.from({length:l}).map(((e,t)=>t)),p[i]=l-1,p[l-1]=i,p.map((e=>c.push(a[e]))),h=(0,r.createAttributeWithCacheKey)({perm:p}),f=(0,o.transpose)(e,t,h));const g=u?s.ShapeUtil.sizeToDimension(c,l-1):s.ShapeUtil.sizeToDimension(a,l-1),b=u?s.ShapeUtil.sizeFromDimension(c,l-1):s.ShapeUtil.sizeFromDimension(a,l-1),y=d(e,u?f:t,n,g,b);return u?(0,o.transpose)(e,y,h):y};const d=(e,t,n,r,s)=>{const a=h(e,t[0],r,s,[r]),i=e.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>a}),t),o=p(e,t[0],r,s,a.output.dims,[r]),d=e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>o}),[t[0],i]),m=f(e,t[0],r,s,a.output.dims,o.output.dims);return[e.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>m}),[t[0],i,d])]},h=(e,t,n,r,s)=>{const[o,u]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),c=s.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const d=(0,a.getGlsl)(e.session.backend.glContext.version),h=`\n      float process(int[${c}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${d.texture2D}(A, offsetToCoords(logical_row_start_offset, ${o},\n        ${u} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${d.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${o}, ${u})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},l),{output:{dims:s,type:t.type,textureType:i.TextureType.unpacked},shaderSource:h})},p=(e,t,n,r,s,o)=>{const[l,c]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),d=o.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==o.length)throw new Error("Dimensionality of the output should be 1");if(o[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==s.length)throw new Error("Dimensionality of the intermediate results should be 1");if(s[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const h=`\n      float process(int[${d}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,a.getGlsl)(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${l}, ${c}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},u),{output:{dims:o,type:t.type,textureType:i.TextureType.unpacked},shaderSource:h})},f=(e,t,n,r,s,a)=>{const[o,l]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),u=t.dims.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length||1!==a.length)throw new Error("Dimensionality of the intermediate results should be 1");if(s[0]!==n||a[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const d=`\n      float process(int[${u}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${o}, ${l});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},c),{output:{dims:t.dims,type:t.type,textureType:i.TextureType.unpacked},shaderSource:d})},m=e=>{if(!e||1!==e.length)throw new Error("Softmax requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type")}},5975:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=n(246),s=n(2517),a=n(2039),i={name:"Split",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.split=(e,t,n)=>{u(t);const r=s.ShapeUtil.normalizeAxis(n.axis,t[0].dims.length),a=o(e,t,r,n),c=[];for(let s=0;s<a;++s)c.push(e.run(Object.assign(Object.assign({},i),{cacheHint:`${n.cacheKey};${s}`,get:()=>l(e,t[0],n,r,s)}),t));return c},t.parseSplitAttributes=e=>{const t=e.attributes.getInt("axis",0),n=e.attributes.getInts("split",[]),s=e.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:t,split:n,numOutputs:s})};const o=(e,t,n,r)=>{const[,a]=s.SplitUtil.splitShape(t[0].dims,n,r.split,r.numOutputs);return a.length},l=(e,t,n,r,o)=>{const[l,u]=s.SplitUtil.splitShape(t.dims,r,n.split,n.numOutputs),c=u[o],d=l[o],h=`\n      float process(int indices[${d.length}]) {\n        indices[${r}] += ${c};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},i),{cacheHint:`${n.cacheKey}:${o}`,output:{dims:d,type:t.type,textureType:a.TextureType.unpacked},shaderSource:h})},u=e=>{if(!e||1!==e.length)throw new Error("Split requires one input.");if("int8"!==e[0].type&&"uint8"!==e[0].type&&"int16"!==e[0].type&&"uint16"!==e[0].type&&"int32"!==e[0].type&&"uint32"!==e[0].type&&"float32"!==e[0].type&&"float64"!==e[0].type&&"bool"!==e[0].type)throw new Error("Invalid input type.")}},3933:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const r=n(2517);t.squeeze=(e,t,n)=>{s(t);const a=r.ShapeUtil.squeezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],a)]},t.squeezeV13=(e,n)=>(a(n),(0,t.squeeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseSqueezeAttributes=e=>e.attributes.getInts("axes");const s=e=>{if(!e||1!==e.length)throw new Error("Squeeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},a=e=>{if(!e||2!==e.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},6558:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const r=n(5060),s=n(2039);t.sum=(e,t)=>{i(t);const n={name:"Sum",inputNames:t.map(((e,t)=>`X${t}`)),inputTypes:new Array(t.length).fill(s.TextureType.unpacked)};return[e.run(Object.assign(Object.assign({},n),{get:()=>a(e,t,n)}),t)]};const a=(e,t,n)=>{const a=(0,r.getGlsl)(e.session.backend.glContext.version),i=t[0].dims.slice(),o=`\n      void main() {\n        vec4 result = ${t.map(((e,t)=>`${a.texture2D}(X${t},TexCoords)`)).join(" + ")};\n        ${a.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:i,type:t[0].type,textureType:s.TextureType.unpacked},hasMain:!0,shaderSource:o})},i=e=>{if(!e||0===e.length)throw new Error("Sum requires inputs.");const t=e[0].dims.length;for(let n=1;n<e.length;n++){if(t!==e[n].dims.length)throw new Error("Input shapes are mismatched.");for(let r=0;r<t;r++)if(e[0].dims[r]!==e[n].dims[r])throw new Error("Input shapes are not matched.")}if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.");for(let t=1;t<e.length;t++)if(e[0].type!==e[t].type)throw new Error("Input types are not matched.")}},5723:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const r=n(782),s=n(2039);t.tile=(e,t)=>{i(t);const n={name:"Tile",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},n),{get:()=>a(e,t,n)}),t)]};const a=(e,t,n)=>{const r=t[0].dims.slice(),a=new Array(r.length),i=[];for(let e=0;e<r.length;e++)a[e]=r[e]*t[1].numberData[e],i.push(`inputIdx[${e}] = int(mod(float(outputIdx[${e}]), ${r[e]}.));`);const o=a.length,l=`\n      float process(int outputIdx[${o}]) {\n        int inputIdx[${o}];\n        ${i.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:t[0].type,textureType:s.TextureType.unpacked},shaderSource:l})},i=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 input.");if(1!==e[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(-1===r.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invalid repeat type.")}},3738:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const r=n(246),s=n(2517),a=n(2039),i={name:"Transpose",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.transpose=(e,t,n)=>(d(t),[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>o(e,t[0],n.perm)}),t)]),t.parseTransposeAttributes=e=>(0,r.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const o=(e,t,n)=>{const r=t.dims;n=l(r,n);const s=u(r,n),o=r.length,d=`\n      ${c("perm",n,o)}\n      float process(int indices[${o}]) {\n        int a[${o}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},i),{output:{dims:s,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},l=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),u=(e,t)=>(t=l(e,t),s.ShapeUtil.sortBasedOnPerm(e,t)),c=(e,t,n)=>{const r=[];r.push(`void ${e}(out int a[${n}], int src[${n}]) {`);for(let e=0;e<n;++e)r.push(`\ta[${t[e]}]=src[${e}];`);return r.push("\t}"),r.join("\n")},d=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("input should be float tensor")}},8710:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const r=n(5060),s=n(2039);t.encodeAsUint8=(e,t)=>{const n=t.shape,a=(0,r.getGlsl)(e.session.backend.glContext.version),i=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${a.texture2D}(X,TexCoords).r;\n      ${a.output} = encodeAsUint8(value);\n    }`,o={name:"Uint8Encode",inputTypes:[s.TextureType.unpacked],inputNames:["X"],output:{dims:n,type:t.tensor.type,textureType:s.TextureType.downloadUint8AsFloat},shaderSource:i,hasMain:!0};return e.executeProgram(o,[t.tensor])}},4909:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const r=n(246),s=n(2517),a=n(8520),i=n(5060),o=n(2039);function l(){return C("abs")}function u(){return C("acos")}function c(){return C("asin")}function d(){return C("atan")}function h(){return C("ceil")}function p(){return C("cos")}function f(e){const t="elu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:a.FunctionType.ValueBased}}function m(){return C("exp")}function g(){return C("floor")}function b(e,t){const n="clip";return{body:`\n  const float min = float(${e});\n  const float max = float(${t});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:a.FunctionType.ValueBased}}function y(){const e="indentity";return{body:`\n  float ${e}_(float a) {\n    return a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return v;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function w(e){const t="leakyRelu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:a.FunctionType.ValueBased}}function v(){return C("log")}function x(){const e="neg";return{body:`\n  float ${e}_(float a) {\n    return -a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return -v;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function _(){const e="not";return{body:`\n  float ${e}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${e}_(bool a) {\n    return !a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${e}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function k(){return C("sin")}function S(){const e="relu";return{body:`\n  float ${e}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${e}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function T(){const e="sigmoid";return{body:`\n  float ${e}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${e}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function I(){return C("sqrt")}function E(){return C("tan")}function A(){const e="tanh";return{body:`\n  float ${e}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${e}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function C(e){return{body:`\n  float ${e}_(float a) {\n    return ${e}(a);\n  }\n  vec4 ${e}_(vec4 v) {\n    return ${e}(v);\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}t.glslAbs=l,t.glslAcos=u,t.glslAsin=c,t.glslAtan=d,t.glslCeil=h,t.glslCos=p,t.glslElu=f,t.glslExp=m,t.glslFloor=g,t.glslClip=b,t.glslIdentity=y,t.glslLeakyRelu=w,t.glslLog=v,t.glslNeg=x,t.glslNot=_,t.glslSin=k,t.glslRelu=S,t.glslSigmoid=T,t.glslSqrt=I,t.glslTan=E,t.glslTanh=A;const N=(e,t,n,r)=>{const s=e.session.pack?o.TextureType.packed:o.TextureType.unpacked,a={name:n.name,inputTypes:[s],inputNames:["A"],cacheHint:r};return Object.assign(Object.assign({},a),{get:()=>((e,t,n,r)=>{const s=e.session.pack?o.TextureType.packed:o.TextureType.unpacked,a=(0,i.getGlsl)(e.session.backend.glContext.version);return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:s},shaderSource:`\n     ${r.body}\n     void main() {\n       vec4 v = ${a.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${a.output} = v;\n     }\n     `,hasMain:!0})})(e,a,t,n)})};t.abs=(e,t)=>[e.run(N(e,t[0],l()),t)],t.acos=(e,t)=>[e.run(N(e,t[0],u()),t)],t.asin=(e,t)=>[e.run(N(e,t[0],c()),t)],t.atan=(e,t)=>[e.run(N(e,t[0],d()),t)],t.clip=(e,t,n)=>[e.run(N(e,t[0],b(n.min,n.max),n.cacheKey),t)],t.parseClipAttributes=e=>(0,r.createAttributeWithCacheKey)({min:e.attributes.getFloat("min",s.MIN_CLIP),max:e.attributes.getFloat("max",s.MAX_CLIP)}),t.clipV11=(e,n)=>{const r=$(e,n);return(0,t.clip)(e,[n[0]],r)};const $=(e,t)=>{if(t.length>=3&&(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=t.length>=3?t[1].numberData[0]:s.MIN_CLIP,a=t.length>=3?t[2].numberData[0]:s.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:a})};t.ceil=(e,t)=>[e.run(N(e,t[0],h()),t)],t.cos=(e,t)=>[e.run(N(e,t[0],p()),t)],t.elu=(e,t,n)=>[e.run(N(e,t[0],f(n.alpha),n.cacheKey),t)],t.parseEluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",1)}),t.exp=(e,t)=>[e.run(N(e,t[0],m()),t)],t.floor=(e,t)=>[e.run(N(e,t[0],g()),t)],t.identity=(e,t)=>[e.run(N(e,t[0],y()),t)],t.leakyRelu=(e,t,n)=>[e.run(N(e,t[0],w(n.alpha),n.cacheKey),t)],t.parseLeakyReluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",.01)}),t.log=(e,t)=>[e.run(N(e,t[0],v()),t)],t.neg=(e,t)=>[e.run(N(e,t[0],x()),t)],t.not=(e,t)=>[e.run(N(e,t[0],_()),t)],t.relu=(e,t)=>[e.run(N(e,t[0],S()),t)],t.sigmoid=(e,t)=>[e.run(N(e,t[0],T()),t)],t.sin=(e,t)=>[e.run(N(e,t[0],k()),t)],t.sqrt=(e,t)=>[e.run(N(e,t[0],I()),t)],t.tan=(e,t)=>[e.run(N(e,t[0],E()),t)],t.tanh=(e,t)=>[e.run(N(e,t[0],A()),t)]},5611:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827),o={name:"unpack",inputNames:["A"],inputTypes:[s.TextureType.packed]};t.createUnpackProgramInfo=(e,t)=>{const n=t.dims.length,l=(0,i.getChannels)("rc",n),u=l.slice(-2),c=(0,a.getCoordsDataType)(n),d=(0,i.unpackFromChannel)(),h=0===t.dims.length?"":function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(n,l),p=n<=1?"rc":`vec2(${u.join(",")})`,f=`\n    ${d}\n    void main() {\n      ${c} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${h});\n\n       ${(0,r.getGlsl)(e.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${p}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},o),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:s.TextureType.unpacked},shaderSource:f})},t.createUnpackProgramInfoLoader=(e,n)=>Object.assign(Object.assign({},o),{get:()=>(0,t.createUnpackProgramInfo)(e,n)})},8428:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const r=n(2517);t.unsqueeze=(e,t,n)=>{s(t);const a=r.ShapeUtil.unsqueezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],a)]},t.unsqueezeV13=(e,n)=>(a(n),(0,t.unsqueeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseUnsqueezeAttributes=e=>e.attributes.getInts("axes");const s=e=>{if(!e||1!==e.length)throw new Error("Unsqueeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},a=e=>{if(!e||2!==e.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},9793:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const r=n(246),s=n(5060),a=n(2039),i={name:"Upsample",inputNames:["X"],inputTypes:[a.TextureType.unpacked]};t.upsample=(e,n,r)=>((0,t.validateInputs)(n,r),[e.run(Object.assign(Object.assign({},i),{cacheHint:r.cacheKey,get:()=>o(e,n,r)}),n)]),t.parseUpsampleAttributesV7=e=>(0,t.parseUpsampleAttributes)(e,7),t.parseUpsampleAttributesV9=e=>(0,t.parseUpsampleAttributes)(e,9),t.parseUpsampleAttributes=(e,n)=>{const s=n>=10,a=e.attributes.getString("mode","nearest");if("nearest"!==a&&"linear"!==a&&(n<11||"cubic"!==a))throw new Error(`unrecognized mode: ${a}`);let i=[];n<9&&(i=e.attributes.getFloats("scales"),(0,t.scalesValidation)(i,a,s));const o=e.attributes.getFloat("extrapolation_value",0),l=n>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(l))throw new Error(`coordinate_transform_mode '${l}' is not supported`);const u="tf_crop_and_resize"===l,c=u,d="nearest"===a&&n>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(d))throw new Error(`nearest_mode '${d}' is not supported`);const h=e.attributes.getFloat("cubic_coeff_a",-.75),p=0!==e.attributes.getInt("exclude_outside",0);if(p&&"cubic"!==a)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const f=n<11||"nearest"===a&&"asymmetric"===l&&"floor"===d;let m=0,g=0,b=0;return n>10?e.inputs.length>2?(m=1,g=2,b=3):(g=1,b=2):9===n&&(g=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:s,mode:a,scales:i,extrapolationValue:o,coordinateTransformMode:l,useExtrapolation:c,needRoiInput:u,nearestMode:d,cubicCoefficientA:h,excludeOutside:p,useNearest2xOptimization:f,roiInputIdx:m,scalesInputIdx:g,sizesInputIdx:b})};const o=(e,t,n)=>{const r=(0,s.getGlsl)(e.session.backend.glContext.version),[o,l]=e.calculateTextureWidthAndHeight(t[0].dims,a.TextureType.unpacked),u=t[0].dims.map(((e,t)=>Math.floor(e*n.scales[t]))),[c,d]=e.calculateTextureWidthAndHeight(u,a.TextureType.unpacked),h=u.length,p=new Array(h),f=new Array(h);let m=`\n      int output_pitches[${h}];\n      int input_pitches[${h}];\n      `;for(let e=h-1;e>=0;e--)p[e]=e===h-1?1:p[e+1]*u[e+1],f[e]=e===h-1?1:f[e+1]*t[0].dims[e+1],m+=`\n        output_pitches[${e}] = ${p[e]};\n        input_pitches[${e}] = ${f[e]};\n        `;const g=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${o}, ${l});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `,b="nearest"===n.mode?`\n    ${g}\n    float process(int indices[${h}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${d});\n\n      ${m}\n\n      int d, m;\n      for (int dim = 0; dim < ${h}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===h?`\n    ${g}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${d});\n\n      ${m}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${g}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${d});\n\n      ${m}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},i),{output:{dims:u,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:b,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map((e=>Math.ceil(e)))}]})};t.validateInputs=(e,t)=>{if(!e||t.opset<9&&1!==e.length||t.opset>=9&&t.opset<11&&2!==e.length||t.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(t.scales.length>0&&e[0].dims.length!==t.scales.length)throw new Error("Invalid input shape.");if("string"===e[0].type)throw new Error("Invalid input tensor types.")},t.scalesValidation=(e,t,n)=>{if(n){for(const t of e)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(const t of e)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==t&&"cubic"!==t||2===e.length||4===e.length&&1===e[0]&&1===e[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}},1958:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(1670),s=n(6231),a=n(8879),i=n(5060);t.ProgramManager=class{constructor(e,t,n){this.profiler=e,this.glContext=t,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n){var r;this.profiler.event("op",`ProgramManager.run ${null!==(r=e.programInfo.name)&&void 0!==r?r:"unknown kernel"}`,(()=>{var r;const a=this.glContext.gl,i=e.program;a.useProgram(i);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,null!==(r=e.programInfo.variables)&&void 0!==r?r:[],t)}catch(t){throw s.Logger.error("ProgramManager",e.programInfo.shaderSource),t}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((e=>this.glContext.deleteProgram(e.program)))}build(e,t,n){return this.profiler.event("backend","ProgramManager.build",(()=>{const r=new a.GlslPreprocessor(this.glContext,e,t,n),s=r.preprocess(),i=this.compile(s);return{programInfo:e,program:i,uniformLocations:this.getUniformLocations(i,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(i)}}))}compile(e){if(!this.vertexShader){s.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const e=(0,i.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(e,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&s.Logger.verbose("ProrgramManager",`FragShader:\n${e}\n`);const t=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,t);return this.glContext.deleteShader(t),n}bindOutput(e){const t=e.width,n=e.height;s.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${t}/${n}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,t,n)}bindAttributes(e){const t=e.position,n=e.textureCoord;this.glContext.setVertexAttributes(t,n),this.attributesBound=!0}bindUniforms(e,t,n){var r;const s=this.glContext.gl;let a=0;for(const{name:i,type:o,location:l,arrayLength:u}of e){const e=null===(r=t.find((e=>e.name===i)))||void 0===r?void 0:r.data;if("sampler2D"!==o&&!e)throw new Error(`variable '${i}' does not have data defined in program info`);switch(o){case"sampler2D":this.bindTexture(n[a],l,a),a++;break;case"float":u?s.uniform1fv(l,e):s.uniform1f(l,e);break;case"int":u?s.uniform1iv(l,e):s.uniform1i(l,e);break;default:throw new Error(`Uniform not implemented: ${o}`)}}}bindTexture(e,t,n){this.glContext.bindTextureToUniform(e.texture,n,t)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,t,n){const r=[];if(t)for(const n of t)r.push({name:n,type:"sampler2D",location:this.getUniformLocation(e,n)});if(n)for(const t of n)r.push(Object.assign(Object.assign({},t),{location:this.getUniformLocation(e,t.name)}));return r}getUniformLocation(e,t){const n=this.glContext.gl.getUniformLocation(e,t);if(null===n)throw new Error(`Uniform ${t} not found.`);return n}getAttribLocation(e,t){return this.glContext.gl.getAttribLocation(e,t)}}},6416:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const r=n(6231),s=n(1047),a=n(8316),i=n(1640),o=n(1958),l=n(7859),u=n(5702);t.WebGLSessionHandler=class{constructor(e,t){this.backend=e,this.context=t,this.layoutStrategy=new l.PreferLogicalStrategy(e.glContext.maxTextureSize),this.programManager=new o.ProgramManager(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new u.TextureManager(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===e.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new a.WebGLInferenceHandler(this)}onGraphInitialized(e){const t=e.getValues().filter((e=>-1===e.from&&e.tensor)).map((e=>e.tensor.dataId));this.initializers=new Set(t)}isInitializer(e){return!!this.initializers&&this.initializers.has(e)}addInitializer(e){this.initializers.add(e)}getTextureData(e,t){return t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(e,t):this.unpackedTextureDataCache.set(e,t)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.unpackedTextureDataCache=new Map}resolve(e,t,n){const r=(0,s.resolveOperator)(e,t,i.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(e,n):e}}}},7769:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const r=n(6231);t.RedFloat32DataEncoder=class{constructor(e,t=1){if(1===t)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=t}}encode(e,t){let n,s;return e.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(e)),t*this.channelSize>e.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),s=e,n=this.allocate(t*this.channelSize),s.forEach(((e,t)=>n[t]=e))):(s=e,n=s),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.RGBAFloatDataEncoder=class{constructor(e,t=1,n){if(1!==t&&4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=t,this.textureType=n||e.FLOAT}encode(e,t){let n=e;return 1===this.channelSize&&(r.Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(t),e.forEach(((e,t)=>n[4*t]=e))),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.Uint8DataEncoder=class{constructor(e,t=1){if(this.channelSize=4,1===t)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t}}encode(e,t){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,t){if(e instanceof Uint8Array)return e.subarray(0,t);throw new Error(`Invalid array type: ${e.constructor}`)}}},7859:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(6231),s=n(2517);function a(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:i(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[o]||a[o]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function i(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),(0,s.assert)(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),(0,s.assert)(e.every(o),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function o(e){return e%1==0}function l(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function u(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){if(0===e.length)return[1,1];const n=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const s=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),a=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(s>n||a>n))return[s,a];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}const s=e.reduce(((e,t)=>e*t));let a=Math.floor(Math.sqrt(s));for(;a<n&&a<s&&s%a!=0;a++);if(a>=n||s%a!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${e}`);return[a,s/a]}},t.PreferLogicalStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){const n=this.computeTexture(e,t);return t&&t.isPacked&&(n[0]/=2,n[1]/=2),t&&t.reverseWH?[n[1],n[0]]:n}computeTexture(e,t){const n=t&&t.isPacked;if(0===e.length)return n?[2,2]:[1,1];let s=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const n=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),a=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(n>s||a>s))return[n,a];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}let i=e.slice(0);if(n&&(s*=2,i=i.map(((e,t)=>t>=i.length-2?i[t]%2==0?i[t]:i[t]+1:i[t])),1===i.length&&(i=[2,i[0]])),2!==i.length){const e=a(i);i=e.newShape}const o=l(i);return i.length<=1&&o<=s?[1,o]:2===i.length&&i[0]<=s&&i[1]<=s?i:3===i.length&&i[0]*i[1]<=s&&i[2]<=s?[i[0]*i[1],i[2]]:3===i.length&&i[0]<=s&&i[1]*i[2]<=s?[i[0],i[1]*i[2]]:4===i.length&&i[0]*i[1]*i[2]<=s&&i[3]<=s?[i[0]*i[1]*i[2],i[3]]:4===i.length&&i[0]<=s&&i[1]*i[2]*i[3]<=s?[i[0],i[1]*i[2]*i[3]]:n?u(o/4).map((e=>2*e)):u(o)}},t.squeezeShape=a,t.parseAxisParam=i,t.isInt=o,t.sizeFromShape=l,t.getRowsCols=function(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]},t.sizeToSquarishShape=u,t.getBatchDim=function(e,t=2){return l(e.slice(0,e.length-t))}},4057:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const r=n(2517),s=n(2039);t.createTextureLayoutFromTextureType=(e,n,r)=>{const a=r===s.TextureType.unpacked||r===s.TextureType.unpackedReversed?1:4,i=r===s.TextureType.packed,o=r===s.TextureType.unpackedReversed||r===s.TextureType.packed,l=r===s.TextureType.packedLastDimension?n.length-1:void 0,u=r===s.TextureType.packedLastDimension?n.map(((e,t)=>t===n.length-1?4*e:e)):void 0;return(0,t.createTextureLayoutFromShape)(e,n,a,u,{isPacked:i,reverseWH:o,breakAxis:l})},t.calculateTextureWidthAndHeight=(e,n,r)=>{const s=(0,t.createTextureLayoutFromTextureType)(e,n,r);return[s.width,s.height]},t.createTextureLayoutFromShape=(e,t,n=1,s,a)=>{const i=!(!a||!a.isPacked),[o,l]=e.computeTextureWH(i&&s||t,a),u=t.length;let c=t.slice(0);if(0===u&&(c=[1]),1===n)s=t;else if(i){if(4!==n)throw new Error("a packed texture must be 4-channel");s=t,u>0&&(c[u-1]=Math.ceil(c[u-1]/2)),u>1&&(c[u-2]=Math.ceil(c[u-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:o,height:l,channels:n,isPacked:i,shape:c,strides:r.ShapeUtil.computeStrides(c),unpackedShape:s,reversedWH:a&&a.reverseWH}}},5702:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const r=n(6231);t.TextureManager=class{constructor(e,t,n,r){this.glContext=e,this.layoutStrategy=t,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,t,n,s){const a=this.toEncoderType(e),i=this.glContext.getEncoder(a,t.channels||1,s);if(t.isPacked&&1===s)throw new Error("not implemented");const o=t.width,l=t.height;let u,c;if(this.config.reuseTextures){u=`${o}x${l}_${i.format}_${i.internalFormat}_${i.textureType}`,c=this.inUseTextures.get(u),c||(c=[],this.inUseTextures.set(u,c));const t=this.idleTextures.get(u);if(t&&t.length>0){const r=t.pop();return c.push(r),1===s&&this.glContext.updateTexture(r,o,l,i,this.toTextureData(e,n)),r}}r.Logger.verbose("TextureManager",`Creating new texture of size ${t.width}x${t.height}`);const d=this.glContext.allocateTexture(o,l,i,this.toTextureData(e,n));return this.config.reuseTextures&&(c.push(d),this.textureLookup.set(d,u)),d}readTexture(e,t,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const r=e.shape.reduce(((e,t)=>e*t))*n,s=this.glContext.readTexture(e.texture,e.width,e.height,r,this.toEncoderType(t),n);return this.toTensorData(t,s)}))}async readTextureAsync(e,t,n){const r=e.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const e=this.pendingRead.get(r);return new Promise((t=>null==e?void 0:e.push(t)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(r,[]);const s=e.shape.reduce(((e,t)=>e*t))*n;await this.glContext.createAndWaitForFence();const a=this.glContext.readTexture(e.texture,e.width,e.height,s,this.toEncoderType(t),n),i=this.toTensorData(t,a),o=this.pendingRead.get(r);return this.pendingRead.delete(r),null==o||o.forEach((e=>e(i))),i}))}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const t=e.shape.reduce(((e,t)=>e*t)),n=this.glContext.readTexture(e.texture,e.width,e.height,4*t,"byte",4);return new Float32Array(n.buffer,n.byteOffset,t)}))}releaseTexture(e,t){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(e.texture),n)){t&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const t=r.indexOf(e.texture);if(-1!==t){r.splice(t,1);let s=this.idleTextures.get(n);s||(s=[],this.idleTextures.set(n,s)),s.push(e.texture)}}}n&&!t||(r.Logger.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,t){switch(e){case"int16":return t instanceof Int16Array?t:Int16Array.from(t);case"int32":return t instanceof Int32Array?t:Int32Array.from(t);case"int8":return t instanceof Int8Array?t:Int8Array.from(t);case"uint16":return t instanceof Uint16Array?t:Uint16Array.from(t);case"uint32":return t instanceof Uint32Array?t:Uint32Array.from(t);case"uint8":case"bool":return t instanceof Uint8Array?t:Uint8Array.from(t);case"float32":return t instanceof Float32Array?t:Float32Array.from(t);case"float64":return t instanceof Float64Array?t:Float64Array.from(t);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,t){if(t)return t instanceof Float32Array?t:new Float32Array(t)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(n=t.TextureType||(t.TextureType={}))[n.unpacked=0]="unpacked",n[n.unpackedReversed=1]="unpackedReversed",n[n.packed=2]="packed",n[n.downloadUint8AsFloat=3]="downloadUint8AsFloat",n[n.packedLastDimension=4]="packedLastDimension"},9390:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const r=n(2517);t.getPackedShape=function(e){const t=e.length;return e.slice(0,t-1).concat(e[t-1]/4)},t.repeatedTry=async function(e,t=(e=>0),n){return new Promise(((r,s)=>{let a=0;const i=()=>{if(e())return void r();a++;const o=t(a);null!=n&&a>=n?s():setTimeout(i,o)};i()}))},t.generateShaderFuncNameFromInputSamplerName=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(e,t){let n=JSON.parse(JSON.stringify(e));return n=t,n},t.getSqueezedParams=function(e,t){return t.map((t=>e[t])).join(", ")},t.getCoordsDataType=function(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)},t.getGlChannels=function(e=6){return["x","y","z","w","u","v"].slice(0,e)}},7305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const r=n(6231),s=n(1713),a={};function i(e){const t=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const e=document.createElement("canvas");return e.width=1,e.height=1,e}();let n;const a={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!e||"webgl2"===e)&&(n=t.getContext("webgl2",a),n))try{return new s.WebGLContext(n,2)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`)}if((!e||"webgl"===e)&&(n=t.getContext("webgl",a)||t.getContext("experimental-webgl",a),n))try{return new s.WebGLContext(n,1)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function e(t){let n;t&&"webgl2"!==t||!("webgl2"in a)?t&&"webgl"!==t||!("webgl"in a)||(n=a.webgl):n=a.webgl2,n=n||i(t),t=t||1===n.version?"webgl":"webgl2";const r=n.gl;return a[t]=n,r.isContextLost()?(delete a[t],e(t)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},t.createNewWebGLContext=i},1713:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const i=n(1670),o=a(n(7769)),l=n(9390);function u(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}t.linearSearchLastTrue=u,t.WebGLContext=class{constructor(e,t){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=t,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,t,n,r){const s=this.gl,a=s.createTexture();s.bindTexture(s.TEXTURE_2D,a),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE);const i=r?n.encode(r,e*t):null;return s.texImage2D(s.TEXTURE_2D,0,n.internalFormat,e,t,0,n.format,n.textureType,i),this.checkError(),a}updateTexture(e,t,n,r,s){const a=this.gl;a.bindTexture(a.TEXTURE_2D,e);const i=r.encode(s,t*n);a.texSubImage2D(a.TEXTURE_2D,0,0,0,t,n,r.format,r.textureType,i),this.checkError()}attachFramebuffer(e,t,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,e),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0),this.checkError(),r.viewport(0,0,t,n),r.scissor(0,0,t,n)}readTexture(e,t,n,r,s,a){const i=this.gl;a||(a=1),this.frameBufferBound||this.attachFramebuffer(e,t,n);const o=this.getEncoder(s,a),l=o.allocate(t*n);return i.bindTexture(i.TEXTURE_2D,e),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0),i.readPixels(0,0,t,n,i.RGBA,o.textureType,l),this.checkError(),o.decode(l,r)}isFramebufferReady(){return!0}getActiveTexture(){const e=this.gl;return"TEXTURE"+(e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,t){const n=this.gl;n.vertexAttribPointer(e,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(e),-1!==t&&(n.vertexAttribPointer(t,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(t)),this.checkError()}createProgram(e,t){const n=this.gl,r=n.createProgram();return n.attachShader(r,e),n.attachShader(r,t),n.linkProgram(r),r}compileShader(e,t){const n=this.gl,r=n.createShader(t);if(!r)throw new Error(`createShader() returned null with type ${t}`);if(n.shaderSource(r,e),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${e}`);return r}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,t,n){const r=this.gl;r.activeTexture(r.TEXTURE0+t),this.checkError(),r.bindTexture(r.TEXTURE_2D,e),this.checkError(),r.uniform1i(n,t),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(i.env.debug){const e=this.gl,t=e.getError();let n="";switch(t){case e.NO_ERROR:return;case e.INVALID_ENUM:n="INVALID_ENUM";break;case e.INVALID_VALUE:n="INVALID_VALUE";break;case e.INVALID_OPERATION:n="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${t.toString(16)}`}throw new Error(n)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,t,n=0){if(2===this.version)return new o.RedFloat32DataEncoder(this.gl,t);switch(e){case"float":return 1===n||this.isRenderFloat32Supported?new o.RGBAFloatDataEncoder(this.gl,t):new o.RGBAFloatDataEncoder(this.gl,t,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new o.Uint8DataEncoder(this.gl,t);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){const e=this.gl;for(let t=0;t<this.maxTextureImageUnits;++t)e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const e=this.gl,t=e.createBuffer();if(!t)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),this.checkError(),t}createFramebuffer(){const e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){const e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);const n=2===this.version?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,n,1,1,0,e.RGBA,e.FLOAT,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(r),s}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const e=this.gl;let t,n,r,s,a;try{t=e.createTexture(),n=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,t);const i=2===this.version?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.enable(e.BLEND),r=e.createShader(e.VERTEX_SHADER),!!r&&(e.shaderSource(r,"void main(){}"),e.compileShader(r),s=e.createShader(e.FRAGMENT_SHADER),!!s&&(e.shaderSource(s,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(s),a=e.createProgram(),!!a&&(e.attachShader(a,r),e.attachShader(a,s),e.linkProgram(a),e.useProgram(a),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)))}finally{e.disable(e.BLEND),a&&e.deleteProgram(a),r&&e.deleteShader(r),s&&e.deleteShader(s),n&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(n)),t&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(t))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const e=this.gl,t=this.disjointTimerQueryWebgl2Extension,n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl,t=this.disjointTimerQueryWebgl2Extension;e.endQuery(t.TIME_ELAPSED_EXT)}}isTimerResultAvailable(e){let t=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl,s=this.disjointTimerQueryWebgl2Extension;t=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(s.GPU_DISJOINT_EXT)}return t&&!n}getTimerResult(e){let t=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;t=n.getQueryParameter(e,n.QUERY_RESULT),n.deleteQuery(e)}return t/1e6}async waitForQueryAndGetTime(e){return await(0,l.repeatedTry)((()=>this.isTimerResultAvailable(e))),this.getTimerResult(e)}async createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;const n=e,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),t=null===r?()=>!0:()=>{const e=n.clientWaitSync(r,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED},{query:r,isFencePassed:t}}async pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=u(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||await(0,l.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},1036:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const r=n(6231);class s{constructor(e,t){this.op=e,this.node=t}}t.ExecutionPlan=class{constructor(e,t,n){this.graph=e,this.profiler=n,this.initialize(t)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const t=this.graph.getNodes();if(t.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map(((e,n)=>new s(e,t[n]))),this.reset(),this._starter=[],this._ops.forEach(((e,t)=>{let n=!0;for(const t of e.node.inputs)if(!this._values[t]&&-1===this.graph.getInputIndices().indexOf(t)){n=!1;break}n&&this._starter.push(t)}))}))}reset(){this._values=this.graph.getValues().map((e=>e.tensor))}async execute(e,t){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const n=e.createInferenceHandler(),s=this.graph.getInputIndices();if(t.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t.length} expected: ${s.length}`);t.forEach(((e,t)=>{const n=s[t];this._values[n]=e}));const a=this._starter.slice(0),i=this.graph.getValues(),o=this.graph.getNodes();let l=0;for(;l<a.length;){const e=a[l++],t=this._ops[e],s=t.node.inputs.map((e=>this._values[e]));if(-1!==s.indexOf(void 0))throw new Error(`unresolved input detected: op: ${t.node}`);const u=s;r.Logger.verbose("ExecPlan",`Runing op:${t.node.name} (${u.map(((e,n)=>`'${t.node.inputs[n]}': ${e.type}[${e.dims.join(",")}]`)).join(", ")})`);const c=await this.profiler.event("node",t.node.name,(async()=>t.op.impl(n,u,t.op.context)));if(c.length!==t.node.outputs.length)throw new Error("the size of output does not match model definition.");c.forEach(((e,n)=>{const r=t.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${t.node.name}`);this._values[r]=e}));const d=new Set;c.forEach(((e,n)=>{const r=t.node.outputs[n];for(const e of i[r].to){const t=o[e];let n=!0;for(const e of t.inputs)if(!this._values[e]){n=!1;break}n&&d.add(e)}})),a.push(...d)}const u=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){const t=this.graph.getOutputIndices()[e],n=this._values[t];if(void 0===n)throw new Error(`required output [${t}] does not have value`);0===t?await n.getData():n.data,u.push(n)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),u}))}}},7070:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const r=n(1446),s=n(7778),a=n(9395),i=n(9162),o=n(2517);var l=a.onnxruntime.experimental.fbs;t.Graph={from:(e,t)=>new d(e,t)};class u{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=o.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}}class c{constructor(e,t){e instanceof r.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new s.Attribute(e.attribute)):e instanceof l.Node&&(this.name=null!=t?t:e.name(),this.opType=e.opType(),this.attributes=new s.Attribute(o.ProtoUtil.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class d{constructor(e,t){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(t),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else{if(!(e instanceof l.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(e)}}buildGraphFromOnnxFormat(e){const t=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!e.input)throw new Error("missing information in graph: input");const r=[];for(const n of e.input){if(t.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const e=this._allData.push(new u(n))-1;t.set(n.name,e),r.push(n.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(const n of e.initializer){let e=t.get(n.name);if(void 0===e){const r=new u;r.type={shape:{dims:o.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:o.ProtoUtil.tensorDataTypeFromProto(n.dataType)},e=this._allData.push(r)-1,t.set(n.name,e)}this._allData[e]._from=-1,this._allData[e].tensor=i.Tensor.fromProto(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(r[e]));if(!e.output)throw new Error("missing information in graph: output");for(const n of e.output){if(t.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const e=this._allData.push(new u(n))-1;t.set(n.name,e),this._allOutputIndices.push(e),this._allOutputNames.push(n.name)}if(!e.node)throw new Error("missing information in graph: node");for(const t of e.node){if(!t.name)for(let e=0;;e++){const r=`unnamed_${t.opType}_${e}`;if(!n.has(r)){t.name=r;break}}if(n.has(t.name))throw new Error(`duplicated node name: ${t.name}`);const e=this._nodes.push(new c(t))-1;n.set(t.name,e)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],s=e.node[n];if(!s.output)throw new Error(`missing output for node: ${s.name}`);for(const e of s.output){let a=t.get(e);if(void 0===a&&(a=this._allData.push(new u)-1,t.set(e,a)),r.outputs.push(a),void 0!==this._allData[a]._from)throw new Error(`multiple nodes output to one data value: ${a}`);if(this._allData[a]._from=n,"Constant"===s.opType){if(!s.attribute||1!==s.attribute.length||!s.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!s.output||1!==s.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[a]._from=-1,this._allData[a].tensor=i.Tensor.fromProto(s.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],s=e.node[n];if(!s.input)throw new Error(`missing input for node: ${s.name}`);for(const e of s.input){const a=t.get(e);if(void 0===a){if(""===e&&3===s.input.length&&"Resize"===s.opType)continue;throw new Error(`unrecognized input '${e}' for node: ${s.name}`)}r.inputs.push(a),this._allData[a]._to.push(n)}}return!0}buildGraphFromOrtFormat(e){var t,n,r;const s=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const a=new Map,d=[];for(let a=0;a<e.inputsLength();a++){const i=e.inputs(a);if(s.has(i))throw new Error(`duplicated input name: ${i}`);for(let a=0;a<e.nodeArgsLength();a++)if((null===(t=e.nodeArgs(a))||void 0===t?void 0:t.name())===i){const t=new u;if((null===(r=null===(n=e.nodeArgs(a))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==l.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const c=e.nodeArgs(a).type().value(new l.TensorTypeAndShape),h=o.ProtoUtil.tensorDataTypeFromProto(c.elemType()),p=c.shape(),f=[];for(let e=0;e<p.dimLength();e++)f.push(o.LongUtil.longToNumber(p.dim(e).value().dimValue()));t.type={shape:{dims:f},tensorType:h};const m=this._allData.push(t)-1;s.set(i,m),d.push(i)}}for(let t=0;t<e.initializersLength();t++){const n=e.initializers(t);let r=s.get(n.name());if(void 0===r){const e=new u,t=o.ProtoUtil.tensorDimsFromORTFormat(n),a=o.ProtoUtil.tensorDataTypeFromProto(n.dataType());e.type={shape:{dims:t},tensorType:a},r=this._allData.push(e)-1,s.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=i.Tensor.fromOrtTensor(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(d[e]));for(let t=0;t<e.outputsLength();t++){const n=e.outputs(t);if(s.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new u)-1;s.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!e.nodes)throw new Error("missing information in graph: node");for(let t=0;t<e.nodesLength();t++){const n=e.nodes(t);let r=n.name();if(!r)for(let e=0;r=`unnamed_${n.opType()}_${e}`,a.has(r);e++);if(a.has(r))throw new Error(`duplicated node name: ${r}`);const s=this._nodes.push(new c(n,r))-1;a.set(r,s)}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(null==r)throw new Error(`No node exists at index ${t}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let e=0;e<(null==r?void 0:r.outputsLength());e++){const a=null==r?void 0:r.outputs(e);let o=s.get(a);if(void 0===o&&(o=this._allData.push(new u)-1,s.set(a,o)),n.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=t,"Constant"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==r.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=i.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let e=0;e<r.inputsLength();e++){const a=r.inputs(e),i=s.get(a);if(void 0===i)throw new Error(`unrecognized input '${a}' for node: ${r.name()}`);n.inputs.push(i),this._allData[i]._to.push(t)}}}checkIsAcyclic(){const e=new Set;this._allInputIndices.forEach((t=>{this._allData[t]._to.forEach((t=>{e.add(t)}))}));const t=Array.from(e),n=new Array(this._nodes.length).fill("white");for(;t.length>0;){const e=t.pop();"gray"===n[e]?n[e]="black":(t.push(e),n[e]="gray",this._nodes[e].outputs.forEach((r=>{const s=this._allData[r];if(void 0!==s.tensor)throw new Error("node outputs should not be initialized");if(s._from!==e)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach((e=>{if("gray"===n[e])throw new Error("model graph is cyclic");"white"===n[e]&&t.push(e)}))})))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0;for(let t=0;t<this._nodes.length;t++)this._nodes[t].executeNode?e>0&&(this._nodes[t].inputs.forEach((n=>{const r=this._allData[n]._to.indexOf(t+e);-1!==r&&(this._allData[n]._to[r]=t)})),this._nodes[t].outputs.forEach((n=>{this._allData[n]._from&&this._allData[n]._from===t+e&&(this._allData[n]._from=t)}))):(e++,this._nodes[t].outputs.forEach((e=>{this._allData[e]._from=-2})),this._nodes.splice(t,1),t--);e=0;for(let t=0;t<this._allData.length;t++)if(-2!==this._allData[t].from||-1!==this._allOutputIndices.indexOf(t+e)){if(e>0){let n=-1;void 0!==this._allData[t].from&&-1!==this._allData[t].from?(n=this._nodes[this._allData[t].from].outputs.indexOf(t+e),-1!==n&&(this._nodes[this._allData[t].from].outputs[n]=t)):(n=this._allInputIndices.indexOf(t+e),-1!==n&&(this._allInputIndices[n]=t)),this._allData[t].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(t+e),-1!==n&&(this._nodes[r].inputs[n]=t)})),0===this._allData[t].to.length&&(n=this._allOutputIndices.indexOf(t+e),-1!==n&&(this._allOutputIndices[n]=t))}}else e++,this._allData.splice(t,1),t--}deleteNode(e){const t=this._nodes[e];if(t.outputs.length>1)for(let e=1;e<t.outputs.length;e++)if(this._allData[t.outputs[e]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");t.executeNode=!1;const n=t.inputs[0],r=t.outputs[0],s=this._allData[r].to,a=this._allData[n].to.indexOf(e);if(-1===a)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n].to.splice(a,1),this._allData[r]._to=[];const i=this._allOutputIndices.indexOf(r);if(-1!==i&&(this._allOutputIndices[i]=n),s&&s.length>0)for(const e of s){const t=this._nodes[e].inputs.indexOf(r);if(-1===t)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[e].inputs[t]=n,this._allData[n].to.push(e)}}removeAllDropoutNodes(){let e=0;for(const t of this._nodes){if("Dropout"===t.opType){if(1!==t.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==t.outputs.length&&2!==t.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===t.outputs.length&&0!==this._allData[t.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(const t of this._nodes)"Identity"===t.opType&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const e of this._nodes)if("Conv"===e.opType){const t=this._allData[e.outputs[0]]._to;if(1===t.length&&this.isActivation(this._nodes[t[0]])){const n=this._nodes[t[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{e.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(t){e.attributes.set("activation_params","floats",[o.MIN_CLIP,o.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;e.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}e.attributes.set("activation","string",n.opType),this.deleteNode(t[0])}}}}},6231:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(e,t,n){}},console:new class{log(e,t,n){console.log(`${this.color(e)} ${n?"[35m"+n+"[0m ":""}${t}`)}color(e){switch(e){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${e}`)}}}},s={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let a={"":s};function i(e,t,n,r){if(void 0===t)return s=e,{verbose:i.verbose.bind(null,s),info:i.info.bind(null,s),warning:i.warning.bind(null,s),error:i.error.bind(null,s),fatal:i.fatal.bind(null,s)};if(void 0===n)o(e,t);else if("number"==typeof n&&void 0===r)o(e,t);else if("string"==typeof n&&void 0===r)o(e,n,0,t);else{if("string"!=typeof n||"number"!=typeof r)throw new TypeError("input is valid");o(e,n,0,t)}var s}function o(e,t,s,i){const o=a[i||""]||a[""];n[e]<n[o.minimalSeverity]||(o.logDateTime&&(t=`${(new Date).toISOString()}|${t}`),o.logSourceLocation,r[o.provider].log(e,t,i))}!function(e){function t(e){a={},n("",e||{})}function n(e,n){if("*"===e)t(n);else{const t=a[e]||s;a[e]={provider:n.provider||t.provider,minimalSeverity:n.minimalSeverity||t.minimalSeverity,logDateTime:void 0===n.logDateTime?t.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?t.logSourceLocation:n.logSourceLocation}}}e.verbose=function(t,n){e("verbose",t,n)},e.info=function(t,n){e("info",t,n)},e.warning=function(t,n){e("warning",t,n)},e.error=function(t,n){e("error",t,n)},e.fatal=function(t,n){e("fatal",t,n)},e.reset=t,e.set=n,e.setWithEnv=function(e){const t={};e.logLevel&&(t.minimalSeverity=e.logLevel),n("",t)}}(i||(i={})),t.Logger=i;class l{constructor(e,t,n,r,s,a){this.category=e,this.name=t,this.startTime=n,this.endCallback=r,this.timer=s,this.ctx=a}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class u{constructor(e,t,n,r){this.category=e,this.name=t,this.startTime=n,this.endTime=r}}t.Profiler=class{static create(e){return void 0===e?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}constructor(e,t,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===e?1e4:e,this._flushBatchSize=void 0===t?10:t,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,t,n,r){const s=this._started?this.begin(e,t,r):void 0;let a=!1;const i=n();if(i&&"function"==typeof i.then)return a=!0,new Promise(((e,t)=>{i.then((async t=>{s&&await s.end(),e(t)}),(async e=>{s&&await s.end(),t(e)}))}));if(!a&&s){const e=s.end();if(e&&"function"==typeof e.then)return new Promise(((t,n)=>{e.then((()=>{t(i)}),(e=>{n(e)}))}))}return i}begin(e,n,r){if(!this._started)throw new Error("profiler is not started yet");if(void 0===r){const r=(0,t.now)();return this.flush(r),new l(e,n,r,(e=>this.endSync(e)))}{const t=r.beginTimer();return new l(e,n,0,(async e=>this.end(e)),t,r)}}async end(e){const t=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new u(e.category,e.name,e.startTime,t)),this.flush(t))}endSync(e){const n=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new u(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){t.Logger.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(const e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const r=n(5686),s=n(1446),a=n(7070),i=n(9395),o=n(2517);var l=i.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(e,t,n){if(!n)try{return void this.loadFromOnnxFormat(e,t)}catch(e){if(void 0!==n)throw e}this.loadFromOrtFormat(e,t)}loadFromOnnxFormat(e,t){const n=s.onnx.ModelProto.decode(e);if(o.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map((e=>({domain:e.domain,version:o.LongUtil.longToNumber(e.version)}))),this._graph=a.Graph.from(n.graph,t)}loadFromOrtFormat(e,t){const n=new r.flatbuffers.ByteBuffer(e),s=l.InferenceSession.getRootAsInferenceSession(n).model();if(o.LongUtil.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let e=0;e<s.opsetImportLength();e++){const t=s.opsetImport(e);this._opsets.push({domain:null==t?void 0:t.domain(),version:o.LongUtil.longToNumber(t.version())})}this._graph=a.Graph.from(s.graph(),t)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},1047:(e,t)=>{"use strict";function n(e,t){if(t.endsWith("+")){const n=Number.parseInt(t.substring(0,t.length-1),10);return!isNaN(n)&&n<=e}if(2===t.split("-").length){const n=t.split("-"),r=Number.parseInt(n[0],10),s=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(s)&&r<=e&&e<=s}return Number.parseInt(t,10)===e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(e,t,r){for(const s of r){const r=s[0],a=s[1],i=s[2],o=s[3],l=s[4];if(e.opType===r)for(const e of t)if((e.domain===a||"ai.onnx"===e.domain&&""===a)&&n(e.version,i))return{opImpl:o,opInit:l}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${t.map((e=>`${e.domain||"ai.onnx"} v${e.version}`)).join(", ")}`)}},9395:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const r=n(5686);var s,a;(function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.INT=2]="INT",e[e.STRING=3]="STRING",e[e.TENSOR=4]="TENSOR",e[e.GRAPH=5]="GRAPH",e[e.FLOATS=6]="FLOATS",e[e.INTS=7]="INTS",e[e.STRINGS=8]="STRINGS",e[e.TENSORS=9]="TENSORS",e[e.GRAPHS=10]="GRAPHS",e[e.SPARSE_TENSOR=11]="SPARSE_TENSOR",e[e.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(t=e.AttributeType||(e.AttributeType={}))})((a=(s=t.onnxruntime||(t.onnxruntime={})).experimental||(s.experimental={})).fbs||(a.fbs={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.VALUE=1]="VALUE",e[e.PARAM=2]="PARAM"}(t=e.DimensionValueType||(e.DimensionValueType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.UINT8=2]="UINT8",e[e.INT8=3]="INT8",e[e.UINT16=4]="UINT16",e[e.INT16=5]="INT16",e[e.INT32=6]="INT32",e[e.INT64=7]="INT64",e[e.STRING=8]="STRING",e[e.BOOL=9]="BOOL",e[e.FLOAT16=10]="FLOAT16",e[e.DOUBLE=11]="DOUBLE",e[e.UINT32=12]="UINT32",e[e.UINT64=13]="UINT64",e[e.COMPLEX64=14]="COMPLEX64",e[e.COMPLEX128=15]="COMPLEX128",e[e.BFLOAT16=16]="BFLOAT16"}(t=e.TensorDataType||(e.TensorDataType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.Primitive=0]="Primitive",e[e.Fused=1]="Fused"}(t=e.NodeType||(e.NodeType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.NONE=0]="NONE",e[e.tensor_type=1]="tensor_type",e[e.sequence_type=2]="sequence_type",e[e.map_type=3]="map_type"}(t=e.TypeInfoValue||(e.TypeInfoValue={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dim(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}dimLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}static startShape(e){e.startObject(1)}static addDim(e,t){e.addFieldOffset(0,t,0)}static createDimVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startDimVector(e,t){e.startVector(4,t,4)}static endShape(e){return e.endObject()}static createShape(e,t){return n.startShape(e),n.addDim(e,t),n.endShape(e)}}t.Shape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimension(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimension(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}value(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimension(e){e.startObject(2)}static addValue(e,t){e.addFieldOffset(0,t,0)}static addDenotation(e,t){e.addFieldOffset(1,t,0)}static endDimension(e){return e.endObject()}static createDimension(e,t,r){return n.startDimension(e),n.addValue(e,t),n.addDenotation(e,r),n.endDimension(e)}}t.Dimension=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimensionValue(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimensionValue(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):e.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}dimParam(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimensionValue(e){e.startObject(3)}static addDimType(t,n){t.addFieldInt8(0,n,e.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static addDimParam(e,t){e.addFieldOffset(2,t,0)}static endDimensionValue(e){return e.endObject()}static createDimensionValue(e,t,r,s){return n.startDimensionValue(e),n.addDimType(e,t),n.addDimValue(e,r),n.addDimParam(e,s),n.endDimensionValue(e)}}t.DimensionValue=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensorTypeAndShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensorTypeAndShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}shape(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(e){e.startObject(2)}static addElemType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(e,t){e.addFieldOffset(1,t,0)}static endTensorTypeAndShape(e){return e.endObject()}static createTensorTypeAndShape(e,t,r){return n.startTensorTypeAndShape(e),n.addElemType(e,t),n.addShape(e,r),n.endTensorTypeAndShape(e)}}t.TensorTypeAndShape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsMapType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsMapType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}valueType(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(e){e.startObject(2)}static addKeyType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(e,t){e.addFieldOffset(1,t,0)}static endMapType(e){return e.endObject()}static createMapType(e,t,r){return n.startMapType(e),n.addKeyType(e,t),n.addValueType(e,r),n.endMapType(e)}}t.MapType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSequenceType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSequenceType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(e){e.startObject(1)}static addElemType(e,t){e.addFieldOffset(0,t,0)}static endSequenceType(e){return e.endObject()}static createSequenceType(e,t){return n.startSequenceType(e),n.addElemType(e,t),n.endSequenceType(e)}}t.SequenceType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){(e.fbs||(e.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(e,t,n,r){return e.prep(4,12),e.writeInt32(r),e.writeInt32(n),e.writeInt32(t),e.offset()}}}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNodeEdge(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNodeEdge(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}nodeIndex(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb_pos+e):0}inputEdges(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}inputEdgesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}outputEdges(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}outputEdgesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNodeEdge(e){e.startObject(3)}static addNodeIndex(e,t){e.addFieldInt32(0,t,0)}static addInputEdges(e,t){e.addFieldOffset(1,t,0)}static startInputEdgesVector(e,t){e.startVector(12,t,4)}static addOutputEdges(e,t){e.addFieldOffset(2,t,0)}static startOutputEdgesVector(e,t){e.startVector(12,t,4)}static endNodeEdge(e){return e.endObject()}static createNodeEdge(e,t,r,s){return n.startNodeEdge(e),n.addNodeIndex(e,t),n.addInputEdges(e,r),n.addOutputEdges(e,s),n.endNodeEdge(e)}}t.NodeEdge=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNode(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNode(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}sinceVersion(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):0}index(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb_pos+e):0}opType(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.NodeType.Primitive}executionProviderType(e){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,e):null}inputs(e,t){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}attributes(t,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}attributesLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCounts(e){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*e):0}inputArgCountsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCountsArray(){let e=this.bb.__offset(this.bb_pos,26);return e?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}implicitInputs(e,t){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}implicitInputsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNode(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDomain(e,t){e.addFieldOffset(2,t,0)}static addSinceVersion(e,t){e.addFieldInt32(3,t,0)}static addIndex(e,t){e.addFieldInt32(4,t,0)}static addOpType(e,t){e.addFieldOffset(5,t,0)}static addType(t,n){t.addFieldInt32(6,n,e.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(e,t){e.addFieldOffset(7,t,0)}static addInputs(e,t){e.addFieldOffset(8,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(9,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addAttributes(e,t){e.addFieldOffset(10,t,0)}static createAttributesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startAttributesVector(e,t){e.startVector(4,t,4)}static addInputArgCounts(e,t){e.addFieldOffset(11,t,0)}static createInputArgCountsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startInputArgCountsVector(e,t){e.startVector(4,t,4)}static addImplicitInputs(e,t){e.addFieldOffset(12,t,0)}static createImplicitInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startImplicitInputsVector(e,t){e.startVector(4,t,4)}static endNode(e){return e.endObject()}static createNode(e,t,r,s,a,i,o,l,u,c,d,h,p,f){return n.startNode(e),n.addName(e,t),n.addDocString(e,r),n.addDomain(e,s),n.addSinceVersion(e,a),n.addIndex(e,i),n.addOpType(e,o),n.addType(e,l),n.addExecutionProviderType(e,u),n.addInputs(e,c),n.addOutputs(e,d),n.addAttributes(e,h),n.addInputArgCounts(e,p),n.addImplicitInputs(e,f),n.endNode(e)}}t.Node=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsValueInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsValueInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(e){e.startObject(3)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldOffset(2,t,0)}static endValueInfo(e){return e.endObject()}static createValueInfo(e,t,r,s){return n.startValueInfo(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,s),n.endValueInfo(e)}}t.ValueInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTypeInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTypeInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}denotation(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):e.experimental.fbs.TypeInfoValue.NONE}value(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(e,this.bb_pos+t):null}static startTypeInfo(e){e.startObject(3)}static addDenotation(e,t){e.addFieldOffset(0,t,0)}static addValueType(t,n){t.addFieldInt8(1,n,e.experimental.fbs.TypeInfoValue.NONE)}static addValue(e,t){e.addFieldOffset(2,t,0)}static endTypeInfo(e){return e.endObject()}static createTypeInfo(e,t,r,s){return n.startTypeInfo(e),n.addDenotation(e,t),n.addValueType(e,r),n.addValue(e,s),n.endTypeInfo(e)}}t.TypeInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsOperatorSetId(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsOperatorSetId(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}domain(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}version(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}static startOperatorSetId(e){e.startObject(2)}static addDomain(e,t){e.addFieldOffset(0,t,0)}static addVersion(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static endOperatorSetId(e){return e.endObject()}static createOperatorSetId(e,n,r){return t.startOperatorSetId(e),t.addDomain(e,n),t.addVersion(e,r),t.endOperatorSetId(e)}}e.OperatorSetId=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}rawData(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+e):0}rawDataLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}rawDataArray(){let e=this.bb.__offset(this.bb_pos,12);return e?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}stringData(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringDataLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}static startTensor(e){e.startObject(6)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static addDataType(t,n){t.addFieldInt32(3,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(e,t){e.addFieldOffset(4,t,0)}static createRawDataVector(e,t){e.startVector(1,t.length,1);for(let n=t.length-1;n>=0;n--)e.addInt8(t[n]);return e.endVector()}static startRawDataVector(e,t){e.startVector(1,t,1)}static addStringData(e,t){e.addFieldOffset(5,t,0)}static createStringDataVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringDataVector(e,t){e.startVector(4,t,4)}static endTensor(e){return e.endObject()}static createTensor(e,t,r,s,a,i,o){return n.startTensor(e),n.addName(e,t),n.addDocString(e,r),n.addDims(e,s),n.addDataType(e,a),n.addRawData(e,i),n.addStringData(e,o),n.endTensor(e)}}t.Tensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSparseTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSparseTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}values(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSparseTensor(e){e.startObject(3)}static addValues(e,t){e.addFieldOffset(0,t,0)}static addIndices(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static endSparseTensor(e){return e.endObject()}static createSparseTensor(e,t,r,s){return n.startSparseTensor(e),n.addValues(e,t),n.addIndices(e,r),n.addDims(e,s),n.endSparseTensor(e)}}t.SparseTensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsAttribute(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAttribute(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.AttributeType.UNDEFINED}f(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb_pos+e):0}i(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}s(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}t(t){let n=this.bb.__offset(this.bb_pos,16);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*e):0}floatsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}floatsArray(){let e=this.bb.__offset(this.bb_pos,20);return e?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}ints(e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}intsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}strings(e,t){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringsLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}tensors(t,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}tensorsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}graphs(t,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}graphsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startAttribute(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(t,n){t.addFieldInt32(2,n,e.experimental.fbs.AttributeType.UNDEFINED)}static addF(e,t){e.addFieldFloat32(3,t,0)}static addI(e,t){e.addFieldInt64(4,t,e.createLong(0,0))}static addS(e,t){e.addFieldOffset(5,t,0)}static addT(e,t){e.addFieldOffset(6,t,0)}static addG(e,t){e.addFieldOffset(7,t,0)}static addFloats(e,t){e.addFieldOffset(8,t,0)}static createFloatsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addFloat32(t[n]);return e.endVector()}static startFloatsVector(e,t){e.startVector(4,t,4)}static addInts(e,t){e.addFieldOffset(9,t,0)}static createIntsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startIntsVector(e,t){e.startVector(8,t,8)}static addStrings(e,t){e.addFieldOffset(10,t,0)}static createStringsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringsVector(e,t){e.startVector(4,t,4)}static addTensors(e,t){e.addFieldOffset(11,t,0)}static createTensorsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startTensorsVector(e,t){e.startVector(4,t,4)}static addGraphs(e,t){e.addFieldOffset(12,t,0)}static createGraphsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startGraphsVector(e,t){e.startVector(4,t,4)}static endAttribute(e){return e.endObject()}static createAttribute(e,t,r,s,a,i,o,l,u,c,d,h,p,f){return n.startAttribute(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,s),n.addF(e,a),n.addI(e,i),n.addS(e,o),n.addT(e,l),n.addG(e,u),n.addFloats(e,c),n.addInts(e,d),n.addStrings(e,h),n.addTensors(e,p),n.addGraphs(e,f),n.endAttribute(e)}}t.Attribute=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsGraph(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsGraph(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}initializers(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}initializersLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeArgs(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeArgsLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}nodes(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}maxNodeIndex(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb_pos+e):0}nodeEdges(t,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeEdgesLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}inputs(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__vector_len(this.bb_pos+e):0}sparseInitializers(t,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}sparseInitializersLength(){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__vector_len(this.bb_pos+e):0}static startGraph(e){e.startObject(8)}static addInitializers(e,t){e.addFieldOffset(0,t,0)}static createInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInitializersVector(e,t){e.startVector(4,t,4)}static addNodeArgs(e,t){e.addFieldOffset(1,t,0)}static createNodeArgsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeArgsVector(e,t){e.startVector(4,t,4)}static addNodes(e,t){e.addFieldOffset(2,t,0)}static createNodesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodesVector(e,t){e.startVector(4,t,4)}static addMaxNodeIndex(e,t){e.addFieldInt32(3,t,0)}static addNodeEdges(e,t){e.addFieldOffset(4,t,0)}static createNodeEdgesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeEdgesVector(e,t){e.startVector(4,t,4)}static addInputs(e,t){e.addFieldOffset(5,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(6,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addSparseInitializers(e,t){e.addFieldOffset(7,t,0)}static createSparseInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSparseInitializersVector(e,t){e.startVector(4,t,4)}static endGraph(e){return e.endObject()}static createGraph(e,t,r,s,a,i,o,l,u){return n.startGraph(e),n.addInitializers(e,t),n.addNodeArgs(e,r),n.addNodes(e,s),n.addMaxNodeIndex(e,a),n.addNodeEdges(e,i),n.addInputs(e,o),n.addOutputs(e,l),n.addSparseInitializers(e,u),n.endGraph(e)}}t.Graph=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsModel(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsModel(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}irVersion(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}opsetImport(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}opsetImportLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}producerName(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}producerVersion(e){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,e):null}modelVersion(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}docString(e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,e):null}graph(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,e):null}static startModel(e){e.startObject(9)}static addIrVersion(e,t){e.addFieldInt64(0,t,e.createLong(0,0))}static addOpsetImport(e,t){e.addFieldOffset(1,t,0)}static createOpsetImportVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOpsetImportVector(e,t){e.startVector(4,t,4)}static addProducerName(e,t){e.addFieldOffset(2,t,0)}static addProducerVersion(e,t){e.addFieldOffset(3,t,0)}static addDomain(e,t){e.addFieldOffset(4,t,0)}static addModelVersion(e,t){e.addFieldInt64(5,t,e.createLong(0,0))}static addDocString(e,t){e.addFieldOffset(6,t,0)}static addGraph(e,t){e.addFieldOffset(7,t,0)}static addGraphDocString(e,t){e.addFieldOffset(8,t,0)}static endModel(e){return e.endObject()}static createModel(e,t,r,s,a,i,o,l,u,c){return n.startModel(e),n.addIrVersion(e,t),n.addOpsetImport(e,r),n.addProducerName(e,s),n.addProducerVersion(e,a),n.addDomain(e,i),n.addModelVersion(e,o),n.addDocString(e,l),n.addGraph(e,u),n.addGraphDocString(e,c),n.endModel(e)}}t.Model=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsKernelCreateInfos(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsKernelCreateInfos(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}nodeIndices(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*e):0}nodeIndicesLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeIndicesArray(){let e=this.bb.__offset(this.bb_pos,4);return e?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}kernelDefHashes(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}kernelDefHashesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startKernelCreateInfos(e){e.startObject(2)}static addNodeIndices(e,t){e.addFieldOffset(0,t,0)}static createNodeIndicesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startNodeIndicesVector(e,t){e.startVector(4,t,4)}static addKernelDefHashes(e,t){e.addFieldOffset(1,t,0)}static createKernelDefHashesVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startKernelDefHashesVector(e,t){e.startVector(8,t,8)}static endKernelCreateInfos(e){return e.endObject()}static createKernelCreateInfos(e,n,r){return t.startKernelCreateInfos(e),t.addNodeIndices(e,n),t.addKernelDefHashes(e,r),t.endKernelCreateInfos(e)}}e.KernelCreateInfos=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSubGraphSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSubGraphSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}graphId(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(e){e.startObject(2)}static addGraphId(e,t){e.addFieldOffset(0,t,0)}static addSessionState(e,t){e.addFieldOffset(1,t,0)}static endSubGraphSessionState(e){let t=e.endObject();return e.requiredField(t,4),t}static createSubGraphSessionState(e,t,r){return n.startSubGraphSessionState(e),n.addGraphId(e,t),n.addSessionState(e,r),n.endSubGraphSessionState(e)}}t.SubGraphSessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}kernels(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}subGraphSessionStatesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSessionState(e){e.startObject(2)}static addKernels(e,t){e.addFieldOffset(0,t,0)}static addSubGraphSessionStates(e,t){e.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSubGraphSessionStatesVector(e,t){e.startVector(4,t,4)}static endSessionState(e){return e.endObject()}static createSessionState(e,t,r){return n.startSessionState(e),n.addKernels(e,t),n.addSubGraphSessionStates(e,r),n.endSessionState(e)}}t.SessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsInferenceSession(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsInferenceSession(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static bufferHasIdentifier(e){return e.__has_identifier("ORTM")}ortVersion(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}model(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(e){e.startObject(3)}static addOrtVersion(e,t){e.addFieldOffset(0,t,0)}static addModel(e,t){e.addFieldOffset(1,t,0)}static addSessionState(e,t){e.addFieldOffset(2,t,0)}static endInferenceSession(e){return e.endObject()}static finishInferenceSessionBuffer(e,t){e.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(e,t){e.finish(t,"ORTM",!0)}static createInferenceSession(e,t,r,s){return n.startInferenceSession(e),n.addOrtVersion(e,t),n.addModel(e,r),n.addSessionState(e,s),n.endInferenceSession(e)}}t.InferenceSession=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},7448:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const r=n(1670),s=n(9162);t.OnnxjsSessionHandler=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,t,n){const a=new Map;for(const t in e)if(Object.hasOwnProperty.call(e,t)){const n=e[t];a.set(t,new s.Tensor(n.dims,n.type,void 0,void 0,n.data))}const i=await this.session.run(a),o={};return i.forEach(((e,t)=>{o[t]=new r.Tensor(e.type,e.data,e.dims)})),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const r=n(7067),s=n(1296),a=n(7091),i=n(1036),o=n(6231),l=n(2644);t.Session=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=o.Profiler.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,t,n){await this.profiler.event("session","Session.loadModel",(async()=>{const i=await(0,a.resolveBackend)(this.backendHint);if(this.sessionHandler=i.createSessionHandler(this.context),this._model=new l.Model,"string"==typeof e){const t=e.endsWith(".ort");if("undefined"==typeof fetch){const n=await(0,s.promisify)(r.readFile)(e);this.initialize(n,t)}else{const n=await fetch(e),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),t)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{const r=new Uint8Array(e,t||0,n||e.byteLength);this.initialize(r)}}))}initialize(e,t){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,n,t),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new i.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const t=this.normalizeAndValidateInputs(e),n=await this._executionPlan.execute(this.sessionHandler,t);return this.createOutput(n)}))}normalizeAndValidateInputs(e){const t=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==t.length)throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`)}else{if(e.size!==t.length)throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);const n=new Array(e.size);let r=0;for(let s=0;s<t.length;++s){const a=e.get(t[s]);if(!a)throw new Error(`missing input tensor for: '${name}'`);n[r++]=a}e=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,e,!1);else{const t=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(t.length);for(let s=0;s<t.length;++s){const a=n[t[s]];r[s]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[s].dims)}this.validateInputTensorDims(r,e,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,t){for(let n=0;n<t.length;n++){const r=e[n],s=t[n].type;if(r!==s)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${s}`)}}validateInputTensorDims(e,t,n){for(let r=0;r<t.length;r++){const s=e[r],a=t[r].dims;if(!this.compareTensorDims(s,a,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${s.join(",")}]' but got [${a.join(",")}]`)}}compareTensorDims(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;++r)if(e[r]!==t[r]&&(!n||0!==e[r]))return!1;return!0}createOutput(e){const t=this._model.graph.getOutputNames();if(e.length!==t.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let r=0;r<t.length;++r)n.set(t[r],e[r]);return n}initializeOps(e){const t=e.getNodes();this._ops=new Array(t.length);for(let n=0;n<t.length;n++)this._ops[n]=this.sessionHandler.resolve(t[n],this._model.opsets,e)}}},9162:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const s=n(3442),a=r(n(3720)),i=n(1446),o=n(9395),l=n(2517);var u=o.onnxruntime.experimental.fbs;class c{get data(){if(void 0===this.cache){const e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[l.ShapeUtil.indicesToOffset(e,this.strides)]}set(e,t){this.data[l.ShapeUtil.indicesToOffset(e,this.strides)]=t}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=l.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(e,t,n,r,a,i=s.Guid.create()){this.dims=e,this.type=t,this.dataProvider=n,this.asyncDataProvider=r,this.cache=a,this.dataId=i,this.size=l.ShapeUtil.validateDimsAndCalcSize(e);const o=this.size,u=void 0===n&&void 0===r&&void 0===a;if(void 0!==a&&a.length!==o)throw new RangeError("Input dims doesn't match data length.");if("string"===t){if(!(void 0===a||Array.isArray(a)&&a.every((e=>"string"==typeof e))))throw new TypeError("cache should be a string array");u&&(this.cache=new Array(o))}else{if(void 0!==a){const e=h(t);if(!(a instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(u){const e=new ArrayBuffer(o*function(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}(t));this.cache=function(e,t){return new(h(t))(e)}(e,t)}}}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=l.ProtoUtil.tensorDataTypeFromProto(e.dataType),n=l.ProtoUtil.tensorDimsFromProto(e.dims),r=new c(n,t);if("string"===t)e.stringData.forEach(((e,t)=>{r.data[t]=(0,l.decodeUtf8String)(e)}));else if(e.rawData&&"number"==typeof e.rawData.byteLength&&e.rawData.byteLength>0){const t=r.data,n=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),s=d(e.dataType),a=e.rawData.byteLength/s;if(e.rawData.byteLength%s!=0)throw new Error("invalid buffer length");if(t.length!==a)throw new Error("buffer length mismatch");for(let r=0;r<a;r++){const a=f(n,e.dataType,r*s);t[r]=a}}else{let t;switch(e.dataType){case i.onnx.TensorProto.DataType.FLOAT:t=e.floatData;break;case i.onnx.TensorProto.DataType.INT32:case i.onnx.TensorProto.DataType.INT16:case i.onnx.TensorProto.DataType.UINT16:case i.onnx.TensorProto.DataType.INT8:case i.onnx.TensorProto.DataType.UINT8:case i.onnx.TensorProto.DataType.BOOL:t=e.int32Data;break;case i.onnx.TensorProto.DataType.INT64:t=e.int64Data;break;case i.onnx.TensorProto.DataType.DOUBLE:t=e.doubleData;break;case i.onnx.TensorProto.DataType.UINT32:case i.onnx.TensorProto.DataType.UINT64:t=e.uint64Data;break;default:throw new Error("unspecific error")}if(null==t)throw new Error("failed to populate data from a tensorproto value");const n=r.data;if(n.length!==t.length)throw new Error("array length mismatch");for(let r=0;r<t.length;r++){const s=t[r];a.default.isLong(s)?n[r]=p(s,e.dataType):n[r]=s}}return r}static fromData(e,t,n){return new c(t,n,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=l.ProtoUtil.tensorDimsFromORTFormat(e),n=l.ProtoUtil.tensorDataTypeFromProto(e.dataType()),r=new c(t,n);if("string"===n)for(let t=0;t<e.stringDataLength();t++)r.data[t]=e.stringData(t);else if(e.rawDataArray()&&"number"==typeof e.rawDataLength()&&e.rawDataLength()>0){const t=r.data,n=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),s=d(e.dataType()),a=e.rawDataLength()/s;if(e.rawDataLength()%s!=0)throw new Error("invalid buffer length");if(t.length!==a)throw new Error("buffer length mismatch");for(let r=0;r<a;r++){const a=f(n,e.dataType(),r*s);t[r]=a}}return r}}function d(e){switch(e){case i.onnx.TensorProto.DataType.UINT8:case i.onnx.TensorProto.DataType.INT8:case i.onnx.TensorProto.DataType.BOOL:return 1;case i.onnx.TensorProto.DataType.UINT16:case i.onnx.TensorProto.DataType.INT16:return 2;case i.onnx.TensorProto.DataType.FLOAT:case i.onnx.TensorProto.DataType.INT32:case i.onnx.TensorProto.DataType.UINT32:return 4;case i.onnx.TensorProto.DataType.INT64:case i.onnx.TensorProto.DataType.DOUBLE:case i.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${i.onnx.TensorProto.DataType[e]}`)}}function h(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function p(e,t){if(t===i.onnx.TensorProto.DataType.INT64||t===u.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(t!==i.onnx.TensorProto.DataType.UINT32&&t!==u.TensorDataType.UINT32&&t!==i.onnx.TensorProto.DataType.UINT64&&t!==u.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${i.onnx.TensorProto.DataType[t]}`);if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}return e.toNumber()}function f(e,t,n){switch(t){case i.onnx.TensorProto.DataType.BOOL:case i.onnx.TensorProto.DataType.UINT8:return e.getUint8(n);case i.onnx.TensorProto.DataType.INT8:return e.getInt8(n);case i.onnx.TensorProto.DataType.UINT16:return e.getUint16(n,!0);case i.onnx.TensorProto.DataType.INT16:return e.getInt16(n,!0);case i.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(n,!0);case i.onnx.TensorProto.DataType.INT32:return e.getInt32(n,!0);case i.onnx.TensorProto.DataType.UINT32:return e.getUint32(n,!0);case i.onnx.TensorProto.DataType.INT64:return p(a.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!1),t);case i.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(n,!0);case i.onnx.TensorProto.DataType.UINT64:return p(a.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!0),t);default:throw new Error(`cannot read from DataView for type ${i.onnx.TensorProto.DataType[t]}`)}}t.Tensor=c},2517:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const s=n(5686),a=r(n(3720)),i=n(1446),o=n(9162);t.checkInputsShape=function(e,...t){if(!e||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!e[n].dims||e[n].dims.length!==t[n])return!1;return!0},t.assert=function(e,t){if(!e)throw new Error("string"==typeof t?t:t())},t.ArrayUtil=class{static arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}};class l{static preprocessInputShapes(e,t){return[1===e.length?[1,e[0]]:e,1===t.length?[t[0],1]:t]}static postprocessOutputShape(e,t,n){1===t&&e.splice(e.length-2,1),1===n&&e.pop()}static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=l;class u{static calcShape(e,t,n=!1){const r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;const a=Math.max(e.length,t.length),i=new Array(a);if(n){if(r<2||s<2)return;const n=l.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[i[a-2],i[a-1]]=n}for(let o=n?3:1;o<=a;o++){const n=r-o<0?1:e[r-o],l=s-o<0?1:t[s-o];if(n!==l&&n>1&&l>1)return;i[a-o]=Math.max(n,l)}return i}static index(e,t){const n=new Array(t.length);return u.fillIndex(e,t,n),n}static fillIndex(e,t,n){const r=e.length-t.length;for(let s=0;s<t.length;s++)n[s]=e[r+s]%t[s]}static calc(e,t,n,r,s){const a=u.calcShape(e.dims,t.dims);if(a){if(r&&!h.areEqual(a,e.dims))return;const i=h.size(a),l=r?e:new o.Tensor(a,s||e.type);if(0===a.length)l.set([],n(e.get([]),t.get([])));else{const r=new Array(a.length),s=new Array(e.dims.length),o=new Array(t.dims.length);let c,d=0,h=0,p=!1,f=!1;0===e.dims.length&&(d=e.get([]),p=!0),0===t.dims.length&&(h=t.get([]),f=!0);for(let m=0;m<i;m++){c=m;for(let e=a.length-1;e>=0;e--)r[e]=c%a[e],c=Math.floor(c/a[e]);p||(u.fillIndex(r,e.dims,s),d=e.get(s)),f||(u.fillIndex(r,t.dims,o),h=t.get(o)),l.set(r,n(d,h))}}return l}}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}static getBroadcastDims(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}}t.BroadcastUtil=u,t.arrayCopyHelper=function(e,t,n,r,s){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<s;a++)e[n+a]=t[r+a]},t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,i,o;t?(a=e[1],i=e[0]):(a=e[0],i=e[1]);let l=-1;if(r?(o=n[0],l=1):(o=n[1],l=0),n[l]!==i)throw new Error("dimension mismatch");if(a<=0||o<=0||i<=0)throw new Error("invalid shape specified");if(s&&!u.isValidBroadcast(s,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,i]}};class c{static tensorDataTypeFromProto(e){switch(e){case i.onnx.TensorProto.DataType.INT8:return"int8";case i.onnx.TensorProto.DataType.UINT8:return"uint8";case i.onnx.TensorProto.DataType.BOOL:return"bool";case i.onnx.TensorProto.DataType.INT16:return"int16";case i.onnx.TensorProto.DataType.UINT16:return"uint16";case i.onnx.TensorProto.DataType.INT32:return"int32";case i.onnx.TensorProto.DataType.UINT32:return"uint32";case i.onnx.TensorProto.DataType.FLOAT:return"float32";case i.onnx.TensorProto.DataType.DOUBLE:return"float64";case i.onnx.TensorProto.DataType.STRING:return"string";case i.onnx.TensorProto.DataType.INT64:return"int32";case i.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${i.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return i.onnx.TensorProto.DataType.INT8;case"uint8":return i.onnx.TensorProto.DataType.UINT8;case"bool":return i.onnx.TensorProto.DataType.BOOL;case"int16":return i.onnx.TensorProto.DataType.INT16;case"uint16":return i.onnx.TensorProto.DataType.UINT16;case"int32":return i.onnx.TensorProto.DataType.INT32;case"uint32":return i.onnx.TensorProto.DataType.UINT32;case"float32":return i.onnx.TensorProto.DataType.FLOAT;case"float64":return i.onnx.TensorProto.DataType.DOUBLE;case"string":return i.onnx.TensorProto.DataType.STRING;case"int64":return i.onnx.TensorProto.DataType.INT64;case"uint64":return i.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map((e=>a.default.isLong(e)?e.toNumber():e))}static tensorValueTypeFromProto(e){return{tensorType:c.tensorDataTypeFromProto(e.elemType),shape:{dims:c.tensorDimsFromProto(e.shape.dim.map((e=>e.dimValue)))}}}static tensorDimsFromORTFormat(e){const t=[];for(let n=0;n<e.dimsLength();n++)t.push(d.longToNumber(e.dims(n)));return t}static tensorAttributesFromORTFormat(e){const t=[];for(let n=0;n<e.attributesLength();n++)t.push(e.attributes(n));return t}}t.ProtoUtil=c;class d{static longToNumber(e,t){return a.default.isLong(e)?e.toNumber():e instanceof s.flatbuffers.Long?a.default.fromValue({low:e.low,high:e.high,unsigned:null!=t&&t}).toNumber():e}static isLong(e){return a.default.isLong(e)||e instanceof s.flatbuffers.Long}}t.LongUtil=d;class h{static size(e){return h.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return h.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return h.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=e[s]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,t,n){void 0===n&&(n=e.length);let r=0;for(let s=0;s<n;++s)r+=t[s]*e[s];return r}static offsetToIndices(e,t){const n=t.length;if(0===n)return[];if(1===n)return[e*t[0]];const r=new Array(t.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(e/t[n]),e-=r[n]*t[n];return r[r.length-1]=e,r}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((e=>this.normalizeAxis(e,t)))}static incrementIndex(e,t,n){if(0===t.length||0===e.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=t.length;else if(n<=0||n>t.length)throw new Error("Incorrect axis to increment on");for(let r=n-1;r>=0&&(e[r]++,!(e[r]<t[r]));--r)e[r]=0}static calculateReshapedDims(e,t){if(0===t.length){if(0===e.length||1===h.size(e))return[];throw new Error("cannot reshape to a scalar Tensor")}const n=t.length,r=new Array(n);let s=-1,a=1;for(let i=0;i<n;i++){if(t[i]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===t[i]){if(-1!==s)throw new Error("at most one dimension in shape hints can be -1");s=i}else{if(0===t[i]){if(i>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");r[i]=e[i]}else r[i]=t[i];a*=r[i]}}const i=h.size(e);if(-1!==s){if(i%a!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);r[s]=i/a}else if(a!==i)throw new Error("reshapedDims and originalDims don't have matching sizes");return r}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let t=1;for(const n of e){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);t*=n}return t}static flattenShape(e,t){t<0&&(t+=e.length);const n=e.reduce(((e,t)=>e*t),1),r=e.slice(t).reduce(((e,t)=>e*t),1);return[n/r,r]}static squeezeShape(e,t){const n=new Array;t=h.normalizeAxes(t,e.length);for(let r=0;r<e.length;r++){const s=t.indexOf(r)>=0;if(s&&1!==e[r])throw new Error("squeeze an axis of size different than 1");(0===t.length&&e[r]>1||t.length>0&&!s)&&n.push(e[r])}return n}static unsqueezeShape(e,t){const n=new Array(e.length+t.length);n.fill(0);for(let e=0;e<t.length;e++){const r=h.normalizeAxis(t[e],n.length);if(r>=n.length)throw new Error("'axes' has an out of range axis");if(0!==n[r])throw new Error("'axes' has a duplicate axis");n[r]=1}let r=0;for(let t=0;t<n.length;t++)0===n[t]&&(n[t]=e[r++]);if(r!==e.length)throw new Error("the unsqueezed dimension could not be established");return n}}t.ShapeUtil=h,t.MathUtil=class{static sqr(e,t,n,r,s){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<s;a++)e[n+a]+=Math.pow(t[r+a],2)}static axpy(e,t,n,r,s,a){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<s;i++)e[n+i]+=a*t[r+i]}static powx(e,t,n,r,s,a){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<s;i++)e[n+i]=Math.pow(t[r+i],a)}static mul(e,t,n,r,s){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<s;a++)e[n+a]=t[r+a]*e[n+a]}};class p{static splitShape(e,t,n,r){if(0===n.length){if(!r)throw new Error("need to know number of outputs when the 'split' attribute is not specified");p.determineSplit(e[t],r,n)}const s=[],a=[0];for(let r=0;r<n.length;++r){0!==r&&a.push(a[r-1]+n[r-1]);const i=e.slice();i[t]=n[r],s.push(i)}return[s,a]}static determineSplit(e,t,n){if(e%t!=0)throw new Error("cannot split tensor to equal sized parts");for(let r=0;r<t;++r)n.push(e/t)}}t.SplitUtil=p;class f{static calcReduce(e,t,n,r,s){const a=e.dims.slice(0);0===t.length&&a.forEach(((e,n)=>t.push(n)));const i=f.calcReduceShape(a,t,!0),l=h.size(i),c=new o.Tensor(i,e.type),d=h.computeStrides(i),p=h.computeStrides(a),m=new Array(a.length);for(let n=0;n<l;n++){const i=h.offsetToIndices(n,d);u.fillIndex(i,a,m),c.set(i,f.calcReduceByAxis(e.numberData,t,a,0,h.indicesToOffset(m,p),r,s))}return n?c:new o.Tensor(f.calcReduceShape(a,t,n),c.type,void 0,void 0,c.data,c.dataId)}static calcReduceByAxis(e,t,n,r,s,a,i){let o=0;if(r>=t.length)return a(e[s]);const l=t[r],u=l>=n.length?1:h.size(n.slice(l+1));for(let c=0;c<n[l];c++)o=0===c?f.calcReduceByAxis(e,t,n,r+1,s,a,i):i(o,f.calcReduceByAxis(e,t,n,r+1,s,a,i)),s+=u;return o}static calcReduceShape(e,t,n){const r=e.slice();for(let e=0;e<t.length;e++)r[t[e]]=n?1:0;return r.filter((e=>0!==e))}}t.ReduceUtil=f;class m{static adjustPoolAttributes(e,t,n,r,s,a){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[e]>=n[e]||a[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,s,a){if(a){if(s.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let i=0;i<e.length-2;i++)m.adjustPadAndReturnShape(e[i+2],t[i],n[i],r[i],s,i,i+e.length-2,a)}}static computePoolOutputShape(e,t,n,r,s,a,i){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const o=[t[0],t[1]];return m.computeShapeHelper(e,t,o,n,r,s,a,i),o}static computeConvOutputShape(e,t,n,r,s,a,i){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const o=[e[0],t[0]];return m.computeShapeHelper(!1,e,o,n,r,s,a,i),o}static computeShapeHelper(e,t,n,r,s,a,i,o){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(m.adjustPadAndReturnShape(t[e+2],r[e],s[e],a[e],i,e,e+t.length-2,o))}static adjustPadAndReturnShape(e,t,n,r,s,a,i,o){const l=n*(r-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+s[a]+s[i]-l)/t+1);switch(o){case"VALID":return s[a]=0,s[i]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return s[a]="SAME_LOWER"===o?Math.floor((n+1)/2):Math.floor(n/2),s[i]=n-s[a],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=m,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(e){return(new TextDecoder).decode(e)}},7967:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,s)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,a])=>{const i=n?n+e:e;if("object"==typeof a)(0,t.iterateExtraOptions)(a,i+".",r,s);else if("string"==typeof a||"number"==typeof a)s(i,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);s(i,a?"1":"0")}}))}},2157:function(e,t,n){"use strict";var r,s=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&s(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const o=n(1670),l=i(n(349)),u=n(6361),c=()=>!!o.env.wasm.proxy&&"undefined"!=typeof document;let d,h,p,f=!1,m=!1,g=!1;const b=[],y=[],w=[],v=[],x=[],_=[],k=()=>{if(f||!m||g||!d)throw new Error("worker not ready")},S=e=>{switch(e.data.type){case"init-wasm":f=!1,e.data.err?(g=!0,h[1](e.data.err)):(m=!0,h[0]());break;case"init-ort":e.data.err?p[1](e.data.err):p[0]();break;case"create_allocate":e.data.err?b.shift()[1](e.data.err):b.shift()[0](e.data.out);break;case"create_finalize":e.data.err?y.shift()[1](e.data.err):y.shift()[0](e.data.out);break;case"create":e.data.err?w.shift()[1](e.data.err):w.shift()[0](e.data.out);break;case"release":e.data.err?v.shift()[1](e.data.err):v.shift()[0]();break;case"run":e.data.err?x.shift()[1](e.data.err):x.shift()[0](e.data.out);break;case"end-profiling":e.data.err?_.shift()[1](e.data.err):_.shift()[0]()}},T="undefined"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;t.initWasm=async()=>{if(c()){if(m)return;if(f)throw new Error("multiple calls to 'initWasm()' detected.");if(g)throw new Error("previous call to 'initWasm()' failed.");return f=!0,void 0===o.env.wasm.wasmPaths&&T&&0!==T.indexOf("blob:")&&(o.env.wasm.wasmPaths=T.substr(0,+T.lastIndexOf("/")+1)),new Promise(((e,t)=>{null==d||d.terminate(),d=n(9710).Z(),d.onmessage=S,h=[e,t];const r={type:"init-wasm",in:o.env.wasm};d.postMessage(r)}))}return(0,u.initializeWebAssembly)(o.env.wasm)},t.initOrt=async(e,t)=>{if(c())return k(),new Promise(((n,r)=>{p=[n,r];const s={type:"init-ort",in:{numThreads:e,loggingLevel:t}};d.postMessage(s)}));l.initOrt(e,t)},t.createSessionAllocate=async e=>c()?(k(),new Promise(((t,n)=>{b.push([t,n]);const r={type:"create_allocate",in:{model:e}};d.postMessage(r,[e.buffer])}))):l.createSessionAllocate(e),t.createSessionFinalize=async(e,t)=>c()?(k(),new Promise(((n,r)=>{y.push([n,r]);const s={type:"create_finalize",in:{modeldata:e,options:t}};d.postMessage(s)}))):l.createSessionFinalize(e,t),t.createSession=async(e,t)=>c()?(k(),new Promise(((n,r)=>{w.push([n,r]);const s={type:"create",in:{model:e,options:t}};d.postMessage(s,[e.buffer])}))):l.createSession(e,t),t.releaseSession=async e=>{if(c())return k(),new Promise(((t,n)=>{v.push([t,n]);const r={type:"release",in:e};d.postMessage(r)}));l.releaseSession(e)},t.run=async(e,t,n,r,s)=>c()?(k(),new Promise(((a,i)=>{x.push([a,i]);const o={type:"run",in:{sessionId:e,inputIndices:t,inputs:n,outputIndices:r,options:s}};d.postMessage(o,l.extractTransferableBuffers(n))}))):l.run(e,t,n,r,s),t.endProfiling=async e=>{if(c())return k(),new Promise(((t,n)=>{_.push([t,n]);const r={type:"end-profiling",in:e};d.postMessage(r)}));l.endProfiling(e)}},586:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(7967),s=n(4983),a=n(6361);t.setRunOptions=e=>{const t=(0,a.getInstance)();let n=0;const i=[],o=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(o.terminate=!1);let a=0;if(void 0!==(null==e?void 0:e.tag)&&(a=(0,s.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),0===n)throw new Error("Can't create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const a=(0,s.allocWasmString)(e,i),o=(0,s.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,a,o))throw new Error(`Can't set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},2306:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),s=n(1670),a=n(2850),i=n(2157);let o;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(e){const t=await fetch(e),n=await t.arrayBuffer();return(0,i.createSessionAllocate)(new Uint8Array(n))}async loadModel(e,t){if(o||(await(0,i.initOrt)(s.env.wasm.numThreads,(e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}})(s.env.logLevel)),o=!0),"string"==typeof e)if("undefined"==typeof fetch){const n=await(0,a.promisify)(r.readFile)(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(n,t)}else{const n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSessionFinalize)(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(e,t)}async dispose(){return(0,i.releaseSession)(this.sessionId)}async run(e,t,n){const r=[],a=[];Object.entries(e).forEach((e=>{const t=e[0],n=e[1],s=this.inputNames.indexOf(t);if(-1===s)throw new Error(`invalid input '${t}'`);r.push(n),a.push(s)}));const o=[];Object.entries(t).forEach((e=>{const t=e[0],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);o.push(n)}));const l=await(0,i.run)(this.sessionId,a,r.map((e=>[e.type,e.dims,e.data])),o,n),u={};for(let e=0;e<l.length;e++)u[this.outputNames[o[e]]]=new s.Tensor(l[e][0],l[e][2],l[e][1]);return u}startProfiling(){}endProfiling(){(0,i.endProfiling)(this.sessionId)}}},4919:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(7967),s=n(4983),a=n(6361);t.setSessionOptions=e=>{const t=(0,a.getInstance)();let n=0;const i=[],o=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1")})(o);try{void 0===(null==e?void 0:e.graphOptimizationLevel)&&(o.graphOptimizationLevel="all");const l=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(o.graphOptimizationLevel);void 0===(null==e?void 0:e.enableCpuMemArena)&&(o.enableCpuMemArena=!0),void 0===(null==e?void 0:e.enableMemPattern)&&(o.enableMemPattern=!0),void 0===(null==e?void 0:e.executionMode)&&(o.executionMode="sequential");const u=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(o.executionMode);let c=0;if(void 0!==(null==e?void 0:e.logId)&&(c=(0,s.allocWasmString)(e.logId,i)),void 0===(null==e?void 0:e.logSeverityLevel))o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);if(void 0===(null==e?void 0:e.enableProfiling)&&(o.enableProfiling=!1),n=t._OrtCreateSessionOptions(l,!!o.enableCpuMemArena,!!o.enableMemPattern,u,!!o.enableProfiling,0,c,o.logSeverityLevel,o.logVerbosityLevel),0===n)throw new Error("Can't create session options");return(null==e?void 0:e.executionProviders)&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,s.allocWasmString)(t,n);if(0!==(0,a.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can't append execution provider: ${t}`)}})(n,e.executionProviders,i),void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const a=(0,s.allocWasmString)(e,i),o=(0,s.allocWasmString)(r,i);if(0!==t._OrtAddSessionConfigEntry(n,a,o))throw new Error(`Can't set a session config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),i.forEach(t._free),e}}},4983:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(6361);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),s=n.lengthBytesUTF8(e)+1,a=n._malloc(s);return n.stringToUTF8(e,a,s),t.push(a),a}},349:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(586),s=n(4919),a=n(4983),i=n(6361);t.initOrt=(e,t)=>{const n=(0,i.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const o=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,i.getInstance)();let r=0,a=0,l=[];try{if([a,l]=(0,s.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],a),0===r)throw new Error("Can't create a session")}finally{n._free(e[0]),n._OrtReleaseSessionOptions(a),l.forEach(n._free)}const u=n._OrtGetInputCount(r),c=n._OrtGetOutputCount(r),d=[],h=[],p=[],f=[];for(let e=0;e<u;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can't get an input name");h.push(t),d.push(n.UTF8ToString(t))}for(let e=0;e<c;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can't get an output name");f.push(t),p.push(n.UTF8ToString(t))}return o.set(r,[r,h,f]),[r,d,p]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,i.getInstance)(),n=o.get(e);if(!n)throw new Error("invalid session id");const r=n[0],s=n[1],a=n[2];s.forEach(t._OrtFree),a.forEach(t._OrtFree),t._OrtReleaseSession(r),o.delete(e)};const l=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},u=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},c=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}};t.run=(e,t,n,s,d)=>{const h=(0,i.getInstance)(),p=o.get(e);if(!p)throw new Error("invalid session id");const f=p[0],m=p[1],g=p[2],b=t.length,y=s.length;let w=0,v=[];const x=[],_=[];try{[w,v]=(0,r.setRunOptions)(d);for(let e=0;e<b;e++){const t=n[e][0],r=n[e][1],s=n[e][2];let i,o;if(Array.isArray(s)){o=4*s.length,i=h._malloc(o),_.push(i);let e=i/4;for(let t=0;t<s.length;t++){if("string"!=typeof s[t])throw new TypeError(`tensor data at index ${t} is not a string`);h.HEAPU32[e++]=(0,a.allocWasmString)(s[t],_)}}else o=s.byteLength,i=h._malloc(o),_.push(i),h.HEAPU8.set(new Uint8Array(s.buffer,s.byteOffset,o),i);const u=h.stackSave(),c=h.stackAlloc(4*r.length);try{let e=c/4;r.forEach((t=>h.HEAP32[e++]=t));const n=h._OrtCreateTensor(l(t),i,o,c,r.length);if(0===n)throw new Error("Can't create a tensor");x.push(n)}finally{h.stackRestore(u)}}const e=h.stackSave(),i=h.stackAlloc(4*b),o=h.stackAlloc(4*b),p=h.stackAlloc(4*y),k=h.stackAlloc(4*y);try{let e=i/4,n=o/4,r=p/4,a=k/4;for(let r=0;r<b;r++)h.HEAPU32[e++]=x[r],h.HEAPU32[n++]=m[t[r]];for(let e=0;e<y;e++)h.HEAPU32[r++]=0,h.HEAPU32[a++]=g[s[e]];let l=h._OrtRun(f,o,i,b,k,y,p,w);const d=[];if(0===l)for(let e=0;e<y;e++){const t=h.HEAPU32[p/4+e],n=h.stackSave(),r=h.stackAlloc(16);let s,a=0;try{if(l=h._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==l)throw new Error(`Can't access output tensor data. error code = ${l}`);let e=r/4;const n=h.HEAPU32[e++];a=h.HEAPU32[e++];const i=h.HEAPU32[e++],o=h.HEAPU32[e++],p=[];for(let e=0;e<o;e++)p.push(h.HEAPU32[i/4+e]);h._OrtFree(i);const f=0===p.length?1:p.reduce(((e,t)=>e*t));if(s=u(n),"string"===s){const e=[];let t=a/4;for(let n=0;n<f;n++){const r=h.HEAPU32[t++],s=n===f-1?void 0:h.HEAPU32[t]-r;e.push(h.UTF8ToString(r,s))}d.push([s,p,e])}else{const e=new(c(s))(f);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(h.HEAPU8.subarray(a,a+e.byteLength)),d.push([s,p,e])}}finally{h.stackRestore(n),"string"===s&&a&&h._free(a),h._OrtReleaseTensor(t)}}if(0===l)return d;throw new Error(`failed to call OrtRun(). error code = ${l}.`)}finally{h.stackRestore(e)}}finally{x.forEach(h._OrtReleaseTensor),_.forEach(h._free),h._OrtReleaseRunOptions(w),v.forEach(h._free)}},t.endProfiling=e=>{const t=(0,i.getInstance)(),n=o.get(e);if(!n)throw new Error("invalid session id");const r=n[0],s=t._OrtEndProfiling(r);if(0===s)throw new Error("Can't get an profile file name");t._OrtFree(s)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},6361:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const o=a(n(6449)),l=i(n(932)),u=n(3474);let c,d=!1,h=!1,p=!1;const f=(e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm";t.initializeWebAssembly=async e=>{if(d)return Promise.resolve();if(h)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(p)throw new Error("previous call to 'initializeWebAssembly()' failed.");h=!0;const t=e.initTimeout,r=e.numThreads,s=e.simd,a=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),i=s&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m="string"==typeof e.wasmPaths?e.wasmPaths:void 0,g=f(!1,a),b=f(i,a),y="object"==typeof e.wasmPaths?e.wasmPaths[b]:void 0;let w=!1;const v=[];if(t>0&&v.push(new Promise((e=>{setTimeout((()=>{w=!0,e()}),t)}))),v.push(new Promise(((e,t)=>{const r=a?u:l.default,s={locateFile:(e,t)=>a&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"})):e===g?null!=y?y:(null!=m?m:t)+b:t+e};if(a)if("undefined"==typeof Blob)s.mainScriptUrlOrBlob=o.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;s.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(s).then((t=>{h=!1,d=!0,c=t,e()}),(e=>{h=!1,p=!0,t(e)}))}))),await Promise.race(v),w)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(d&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!d||h||p||(h=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,h=!1,d=!1,p=!0)}},9710:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var r=n(477),s=n.n(r);function a(){return s()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:e=>{"use strict";e.exports=function(e,t,n,r){var s=self||window;try{try{var a;try{a=new s.Blob([e])}catch(t){(a=new(s.BlobBuilder||s.WebKitBlobBuilder||s.MozBlobBuilder||s.MSBlobBuilder)).append(e),a=a.getBlob()}var i=s.URL||s.webkitURL,o=i.createObjectURL(a),l=new s[t](o,n);return i.revokeObjectURL(o),l}catch(r){return new s[t]("data:application/javascript,".concat(encodeURIComponent(e)),n)}}catch(e){if(!r)throw Error("Inline worker is not supported");return new s[t](r,n)}}},4154:e=>{"use strict";e.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},1670:e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(e,t,n)=>{"use strict";n.r(t),n.d(t,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(e,t){this.low=0|e,this.high=0|t},r.Long.create=function(e,t){return 0==e&&0==t?r.Long.ZERO:new r.Long(e,t)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(e){if(e)t=e;else var t=1024;this.bb=r.ByteBuffer.allocate(t),this.space=t,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(e,t){e>this.minalign&&(this.minalign=e);for(var n=1+~(this.bb.capacity()-this.space+t)&e-1;this.space<n+e+t;){var s=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(n)},r.Builder.prototype.pad=function(e){for(var t=0;t<e;t++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},r.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},r.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},r.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},r.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},r.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},r.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},r.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},r.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},r.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},r.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},r.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},r.Builder.prototype.addFieldInt8=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt8(t),this.slot(e))},r.Builder.prototype.addFieldInt16=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt16(t),this.slot(e))},r.Builder.prototype.addFieldInt32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt32(t),this.slot(e))},r.Builder.prototype.addFieldInt64=function(e,t,n){!this.force_defaults&&t.equals(n)||(this.addInt64(t),this.slot(e))},r.Builder.prototype.addFieldFloat32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat32(t),this.slot(e))},r.Builder.prototype.addFieldFloat64=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat64(t),this.slot(e))},r.Builder.prototype.addFieldOffset=function(e,t,n){(this.force_defaults||t!=n)&&(this.addOffset(t),this.slot(e))},r.Builder.prototype.addFieldStruct=function(e,t,n){t!=n&&(this.nested(t),this.slot(e))},r.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(e){var t=e.capacity();if(3221225472&t)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=t<<1,s=r.ByteBuffer.allocate(n);return s.setPosition(n-t),s.bytes().set(e.bytes(),n-t),s},r.Builder.prototype.addOffset=function(e){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-e+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(e){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=e;for(var t=0;t<e;t++)this.vtable[t]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),t=this.vtable_in_use-1;t>=0&&0==this.vtable[t];t--);for(var n=t+1;t>=0;t--)this.addInt16(0!=this.vtable[t]?e-this.vtable[t]:0);this.addInt16(e-this.object_start);var s=(n+2)*r.SIZEOF_SHORT;this.addInt16(s);var a=0,i=this.space;e:for(t=0;t<this.vtables.length;t++){var o=this.bb.capacity()-this.vtables[t];if(s==this.bb.readInt16(o)){for(var l=r.SIZEOF_SHORT;l<s;l+=r.SIZEOF_SHORT)if(this.bb.readInt16(i+l)!=this.bb.readInt16(o+l))continue e;a=this.vtables[t];break}}return a?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,a-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},r.Builder.prototype.finish=function(e,t,n){var s=n?r.SIZE_PREFIX_LENGTH:0;if(t){var a=t;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+s),a.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var i=r.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(a.charCodeAt(i))}this.prep(this.minalign,r.SIZEOF_INT+s),this.addOffset(e),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(e,t){this.finish(e,t,!0)},r.Builder.prototype.requiredField=function(e,t){var n=this.bb.capacity()-e,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+t))throw new Error("FlatBuffers: field "+t+" must be set")},r.Builder.prototype.startVector=function(e,t,n){this.notNested(),this.vector_num_elems=t,this.prep(r.SIZEOF_INT,e*t),this.prep(n,e*t)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var t=e;else{t=[];for(var n=0;n<e.length;){var r,s=e.charCodeAt(n++);(r=s<55296||s>=56320?s:(s<<10)+e.charCodeAt(n++)+-56613888)<128?t.push(r):(r<2048?t.push(r>>6&31|192):(r<65536?t.push(r>>12&15|224):t.push(r>>18&7|240,r>>12&63|128),t.push(r>>6&63|128)),t.push(63&r|128))}}this.addInt8(0),this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),n=0;for(var a=this.space,i=this.bb.bytes();n<t.length;n++)i[a++]=t[n];return this.endVector()},r.Builder.prototype.createLong=function(e,t){return r.Long.create(e,t)},r.ByteBuffer=function(e){this.bytes_=e,this.position_=0},r.ByteBuffer.allocate=function(e){return new r.ByteBuffer(new Uint8Array(e))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(e){this.position_=e},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},r.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},r.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},r.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},r.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},r.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},r.ByteBuffer.prototype.readInt64=function(e){return new r.Long(this.readInt32(e),this.readInt32(e+4))},r.ByteBuffer.prototype.readUint64=function(e){return new r.Long(this.readUint32(e),this.readUint32(e+4))},r.ByteBuffer.prototype.readFloat32=function(e){return r.int32[0]=this.readInt32(e),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(e){return r.int32[r.isLittleEndian?0:1]=this.readInt32(e),r.int32[r.isLittleEndian?1:0]=this.readInt32(e+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeUint8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeInt16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeUint16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeInt32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeUint32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeInt64=function(e,t){this.writeInt32(e,t.low),this.writeInt32(e+4,t.high)},r.ByteBuffer.prototype.writeUint64=function(e,t){this.writeUint32(e,t.low),this.writeUint32(e+4,t.high)},r.ByteBuffer.prototype.writeFloat32=function(e,t){r.float32[0]=t,this.writeInt32(e,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(e,t){r.float64[0]=t,this.writeInt32(e,r.int32[r.isLittleEndian?0:1]),this.writeInt32(e+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)e+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+t));return e},r.ByteBuffer.prototype.__offset=function(e,t){var n=e-this.readInt32(e);return t<this.readInt16(n)?this.readInt16(n+t):0},r.ByteBuffer.prototype.__union=function(e,t){return e.bb_pos=t+this.readInt32(t),e.bb=this,e},r.ByteBuffer.prototype.__string=function(e,t){e+=this.readInt32(e);var n=this.readInt32(e),s="",a=0;if(e+=r.SIZEOF_INT,t===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+n);for(;a<n;){var i,o=this.readUint8(e+a++);if(o<192)i=o;else{var l=this.readUint8(e+a++);if(o<224)i=(31&o)<<6|63&l;else{var u=this.readUint8(e+a++);i=o<240?(15&o)<<12|(63&l)<<6|63&u:(7&o)<<18|(63&l)<<12|(63&u)<<6|63&this.readUint8(e+a++)}}i<65536?s+=String.fromCharCode(i):(i-=65536,s+=String.fromCharCode(55296+(i>>10),56320+(1023&i)))}return s},r.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},r.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},r.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)if(e.charCodeAt(t)!=this.readInt8(this.position_+r.SIZEOF_INT+t))return!1;return!0},r.ByteBuffer.prototype.createLong=function(e,t){return r.Long.create(e,t)}}},__webpack_module_cache__={};function __nested_webpack_require_546802__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__nested_webpack_require_546802__),n.exports}__nested_webpack_require_546802__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __nested_webpack_require_546802__.d(t,{a:t}),t},__nested_webpack_require_546802__.d=(e,t)=>{for(var n in t)__nested_webpack_require_546802__.o(t,n)&&!__nested_webpack_require_546802__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__nested_webpack_require_546802__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__nested_webpack_require_546802__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__nested_webpack_require_546802__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_546802__(6018);return __nested_webpack_exports__})(),module.exports=e(__webpack_require__(6409))},7045:(e,t,n)=>{"use strict";var r=n(7810),s=n(2328);function a(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var c=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,r,s,a,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=a,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function y(e){return e[1].toUpperCase()}function w(e,t,n,r){var s=g.hasOwnProperty(t)?g[t]:null;(null!==s?0!==s.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null==t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,s,r)&&(n=null),r||null===s?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=null===n?3!==s.type&&"":n:(t=s.attributeName,r=s.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(s=s.type)||4===s&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(b,y);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var v=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=Symbol.for("react.element"),_=Symbol.for("react.portal"),k=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),T=Symbol.for("react.profiler"),I=Symbol.for("react.provider"),E=Symbol.for("react.context"),A=Symbol.for("react.forward_ref"),C=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),$=Symbol.for("react.memo"),O=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var F=Symbol.iterator;function R(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=F&&e[F]||e["@@iterator"])?e:null}var M,L=Object.assign;function P(e){if(void 0===M)try{throw Error()}catch(e){var t=e.stack.trim().match(/\n( *(at )?)/);M=t&&t[1]||""}return"\n"+M+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(e){var r=e}Reflect.construct(e,[],t)}else{try{t.call()}catch(e){r=e}e.call(t.prototype)}else{try{throw Error()}catch(e){r=e}e()}}catch(t){if(t&&r&&"string"==typeof t.stack){for(var s=t.stack.split("\n"),a=r.stack.split("\n"),i=s.length-1,o=a.length-1;1<=i&&0<=o&&s[i]!==a[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==a[o]){if(1!==i||1!==o)do{if(i--,0>--o||s[i]!==a[o]){var l="\n"+s[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=i&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?P(e):""}function V(e){switch(e.tag){case 5:return P(e.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return B(e.type,!1);case 11:return B(e.type.render,!1);case 1:return B(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case k:return"Fragment";case _:return"Portal";case T:return"Profiler";case S:return"StrictMode";case C:return"Suspense";case N:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case E:return(e.displayName||"Context")+".Consumer";case I:return(e._context.displayName||"Context")+".Provider";case A:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case $:return null!==(t=e.displayName||null)?t:U(e.type)||"Memo";case O:t=e._payload,e=e._init;try{return U(e(t))}catch(e){}}return null}function j(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(t);case 8:return t===S?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof t)return t.displayName||t.name||null;if("string"==typeof t)return t}return null}function W(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function H(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function Z(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function K(e,t){var n=t.checked;return L({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=W(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function X(e,t){null!=(t=t.checked)&&w(e,"checked",t,!1)}function Q(e,t){X(e,t);var n=W(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,W(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function J(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&Z(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+W(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(a(91));return L({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function se(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(a(92));if(te(n)){if(1<n.length)throw Error(a(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:W(n)}}function ae(e,t){var n=W(t.value),r=W(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,de=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"==typeof t||""===t?"":n||"number"!=typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),s=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var be=L({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ye(e,t){if(t){if(be[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(a(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(a(60));if("object"!=typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=t.style&&"object"!=typeof t.style)throw Error(a(62))}}function we(e,t){if(-1===e.indexOf("-"))return"string"==typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ve=null;function xe(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var _e=null,ke=null,Se=null;function Te(e){if(e=ws(e)){if("function"!=typeof _e)throw Error(a(280));var t=e.stateNode;t&&(t=xs(t),_e(e.stateNode,e.type,t))}}function Ie(e){ke?Se?Se.push(e):Se=[e]:ke=e}function Ee(){if(ke){var e=ke,t=Se;if(Se=ke=null,Te(e),t)for(e=0;e<t.length;e++)Te(t[e])}}function Ae(e,t){return e(t)}function Ce(){}var Ne=!1;function $e(e,t,n){if(Ne)return e(t,n);Ne=!0;try{return Ae(e,t,n)}finally{Ne=!1,(null!==ke||null!==Se)&&(Ce(),Ee())}}function Oe(e,t){var n=e.stateNode;if(null===n)return null;var r=xs(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(a(231,t,typeof n));return n}var De=!1;if(c)try{var Fe={};Object.defineProperty(Fe,"passive",{get:function(){De=!0}}),window.addEventListener("test",Fe,Fe),window.removeEventListener("test",Fe,Fe)}catch(ce){De=!1}function Re(e,t,n,r,s,a,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(e){this.onError(e)}}var Me=!1,Le=null,Pe=!1,ze=null,Be={onError:function(e){Me=!0,Le=e}};function Ve(e,t,n,r,s,a,i,o,l){Me=!1,Le=null,Re.apply(Be,arguments)}function Ue(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{!!(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function je(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&null!==(e=e.alternate)&&(t=e.memoizedState),null!==t)return t.dehydrated}return null}function We(e){if(Ue(e)!==e)throw Error(a(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ue(e)))throw Error(a(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(null===s)break;var i=s.alternate;if(null===i){if(null!==(r=s.return)){n=r;continue}break}if(s.child===i.child){for(i=s.child;i;){if(i===n)return We(s),e;if(i===r)return We(s),t;i=i.sibling}throw Error(a(188))}if(n.return!==r.return)n=s,r=i;else{for(var o=!1,l=s.child;l;){if(l===n){o=!0,n=s,r=i;break}if(l===r){o=!0,r=s,n=i;break}l=l.sibling}if(!o){for(l=i.child;l;){if(l===n){o=!0,n=i,r=s;break}if(l===r){o=!0,r=i,n=s;break}l=l.sibling}if(!o)throw Error(a(189))}}if(n.alternate!==r)throw Error(a(190))}if(3!==n.tag)throw Error(a(188));return n.stateNode.current===n?e:t}(e))?He(e):null}function He(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=He(e);if(null!==t)return t;e=e.sibling}return null}var qe=s.unstable_scheduleCallback,Ze=s.unstable_cancelCallback,Ke=s.unstable_shouldYield,Ye=s.unstable_requestPaint,Xe=s.unstable_now,Qe=s.unstable_getCurrentPriorityLevel,Je=s.unstable_ImmediatePriority,et=s.unstable_UserBlockingPriority,tt=s.unstable_NormalPriority,nt=s.unstable_LowPriority,rt=s.unstable_IdlePriority,st=null,at=null,it=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2,ut=64,ct=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,s=e.suspendedLanes,a=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~s;0!==o?r=dt(o):0!=(a&=i)&&(r=dt(a))}else 0!=(i=n&~s)?r=dt(i):0!==a&&(r=dt(a));if(0===r)return 0;if(0!==t&&t!==r&&!(t&s)&&((s=r&-r)>=(a=t&-t)||16===s&&4194240&a))return t;if(4&r&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)s=1<<(n=31-it(t)),r|=e[n],t&=~s;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!=(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return!(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function bt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function yt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var wt=0;function vt(e){return 1<(e&=-e)?4<e?268435455&e?16:536870912:4:1}var xt,_t,kt,St,Tt,It=!1,Et=[],At=null,Ct=null,Nt=null,$t=new Map,Ot=new Map,Dt=[],Ft="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Rt(e,t){switch(e){case"focusin":case"focusout":At=null;break;case"dragenter":case"dragleave":Ct=null;break;case"mouseover":case"mouseout":Nt=null;break;case"pointerover":case"pointerout":$t.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ot.delete(t.pointerId)}}function Mt(e,t,n,r,s,a){return null===e||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},null!==t&&null!==(t=ws(t))&&_t(t),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function Lt(e){var t=ys(e.target);if(null!==t){var n=Ue(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=je(n)))return e.blockedOn=t,void Tt(e.priority,(function(){kt(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Pt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Kt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=ws(n))&&_t(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);ve=r,n.target.dispatchEvent(r),ve=null,t.shift()}return!0}function zt(e,t,n){Pt(e)&&n.delete(t)}function Bt(){It=!1,null!==At&&Pt(At)&&(At=null),null!==Ct&&Pt(Ct)&&(Ct=null),null!==Nt&&Pt(Nt)&&(Nt=null),$t.forEach(zt),Ot.forEach(zt)}function Vt(e,t){e.blockedOn===t&&(e.blockedOn=null,It||(It=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,Bt)))}function Ut(e){function t(t){return Vt(t,e)}if(0<Et.length){Vt(Et[0],e);for(var n=1;n<Et.length;n++){var r=Et[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==At&&Vt(At,e),null!==Ct&&Vt(Ct,e),null!==Nt&&Vt(Nt,e),$t.forEach(t),Ot.forEach(t),n=0;n<Dt.length;n++)(r=Dt[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Dt.length&&null===(n=Dt[0]).blockedOn;)Lt(n),null===n.blockedOn&&Dt.shift()}var jt=v.ReactCurrentBatchConfig,Wt=!0;function Gt(e,t,n,r){var s=wt,a=jt.transition;jt.transition=null;try{wt=1,qt(e,t,n,r)}finally{wt=s,jt.transition=a}}function Ht(e,t,n,r){var s=wt,a=jt.transition;jt.transition=null;try{wt=4,qt(e,t,n,r)}finally{wt=s,jt.transition=a}}function qt(e,t,n,r){if(Wt){var s=Kt(e,t,n,r);if(null===s)Wr(e,t,r,Zt,n),Rt(e,r);else if(function(e,t,n,r,s){switch(t){case"focusin":return At=Mt(At,e,t,n,r,s),!0;case"dragenter":return Ct=Mt(Ct,e,t,n,r,s),!0;case"mouseover":return Nt=Mt(Nt,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return $t.set(a,Mt($t.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,Ot.set(a,Mt(Ot.get(a)||null,e,t,n,r,s)),!0}return!1}(s,e,t,n,r))r.stopPropagation();else if(Rt(e,r),4&t&&-1<Ft.indexOf(e)){for(;null!==s;){var a=ws(s);if(null!==a&&xt(a),null===(a=Kt(e,t,n,r))&&Wr(e,t,r,Zt,n),a===s)break;s=a}null!==s&&r.stopPropagation()}else Wr(e,t,r,null,n)}}var Zt=null;function Kt(e,t,n,r){if(Zt=null,null!==(e=ys(e=xe(r))))if(null===(t=Ue(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=je(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Zt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qe()){case Je:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Xt=null,Qt=null,Jt=null;function en(){if(Jt)return Jt;var e,t,n=Qt,r=n.length,s="value"in Xt?Xt.value:Xt.textContent,a=s.length;for(e=0;e<r&&n[e]===s[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===s[a-t];t++);return Jt=s.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function sn(e){function t(t,n,r,s,a){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return L(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var an,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=sn(un),dn=L({},un,{view:0,detail:0}),hn=sn(dn),pn=L({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Tn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(an=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=an=0,ln=e),an)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=sn(pn),mn=sn(L({},pn,{dataTransfer:0})),gn=sn(L({},dn,{relatedTarget:0})),bn=sn(L({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),yn=L({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),wn=sn(yn),vn=sn(L({},un,{data:0})),xn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},_n={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},kn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=kn[e])&&!!t[e]}function Tn(){return Sn}var In=L({},dn,{key:function(e){if(e.key){var t=xn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?_n[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Tn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),En=sn(In),An=sn(L({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Cn=sn(L({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Tn})),Nn=sn(L({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),$n=L({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),On=sn($n),Dn=[9,13,27,32],Fn=c&&"CompositionEvent"in window,Rn=null;c&&"documentMode"in document&&(Rn=document.documentMode);var Mn=c&&"TextEvent"in window&&!Rn,Ln=c&&(!Fn||Rn&&8<Rn&&11>=Rn),Pn=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==Dn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vn(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Un=!1,jn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Wn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!jn[e.type]:"textarea"===t}function Gn(e,t,n,r){Ie(r),0<(t=Hr(t,"onChange")).length&&(n=new cn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hn=null,qn=null;function Zn(e){Pr(e,0)}function Kn(e){if(q(vs(e)))return e}function Yn(e,t){if("change"===e)return t}var Xn=!1;if(c){var Qn;if(c){var Jn="oninput"in document;if(!Jn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Jn="function"==typeof er.oninput}Qn=Jn}else Qn=!1;Xn=Qn&&(!document.documentMode||9<document.documentMode)}function tr(){Hn&&(Hn.detachEvent("onpropertychange",nr),qn=Hn=null)}function nr(e){if("value"===e.propertyName&&Kn(qn)){var t=[];Gn(t,qn,e,xe(e)),$e(Zn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(Hn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function sr(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Kn(qn)}function ar(e,t){if("click"===e)return Kn(t)}function ir(e,t){if("input"===e||"change"===e)return Kn(t)}var or="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t};function lr(e,t){if(or(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!d.call(t,s)||!or(e[s],t[s]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function dr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=Z();t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(e){n=!1}if(!n)break;t=Z((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=hr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&dr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var s=n.textContent.length,a=Math.min(r.start,s);r=void 0===r.end?a:Math.min(r.end,s),!e.extend&&a>r&&(s=r,r=a,a=s),s=cr(n,a);var i=cr(n,r);s&&i&&(1!==e.rangeCount||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(s.node,s.offset),e.removeAllRanges(),a>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"==typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=c&&"documentMode"in document&&11>=document.documentMode,gr=null,br=null,yr=null,wr=!1;function vr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;wr||null==gr||gr!==Z(r)||(r="selectionStart"in(r=gr)&&pr(r)?{start:r.selectionStart,end:r.selectionEnd}:{anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},yr&&lr(yr,r)||(yr=r,0<(r=Hr(br,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function xr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var _r={animationend:xr("Animation","AnimationEnd"),animationiteration:xr("Animation","AnimationIteration"),animationstart:xr("Animation","AnimationStart"),transitionend:xr("Transition","TransitionEnd")},kr={},Sr={};function Tr(e){if(kr[e])return kr[e];if(!_r[e])return e;var t,n=_r[e];for(t in n)if(n.hasOwnProperty(t)&&t in Sr)return kr[e]=n[t];return e}c&&(Sr=document.createElement("div").style,"AnimationEvent"in window||(delete _r.animationend.animation,delete _r.animationiteration.animation,delete _r.animationstart.animation),"TransitionEvent"in window||delete _r.transitionend.transition);var Ir=Tr("animationend"),Er=Tr("animationiteration"),Ar=Tr("animationstart"),Cr=Tr("transitionend"),Nr=new Map,$r="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Or(e,t){Nr.set(e,t),l(t,[e])}for(var Dr=0;Dr<$r.length;Dr++){var Fr=$r[Dr];Or(Fr.toLowerCase(),"on"+(Fr[0].toUpperCase()+Fr.slice(1)))}Or(Ir,"onAnimationEnd"),Or(Er,"onAnimationIteration"),Or(Ar,"onAnimationStart"),Or("dblclick","onDoubleClick"),Or("focusin","onFocus"),Or("focusout","onBlur"),Or(Cr,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Rr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Mr=new Set("cancel close invalid load scroll toggle".split(" ").concat(Rr));function Lr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,s,i,o,l,u){if(Ve.apply(this,arguments),Me){if(!Me)throw Error(a(198));var c=Le;Me=!1,Le=null,Pe||(Pe=!0,ze=c)}}(r,t,void 0,e),e.currentTarget=null}function Pr(e,t){t=!!(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;Lr(s,o,u),a=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;Lr(s,o,u),a=l}}}if(Pe)throw e=ze,Pe=!1,ze=null,e}function zr(e,t){var n=t[ms];void 0===n&&(n=t[ms]=new Set);var r=e+"__bubble";n.has(r)||(jr(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),jr(n,e,r,t)}var Vr="_reactListening"+Math.random().toString(36).slice(2);function Ur(e){if(!e[Vr]){e[Vr]=!0,i.forEach((function(t){"selectionchange"!==t&&(Mr.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Vr]||(t[Vr]=!0,Br("selectionchange",!1,t))}}function jr(e,t,n,r){switch(Yt(t)){case 1:var s=Gt;break;case 4:s=Ht;break;default:s=qt}n=s.bind(null,t,n,e),s=void 0,!De||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Wr(e,t,n,r,s){var a=r;if(!(1&t||2&t||null===r))e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===s||8===o.nodeType&&o.parentNode===s)break;if(4===i)for(i=r.return;null!==i;){var l=i.tag;if((3===l||4===l)&&((l=i.stateNode.containerInfo)===s||8===l.nodeType&&l.parentNode===s))return;i=i.return}for(;null!==o;){if(null===(i=ys(o)))return;if(5===(l=i.tag)||6===l){r=a=i;continue e}o=o.parentNode}}r=r.return}$e((function(){var r=a,s=xe(n),i=[];e:{var o=Nr.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=En;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=Cn;break;case Ir:case Er:case Ar:l=bn;break;case Cr:l=Nn;break;case"scroll":l=hn;break;case"wheel":l=On;break;case"copy":case"cut":case"paste":l=wn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=An}var c=!!(4&t),d=!c&&"scroll"===e,h=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=r;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&null!=(m=Oe(f,h))&&c.push(Gr(f,m,p))),d)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,s),i.push({event:o,listeners:c}))}}if(!(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===ve||!(u=n.relatedTarget||n.fromElement)||!ys(u)&&!u[fs])&&(l||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?ys(u):null)&&(u!==(d=Ue(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(c=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=An,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==l?o:vs(l),p=null==u?o:vs(u),(o=new c(m,f+"leave",l,n,s)).target=d,o.relatedTarget=p,m=null,ys(s)===r&&((c=new c(h,f+"enter",u,n,s)).target=p,c.relatedTarget=d,m=c),d=m,l&&u)e:{for(h=u,f=0,p=c=l;p;p=qr(p))f++;for(p=0,m=h;m;m=qr(m))p++;for(;0<f-p;)c=qr(c),f--;for(;0<p-f;)h=qr(h),p--;for(;f--;){if(c===h||null!==h&&c===h.alternate)break e;c=qr(c),h=qr(h)}c=null}else c=null;null!==l&&Zr(i,o,l,c,!1),null!==u&&null!==d&&Zr(i,d,u,c,!0)}if("select"===(l=(o=r?vs(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Yn;else if(Wn(o))if(Xn)g=ir;else{g=sr;var b=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=ar);switch(g&&(g=g(e,r))?Gn(i,g,n,s):(b&&b(e,o,r),"focusout"===e&&(b=o._wrapperState)&&b.controlled&&"number"===o.type&&ee(o,"number",o.value)),b=r?vs(r):window,e){case"focusin":(Wn(b)||"true"===b.contentEditable)&&(gr=b,br=r,yr=null);break;case"focusout":yr=br=gr=null;break;case"mousedown":wr=!0;break;case"contextmenu":case"mouseup":case"dragend":wr=!1,vr(i,n,s);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":vr(i,n,s)}var y;if(Fn)e:{switch(e){case"compositionstart":var w="onCompositionStart";break e;case"compositionend":w="onCompositionEnd";break e;case"compositionupdate":w="onCompositionUpdate";break e}w=void 0}else Un?Bn(e,n)&&(w="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(w="onCompositionStart");w&&(Ln&&"ko"!==n.locale&&(Un||"onCompositionStart"!==w?"onCompositionEnd"===w&&Un&&(y=en()):(Qt="value"in(Xt=s)?Xt.value:Xt.textContent,Un=!0)),0<(b=Hr(r,w)).length&&(w=new vn(w,e,null,n,s),i.push({event:w,listeners:b}),(y||null!==(y=Vn(n)))&&(w.data=y))),(y=Mn?function(e,t){switch(e){case"compositionend":return Vn(t);case"keypress":return 32!==t.which?null:(zn=!0,Pn);case"textInput":return(e=t.data)===Pn&&zn?null:e;default:return null}}(e,n):function(e,t){if(Un)return"compositionend"===e||!Fn&&Bn(e,t)?(e=en(),Jt=Qt=Xt=null,Un=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ln&&"ko"!==t.locale?null:t.data}}(e,n))&&0<(r=Hr(r,"onBeforeInput")).length&&(s=new vn("onBeforeInput","beforeinput",null,n,s),i.push({event:s,listeners:r}),s.data=y)}Pr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Hr(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,a=s.stateNode;5===s.tag&&null!==a&&(s=a,null!=(a=Oe(e,n))&&r.unshift(Gr(e,a,s)),null!=(a=Oe(e,t))&&r.push(Gr(e,a,s))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Zr(e,t,n,r,s){for(var a=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,s?null!=(l=Oe(n,a))&&i.unshift(Gr(n,l,o)):s||null!=(l=Oe(n,a))&&i.push(Gr(n,l,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Kr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Xr(e){return("string"==typeof e?e:""+e).replace(Kr,"\n").replace(Yr,"")}function Qr(e,t,n){if(t=Xr(t),Xr(e)!==t&&n)throw Error(a(425))}function Jr(){}var es=null,ts=null;function ns(e,t){return"textarea"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var rs="function"==typeof setTimeout?setTimeout:void 0,ss="function"==typeof clearTimeout?clearTimeout:void 0,as="function"==typeof Promise?Promise:void 0,is="function"==typeof queueMicrotask?queueMicrotask:void 0!==as?function(e){return as.resolve(null).then(e).catch(os)}:rs;function os(e){setTimeout((function(){throw e}))}function ls(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&8===s.nodeType)if("/$"===(n=s.data)){if(0===r)return e.removeChild(s),void Ut(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=s}while(n);Ut(t)}function us(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function cs(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var ds=Math.random().toString(36).slice(2),hs="__reactFiber$"+ds,ps="__reactProps$"+ds,fs="__reactContainer$"+ds,ms="__reactEvents$"+ds,gs="__reactListeners$"+ds,bs="__reactHandles$"+ds;function ys(e){var t=e[hs];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fs]||n[hs]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=cs(e);null!==e;){if(n=e[hs])return n;e=cs(e)}return t}n=(e=n).parentNode}return null}function ws(e){return!(e=e[hs]||e[fs])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vs(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(a(33))}function xs(e){return e[ps]||null}var _s=[],ks=-1;function Ss(e){return{current:e}}function Ts(e){0>ks||(e.current=_s[ks],_s[ks]=null,ks--)}function Is(e,t){ks++,_s[ks]=e.current,e.current=t}var Es={},As=Ss(Es),Cs=Ss(!1),Ns=Es;function $s(e,t){var n=e.type.contextTypes;if(!n)return Es;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s,a={};for(s in n)a[s]=t[s];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function Os(e){return null!=e.childContextTypes}function Ds(){Ts(Cs),Ts(As)}function Fs(e,t,n){if(As.current!==Es)throw Error(a(168));Is(As,t),Is(Cs,n)}function Rs(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!=typeof r.getChildContext)return n;for(var s in r=r.getChildContext())if(!(s in t))throw Error(a(108,j(e)||"Unknown",s));return L({},n,r)}function Ms(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Es,Ns=As.current,Is(As,e),Is(Cs,Cs.current),!0}function Ls(e,t,n){var r=e.stateNode;if(!r)throw Error(a(169));n?(e=Rs(e,t,Ns),r.__reactInternalMemoizedMergedChildContext=e,Ts(Cs),Ts(As),Is(As,e)):Ts(Cs),Is(Cs,n)}var Ps=null,zs=!1,Bs=!1;function Vs(e){null===Ps?Ps=[e]:Ps.push(e)}function Us(){if(!Bs&&null!==Ps){Bs=!0;var e=0,t=wt;try{var n=Ps;for(wt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}Ps=null,zs=!1}catch(t){throw null!==Ps&&(Ps=Ps.slice(e+1)),qe(Je,Us),t}finally{wt=t,Bs=!1}}return null}var js=[],Ws=0,Gs=null,Hs=0,qs=[],Zs=0,Ks=null,Ys=1,Xs="";function Qs(e,t){js[Ws++]=Hs,js[Ws++]=Gs,Gs=e,Hs=t}function Js(e,t,n){qs[Zs++]=Ys,qs[Zs++]=Xs,qs[Zs++]=Ks,Ks=e;var r=Ys;e=Xs;var s=32-it(r)-1;r&=~(1<<s),n+=1;var a=32-it(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,Ys=1<<32-it(t)+s|n<<s|r,Xs=a+e}else Ys=1<<a|n<<s|r,Xs=e}function ea(e){null!==e.return&&(Qs(e,1),Js(e,1,0))}function ta(e){for(;e===Gs;)Gs=js[--Ws],js[Ws]=null,Hs=js[--Ws],js[Ws]=null;for(;e===Ks;)Ks=qs[--Zs],qs[Zs]=null,Xs=qs[--Zs],qs[Zs]=null,Ys=qs[--Zs],qs[Zs]=null}var na=null,ra=null,sa=!1,aa=null;function ia(e,t){var n=Ou(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function oa(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,na=e,ra=us(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,na=e,ra=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Ks?{id:Ys,overflow:Xs}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Ou(18,null,null,0)).stateNode=t,n.return=e,e.child=n,na=e,ra=null,!0);default:return!1}}function la(e){return!(!(1&e.mode)||128&e.flags)}function ua(e){if(sa){var t=ra;if(t){var n=t;if(!oa(e,t)){if(la(e))throw Error(a(418));t=us(n.nextSibling);var r=na;t&&oa(e,t)?ia(r,n):(e.flags=-4097&e.flags|2,sa=!1,na=e)}}else{if(la(e))throw Error(a(418));e.flags=-4097&e.flags|2,sa=!1,na=e}}}function ca(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;na=e}function da(e){if(e!==na)return!1;if(!sa)return ca(e),sa=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!ns(e.type,e.memoizedProps)),t&&(t=ra)){if(la(e))throw ha(),Error(a(418));for(;t;)ia(e,t),t=us(t.nextSibling)}if(ca(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(a(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ra=us(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ra=null}}else ra=na?us(e.stateNode.nextSibling):null;return!0}function ha(){for(var e=ra;e;)e=us(e.nextSibling)}function pa(){ra=na=null,sa=!1}function fa(e){null===aa?aa=[e]:aa.push(e)}var ma=v.ReactCurrentBatchConfig;function ga(e,t){if(e&&e.defaultProps){for(var n in t=L({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}var ba=Ss(null),ya=null,wa=null,va=null;function xa(){va=wa=ya=null}function _a(e){var t=ba.current;Ts(ba),e._currentValue=t}function ka(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Sa(e,t){ya=e,va=wa=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(!!(e.lanes&t)&&(vo=!0),e.firstContext=null)}function Ta(e){var t=e._currentValue;if(va!==e)if(e={context:e,memoizedValue:t,next:null},null===wa){if(null===ya)throw Error(a(308));wa=e,ya.dependencies={lanes:0,firstContext:e}}else wa=wa.next=e;return t}var Ia=null;function Ea(e){null===Ia?Ia=[e]:Ia.push(e)}function Aa(e,t,n,r){var s=t.interleaved;return null===s?(n.next=n,Ea(t)):(n.next=s.next,s.next=n),t.interleaved=n,Ca(e,r)}function Ca(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Na=!1;function $a(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Oa(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Da(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Fa(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,2&Cl){var s=r.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),r.pending=t,Ca(e,n)}return null===(s=r.interleaved)?(t.next=t,Ea(r)):(t.next=s.next,s.next=t),r.interleaved=t,Ca(e,n)}function Ra(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,yt(e,n)}}function Ma(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===a?s=a=i:a=a.next=i,n=n.next}while(null!==n);null===a?s=a=t:a=a.next=t}else s=a=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function La(e,t,n,r){var s=e.updateQueue;Na=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?a=u:i.next=u,i=l;var c=e.alternate;null!==c&&(o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l)}if(null!==a){var d=s.baseState;for(i=0,c=u=l=null,o=a;;){var h=o.lane,p=o.eventTime;if((r&h)===h){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if("function"==typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null==(h="function"==typeof(f=m.payload)?f.call(p,d,h):f))break e;d=L({},d,h);break e;case 2:Na=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(h=s.effects)?s.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=d):c=c.next=p,i|=h;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(h=o).next,h.next=null,s.lastBaseUpdate=h,s.shared.pending=null}}if(null===c&&(l=d),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,null!==(t=s.shared.interleaved)){s=t;do{i|=s.lane,s=s.next}while(s!==t)}else null===a&&(s.shared.lanes=0);Ll|=i,e.lanes=i,e.memoizedState=d}}function Pa(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(null!==s){if(r.callback=null,r=n,"function"!=typeof s)throw Error(a(191,s));s.call(r)}}}var za=(new r.Component).refs;function Ba(e,t,n,r){n=null==(n=n(r,t=e.memoizedState))?t:L({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var Va={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=tu(),s=nu(e),a=Da(r,s);a.payload=t,null!=n&&(a.callback=n),null!==(t=Fa(e,a,s))&&(ru(t,e,s,r),Ra(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=tu(),s=nu(e),a=Da(r,s);a.tag=1,a.payload=t,null!=n&&(a.callback=n),null!==(t=Fa(e,a,s))&&(ru(t,e,s,r),Ra(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=tu(),r=nu(e),s=Da(n,r);s.tag=2,null!=t&&(s.callback=t),null!==(t=Fa(e,s,r))&&(ru(t,e,r,n),Ra(t,e,r))}};function Ua(e,t,n,r,s,a,i){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,a,i):!(t.prototype&&t.prototype.isPureReactComponent&&lr(n,r)&&lr(s,a))}function ja(e,t,n){var r=!1,s=Es,a=t.contextType;return"object"==typeof a&&null!==a?a=Ta(a):(s=Os(t)?Ns:As.current,a=(r=null!=(r=t.contextTypes))?$s(e,s):Es),t=new t(n,a),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=Va,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=a),t}function Wa(e,t,n,r){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&Va.enqueueReplaceState(t,t.state,null)}function Ga(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs=za,$a(e);var a=t.contextType;"object"==typeof a&&null!==a?s.context=Ta(a):(a=Os(t)?Ns:As.current,s.context=$s(e,a)),s.state=e.memoizedState,"function"==typeof(a=t.getDerivedStateFromProps)&&(Ba(e,t,a,n),s.state=e.memoizedState),"function"==typeof t.getDerivedStateFromProps||"function"==typeof s.getSnapshotBeforeUpdate||"function"!=typeof s.UNSAFE_componentWillMount&&"function"!=typeof s.componentWillMount||(t=s.state,"function"==typeof s.componentWillMount&&s.componentWillMount(),"function"==typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),t!==s.state&&Va.enqueueReplaceState(s,s.state,null),La(e,n,s,r),s.state=e.memoizedState),"function"==typeof s.componentDidMount&&(e.flags|=4194308)}function Ha(e,t,n){if(null!==(e=n.ref)&&"function"!=typeof e&&"object"!=typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(a(309));var r=n.stateNode}if(!r)throw Error(a(147,e));var s=r,i=""+e;return null!==t&&null!==t.ref&&"function"==typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=s.refs;t===za&&(t=s.refs={}),null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!=typeof e)throw Error(a(284));if(!n._owner)throw Error(a(290,e))}return e}function qa(e,t){throw e=Object.prototype.toString.call(t),Error(a(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Za(e){return(0,e._init)(e._payload)}function Ka(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function s(e,t){return(e=Fu(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Pu(n,e.mode,r)).return=e,t):((t=s(t,n)).return=e,t)}function u(e,t,n,r){var a=n.type;return a===k?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===a||"object"==typeof a&&null!==a&&a.$$typeof===O&&Za(a)===t.type)?((r=s(t,n.props)).ref=Ha(e,t,n),r.return=e,r):((r=Ru(n.type,n.key,n.props,null,e.mode,r)).ref=Ha(e,t,n),r.return=e,r)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=zu(n,e.mode,r)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function d(e,t,n,r,a){return null===t||7!==t.tag?((t=Mu(n,e.mode,r,a)).return=e,t):((t=s(t,n)).return=e,t)}function h(e,t,n){if("string"==typeof t&&""!==t||"number"==typeof t)return(t=Pu(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case x:return(n=Ru(t.type,t.key,t.props,null,e.mode,n)).ref=Ha(e,null,t),n.return=e,n;case _:return(t=zu(t,e.mode,n)).return=e,t;case O:return h(e,(0,t._init)(t._payload),n)}if(te(t)||R(t))return(t=Mu(t,e.mode,n,null)).return=e,t;qa(e,t)}return null}function p(e,t,n,r){var s=null!==t?t.key:null;if("string"==typeof n&&""!==n||"number"==typeof n)return null!==s?null:l(e,t,""+n,r);if("object"==typeof n&&null!==n){switch(n.$$typeof){case x:return n.key===s?u(e,t,n,r):null;case _:return n.key===s?c(e,t,n,r):null;case O:return p(e,t,(s=n._init)(n._payload),r)}if(te(n)||R(n))return null!==s?null:d(e,t,n,r,null);qa(e,n)}return null}function f(e,t,n,r,s){if("string"==typeof r&&""!==r||"number"==typeof r)return l(t,e=e.get(n)||null,""+r,s);if("object"==typeof r&&null!==r){switch(r.$$typeof){case x:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s);case _:return c(t,e=e.get(null===r.key?n:r.key)||null,r,s);case O:return f(e,t,n,(0,r._init)(r._payload),s)}if(te(r)||R(r))return d(t,e=e.get(n)||null,r,s,null);qa(t,r)}return null}function m(s,a,o,l){for(var u=null,c=null,d=a,m=a=0,g=null;null!==d&&m<o.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var b=p(s,d,o[m],l);if(null===b){null===d&&(d=g);break}e&&d&&null===b.alternate&&t(s,d),a=i(b,a,m),null===c?u=b:c.sibling=b,c=b,d=g}if(m===o.length)return n(s,d),sa&&Qs(s,m),u;if(null===d){for(;m<o.length;m++)null!==(d=h(s,o[m],l))&&(a=i(d,a,m),null===c?u=d:c.sibling=d,c=d);return sa&&Qs(s,m),u}for(d=r(s,d);m<o.length;m++)null!==(g=f(d,s,m,o[m],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),a=i(g,a,m),null===c?u=g:c.sibling=g,c=g);return e&&d.forEach((function(e){return t(s,e)})),sa&&Qs(s,m),u}function g(s,o,l,u){var c=R(l);if("function"!=typeof c)throw Error(a(150));if(null==(l=c.call(l)))throw Error(a(151));for(var d=c=null,m=o,g=o=0,b=null,y=l.next();null!==m&&!y.done;g++,y=l.next()){m.index>g?(b=m,m=null):b=m.sibling;var w=p(s,m,y.value,u);if(null===w){null===m&&(m=b);break}e&&m&&null===w.alternate&&t(s,m),o=i(w,o,g),null===d?c=w:d.sibling=w,d=w,m=b}if(y.done)return n(s,m),sa&&Qs(s,g),c;if(null===m){for(;!y.done;g++,y=l.next())null!==(y=h(s,y.value,u))&&(o=i(y,o,g),null===d?c=y:d.sibling=y,d=y);return sa&&Qs(s,g),c}for(m=r(s,m);!y.done;g++,y=l.next())null!==(y=f(m,s,g,y.value,u))&&(e&&null!==y.alternate&&m.delete(null===y.key?g:y.key),o=i(y,o,g),null===d?c=y:d.sibling=y,d=y);return e&&m.forEach((function(e){return t(s,e)})),sa&&Qs(s,g),c}return function e(r,a,i,l){if("object"==typeof i&&null!==i&&i.type===k&&null===i.key&&(i=i.props.children),"object"==typeof i&&null!==i){switch(i.$$typeof){case x:e:{for(var u=i.key,c=a;null!==c;){if(c.key===u){if((u=i.type)===k){if(7===c.tag){n(r,c.sibling),(a=s(c,i.props.children)).return=r,r=a;break e}}else if(c.elementType===u||"object"==typeof u&&null!==u&&u.$$typeof===O&&Za(u)===c.type){n(r,c.sibling),(a=s(c,i.props)).ref=Ha(r,c,i),a.return=r,r=a;break e}n(r,c);break}t(r,c),c=c.sibling}i.type===k?((a=Mu(i.props.children,r.mode,l,i.key)).return=r,r=a):((l=Ru(i.type,i.key,i.props,null,r.mode,l)).ref=Ha(r,a,i),l.return=r,r=l)}return o(r);case _:e:{for(c=i.key;null!==a;){if(a.key===c){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){n(r,a.sibling),(a=s(a,i.children||[])).return=r,r=a;break e}n(r,a);break}t(r,a),a=a.sibling}(a=zu(i,r.mode,l)).return=r,r=a}return o(r);case O:return e(r,a,(c=i._init)(i._payload),l)}if(te(i))return m(r,a,i,l);if(R(i))return g(r,a,i,l);qa(r,i)}return"string"==typeof i&&""!==i||"number"==typeof i?(i=""+i,null!==a&&6===a.tag?(n(r,a.sibling),(a=s(a,i)).return=r,r=a):(n(r,a),(a=Pu(i,r.mode,l)).return=r,r=a),o(r)):n(r,a)}}var Ya=Ka(!0),Xa=Ka(!1),Qa={},Ja=Ss(Qa),ei=Ss(Qa),ti=Ss(Qa);function ni(e){if(e===Qa)throw Error(a(174));return e}function ri(e,t){switch(Is(ti,t),Is(ei,e),Is(Ja,Qa),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ts(Ja),Is(Ja,t)}function si(){Ts(Ja),Ts(ei),Ts(ti)}function ai(e){ni(ti.current);var t=ni(Ja.current),n=le(t,e.type);t!==n&&(Is(ei,e),Is(Ja,n))}function ii(e){ei.current===e&&(Ts(Ja),Ts(ei))}var oi=Ss(0);function li(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(128&t.flags)return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ui=[];function ci(){for(var e=0;e<ui.length;e++)ui[e]._workInProgressVersionPrimary=null;ui.length=0}var di=v.ReactCurrentDispatcher,hi=v.ReactCurrentBatchConfig,pi=0,fi=null,mi=null,gi=null,bi=!1,yi=!1,wi=0,vi=0;function xi(){throw Error(a(321))}function _i(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function ki(e,t,n,r,s,i){if(pi=i,fi=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,di.current=null===e||null===e.memoizedState?io:oo,e=n(r,s),yi){i=0;do{if(yi=!1,wi=0,25<=i)throw Error(a(301));i+=1,gi=mi=null,t.updateQueue=null,di.current=lo,e=n(r,s)}while(yi)}if(di.current=ao,t=null!==mi&&null!==mi.next,pi=0,gi=mi=fi=null,bi=!1,t)throw Error(a(300));return e}function Si(){var e=0!==wi;return wi=0,e}function Ti(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===gi?fi.memoizedState=gi=e:gi=gi.next=e,gi}function Ii(){if(null===mi){var e=fi.alternate;e=null!==e?e.memoizedState:null}else e=mi.next;var t=null===gi?fi.memoizedState:gi.next;if(null!==t)gi=t,mi=e;else{if(null===e)throw Error(a(310));e={memoizedState:(mi=e).memoizedState,baseState:mi.baseState,baseQueue:mi.baseQueue,queue:mi.queue,next:null},null===gi?fi.memoizedState=gi=e:gi=gi.next=e}return gi}function Ei(e,t){return"function"==typeof t?t(e):t}function Ai(e){var t=Ii(),n=t.queue;if(null===n)throw Error(a(311));n.lastRenderedReducer=e;var r=mi,s=r.baseQueue,i=n.pending;if(null!==i){if(null!==s){var o=s.next;s.next=i.next,i.next=o}r.baseQueue=s=i,n.pending=null}if(null!==s){i=s.next,r=r.baseState;var l=o=null,u=null,c=i;do{var d=c.lane;if((pi&d)===d)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var h={lane:d,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=h,o=r):u=u.next=h,fi.lanes|=d,Ll|=d}c=c.next}while(null!==c&&c!==i);null===u?o=r:u.next=l,or(r,t.memoizedState)||(vo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){s=e;do{i=s.lane,fi.lanes|=i,Ll|=i,s=s.next}while(s!==e)}else null===s&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Ci(e){var t=Ii(),n=t.queue;if(null===n)throw Error(a(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,i=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{i=e(i,o.action),o=o.next}while(o!==s);or(i,t.memoizedState)||(vo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function Ni(){}function $i(e,t){var n=fi,r=Ii(),s=t(),i=!or(r.memoizedState,s);if(i&&(r.memoizedState=s,vo=!0),r=r.queue,ji(Fi.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==gi&&1&gi.memoizedState.tag){if(n.flags|=2048,Pi(9,Di.bind(null,n,r,s,t),void 0,null),null===Nl)throw Error(a(349));30&pi||Oi(n,t,s)}return s}function Oi(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=fi.updateQueue)?(t={lastEffect:null,stores:null},fi.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Di(e,t,n,r){t.value=n,t.getSnapshot=r,Ri(t)&&Mi(e)}function Fi(e,t,n){return n((function(){Ri(t)&&Mi(e)}))}function Ri(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(e){return!0}}function Mi(e){var t=Ca(e,1);null!==t&&ru(t,e,1,-1)}function Li(e){var t=Ti();return"function"==typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ei,lastRenderedState:e},t.queue=e,e=e.dispatch=to.bind(null,fi,e),[t.memoizedState,e]}function Pi(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=fi.updateQueue)?(t={lastEffect:null,stores:null},fi.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function zi(){return Ii().memoizedState}function Bi(e,t,n,r){var s=Ti();fi.flags|=e,s.memoizedState=Pi(1|t,n,void 0,void 0===r?null:r)}function Vi(e,t,n,r){var s=Ii();r=void 0===r?null:r;var a=void 0;if(null!==mi){var i=mi.memoizedState;if(a=i.destroy,null!==r&&_i(r,i.deps))return void(s.memoizedState=Pi(t,n,a,r))}fi.flags|=e,s.memoizedState=Pi(1|t,n,a,r)}function Ui(e,t){return Bi(8390656,8,e,t)}function ji(e,t){return Vi(2048,8,e,t)}function Wi(e,t){return Vi(4,2,e,t)}function Gi(e,t){return Vi(4,4,e,t)}function Hi(e,t){return"function"==typeof t?(e=e(),t(e),function(){t(null)}):null!=t?(e=e(),t.current=e,function(){t.current=null}):void 0}function qi(e,t,n){return n=null!=n?n.concat([e]):null,Vi(4,4,Hi.bind(null,t,e),n)}function Zi(){}function Ki(e,t){var n=Ii();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&_i(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Yi(e,t){var n=Ii();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&_i(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Xi(e,t,n){return 21&pi?(or(n,t)||(n=mt(),fi.lanes|=n,Ll|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=n)}function Qi(e,t){var n=wt;wt=0!==n&&4>n?n:4,e(!0);var r=hi.transition;hi.transition={};try{e(!1),t()}finally{wt=n,hi.transition=r}}function Ji(){return Ii().memoizedState}function eo(e,t,n){var r=nu(e);n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},no(e)?ro(t,n):null!==(n=Aa(e,t,n,r))&&(ru(n,e,r,tu()),so(n,t,r))}function to(e,t,n){var r=nu(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(no(e))ro(t,s);else{var a=e.alternate;if(0===e.lanes&&(null===a||0===a.lanes)&&null!==(a=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,or(o,i)){var l=t.interleaved;return null===l?(s.next=s,Ea(t)):(s.next=l.next,l.next=s),void(t.interleaved=s)}}catch(e){}null!==(n=Aa(e,t,s,r))&&(ru(n,e,r,s=tu()),so(n,t,r))}}function no(e){var t=e.alternate;return e===fi||null!==t&&t===fi}function ro(e,t){yi=bi=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function so(e,t,n){if(4194240&n){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,yt(e,n)}}var ao={readContext:Ta,useCallback:xi,useContext:xi,useEffect:xi,useImperativeHandle:xi,useInsertionEffect:xi,useLayoutEffect:xi,useMemo:xi,useReducer:xi,useRef:xi,useState:xi,useDebugValue:xi,useDeferredValue:xi,useTransition:xi,useMutableSource:xi,useSyncExternalStore:xi,useId:xi,unstable_isNewReconciler:!1},io={readContext:Ta,useCallback:function(e,t){return Ti().memoizedState=[e,void 0===t?null:t],e},useContext:Ta,useEffect:Ui,useImperativeHandle:function(e,t,n){return n=null!=n?n.concat([e]):null,Bi(4194308,4,Hi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Bi(4194308,4,e,t)},useInsertionEffect:function(e,t){return Bi(4,2,e,t)},useMemo:function(e,t){var n=Ti();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=Ti();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=eo.bind(null,fi,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},Ti().memoizedState=e},useState:Li,useDebugValue:Zi,useDeferredValue:function(e){return Ti().memoizedState=e},useTransition:function(){var e=Li(!1),t=e[0];return e=Qi.bind(null,e[1]),Ti().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=fi,s=Ti();if(sa){if(void 0===n)throw Error(a(407));n=n()}else{if(n=t(),null===Nl)throw Error(a(349));30&pi||Oi(r,t,n)}s.memoizedState=n;var i={value:n,getSnapshot:t};return s.queue=i,Ui(Fi.bind(null,r,i,e),[e]),r.flags|=2048,Pi(9,Di.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=Ti(),t=Nl.identifierPrefix;if(sa){var n=Xs;t=":"+t+"R"+(n=(Ys&~(1<<32-it(Ys)-1)).toString(32)+n),0<(n=wi++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=vi++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},oo={readContext:Ta,useCallback:Ki,useContext:Ta,useEffect:ji,useImperativeHandle:qi,useInsertionEffect:Wi,useLayoutEffect:Gi,useMemo:Yi,useReducer:Ai,useRef:zi,useState:function(){return Ai(Ei)},useDebugValue:Zi,useDeferredValue:function(e){return Xi(Ii(),mi.memoizedState,e)},useTransition:function(){return[Ai(Ei)[0],Ii().memoizedState]},useMutableSource:Ni,useSyncExternalStore:$i,useId:Ji,unstable_isNewReconciler:!1},lo={readContext:Ta,useCallback:Ki,useContext:Ta,useEffect:ji,useImperativeHandle:qi,useInsertionEffect:Wi,useLayoutEffect:Gi,useMemo:Yi,useReducer:Ci,useRef:zi,useState:function(){return Ci(Ei)},useDebugValue:Zi,useDeferredValue:function(e){var t=Ii();return null===mi?t.memoizedState=e:Xi(t,mi.memoizedState,e)},useTransition:function(){return[Ci(Ei)[0],Ii().memoizedState]},useMutableSource:Ni,useSyncExternalStore:$i,useId:Ji,unstable_isNewReconciler:!1};function uo(e,t){try{var n="",r=t;do{n+=V(r),r=r.return}while(r);var s=n}catch(e){s="\nError generating stack: "+e.message+"\n"+e.stack}return{value:e,source:t,stack:s,digest:null}}function co(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function ho(e,t){try{console.error(t.value)}catch(e){setTimeout((function(){throw e}))}}var po="function"==typeof WeakMap?WeakMap:Map;function fo(e,t,n){(n=Da(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Gl||(Gl=!0,Hl=r),ho(0,t)},n}function mo(e,t,n){(n=Da(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"==typeof r){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){ho(0,t)}}var a=e.stateNode;return null!==a&&"function"==typeof a.componentDidCatch&&(n.callback=function(){ho(0,t),"function"!=typeof r&&(null===ql?ql=new Set([this]):ql.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function go(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new po;var s=new Set;r.set(t,s)}else void 0===(s=r.get(t))&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=Iu.bind(null,e,t,n),t.then(e,e))}function bo(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,r,s){return 1&e.mode?(e.flags|=65536,e.lanes=s,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Da(-1,1)).tag=2,Fa(n,t,1))),n.lanes|=1),e)}var wo=v.ReactCurrentOwner,vo=!1;function xo(e,t,n,r){t.child=null===e?Xa(t,null,n,r):Ya(t,e.child,n,r)}function _o(e,t,n,r,s){n=n.render;var a=t.ref;return Sa(t,s),r=ki(e,t,n,r,a,s),n=Si(),null===e||vo?(sa&&n&&ea(t),t.flags|=1,xo(e,t,r,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Go(e,t,s))}function ko(e,t,n,r,s){if(null===e){var a=n.type;return"function"!=typeof a||Du(a)||void 0!==a.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Ru(n.type,null,r,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=a,So(e,t,a,r,s))}if(a=e.child,!(e.lanes&s)){var i=a.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(i,r)&&e.ref===t.ref)return Go(e,t,s)}return t.flags|=1,(e=Fu(a,r)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,r,s){if(null!==e){var a=e.memoizedProps;if(lr(a,r)&&e.ref===t.ref){if(vo=!1,t.pendingProps=r=a,!(e.lanes&s))return t.lanes=e.lanes,Go(e,t,s);131072&e.flags&&(vo=!0)}}return Eo(e,t,n,r,s)}function To(e,t,n){var r=t.pendingProps,s=r.children,a=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(1&t.mode){if(!(1073741824&n))return e=null!==a?a.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Is(Fl,Dl),Dl|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==a?a.baseLanes:n,Is(Fl,Dl),Dl|=r}else t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Is(Fl,Dl),Dl|=n;else null!==a?(r=a.baseLanes|n,t.memoizedState=null):r=n,Is(Fl,Dl),Dl|=r;return xo(e,t,s,n),t.child}function Io(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function Eo(e,t,n,r,s){var a=Os(n)?Ns:As.current;return a=$s(t,a),Sa(t,s),n=ki(e,t,n,r,a,s),r=Si(),null===e||vo?(sa&&r&&ea(t),t.flags|=1,xo(e,t,n,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Go(e,t,s))}function Ao(e,t,n,r,s){if(Os(n)){var a=!0;Ms(t)}else a=!1;if(Sa(t,s),null===t.stateNode)Wo(e,t),ja(t,n,r),Ga(t,n,r,s),r=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;u="object"==typeof u&&null!==u?Ta(u):$s(t,u=Os(n)?Ns:As.current);var c=n.getDerivedStateFromProps,d="function"==typeof c||"function"==typeof i.getSnapshotBeforeUpdate;d||"function"!=typeof i.UNSAFE_componentWillReceiveProps&&"function"!=typeof i.componentWillReceiveProps||(o!==r||l!==u)&&Wa(t,i,r,u),Na=!1;var h=t.memoizedState;i.state=h,La(t,r,i,s),l=t.memoizedState,o!==r||h!==l||Cs.current||Na?("function"==typeof c&&(Ba(t,n,c,r),l=t.memoizedState),(o=Na||Ua(t,n,o,r,h,l,u))?(d||"function"!=typeof i.UNSAFE_componentWillMount&&"function"!=typeof i.componentWillMount||("function"==typeof i.componentWillMount&&i.componentWillMount(),"function"==typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"==typeof i.componentDidMount&&(t.flags|=4194308)):("function"==typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):("function"==typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,Oa(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:ga(t.type,o),i.props=u,d=t.pendingProps,h=i.context,l="object"==typeof(l=n.contextType)&&null!==l?Ta(l):$s(t,l=Os(n)?Ns:As.current);var p=n.getDerivedStateFromProps;(c="function"==typeof p||"function"==typeof i.getSnapshotBeforeUpdate)||"function"!=typeof i.UNSAFE_componentWillReceiveProps&&"function"!=typeof i.componentWillReceiveProps||(o!==d||h!==l)&&Wa(t,i,r,l),Na=!1,h=t.memoizedState,i.state=h,La(t,r,i,s);var f=t.memoizedState;o!==d||h!==f||Cs.current||Na?("function"==typeof p&&(Ba(t,n,p,r),f=t.memoizedState),(u=Na||Ua(t,n,u,r,h,f,l)||!1)?(c||"function"!=typeof i.UNSAFE_componentWillUpdate&&"function"!=typeof i.componentWillUpdate||("function"==typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,l),"function"==typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,l)),"function"==typeof i.componentDidUpdate&&(t.flags|=4),"function"==typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!=typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!=typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):("function"!=typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!=typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return Co(e,t,n,r,a,s)}function Co(e,t,n,r,s,a){Io(e,t);var i=!!(128&t.flags);if(!r&&!i)return s&&Ls(t,n,!1),Go(e,t,a);r=t.stateNode,wo.current=t;var o=i&&"function"!=typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=Ya(t,e.child,null,a),t.child=Ya(t,null,o,a)):xo(e,t,o,a),t.memoizedState=r.state,s&&Ls(t,n,!0),t.child}function No(e){var t=e.stateNode;t.pendingContext?Fs(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Fs(0,t.context,!1),ri(e,t.containerInfo)}function $o(e,t,n,r,s){return pa(),fa(s),t.flags|=256,xo(e,t,n,r),t.child}var Oo,Do,Fo,Ro,Mo={dehydrated:null,treeContext:null,retryLane:0};function Lo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Po(e,t,n){var r,s=t.pendingProps,i=oi.current,o=!1,l=!!(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&!!(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Is(oi,1&i),null===e)return ua(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(1&t.mode?"$!"===e.data?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(l=s.children,e=s.fallback,o?(s=t.mode,o=t.child,l={mode:"hidden",children:l},1&s||null===o?o=Lu(l,s,0,null):(o.childLanes=0,o.pendingProps=l),e=Mu(e,s,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Lo(n),t.memoizedState=Mo,e):zo(t,l));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,s,i,o){if(n)return 256&t.flags?(t.flags&=-257,Bo(e,t,o,r=co(Error(a(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,s=t.mode,r=Lu({mode:"visible",children:r.children},s,0,null),(i=Mu(i,s,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,1&t.mode&&Ya(t,e.child,null,o),t.child.memoizedState=Lo(o),t.memoizedState=Mo,i);if(!(1&t.mode))return Bo(e,t,o,null);if("$!"===s.data){if(r=s.nextSibling&&s.nextSibling.dataset)var l=r.dgst;return r=l,Bo(e,t,o,r=co(i=Error(a(419)),r,void 0))}if(l=!!(o&e.childLanes),vo||l){if(null!==(r=Nl)){switch(o&-o){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}0!==(s=s&(r.suspendedLanes|o)?0:s)&&s!==i.retryLane&&(i.retryLane=s,Ca(e,s),ru(r,e,s,-1))}return gu(),Bo(e,t,o,r=co(Error(a(421))))}return"$?"===s.data?(t.flags|=128,t.child=e.child,t=Au.bind(null,e),s._reactRetry=t,null):(e=i.treeContext,ra=us(s.nextSibling),na=t,sa=!0,aa=null,null!==e&&(qs[Zs++]=Ys,qs[Zs++]=Xs,qs[Zs++]=Ks,Ys=e.id,Xs=e.overflow,Ks=t),(t=zo(t,r.children)).flags|=4096,t)}(e,t,l,s,r,i,n);if(o){o=s.fallback,l=t.mode,r=(i=e.child).sibling;var u={mode:"hidden",children:s.children};return 1&l||t.child===i?(s=Fu(i,u)).subtreeFlags=14680064&i.subtreeFlags:((s=t.child).childLanes=0,s.pendingProps=u,t.deletions=null),null!==r?o=Fu(r,o):(o=Mu(o,l,n,null)).flags|=2,o.return=t,s.return=t,s.sibling=o,t.child=s,s=o,o=t.child,l=null===(l=e.child.memoizedState)?Lo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Mo,s}return e=(o=e.child).sibling,s=Fu(o,{mode:"visible",children:s.children}),!(1&t.mode)&&(s.lanes=n),s.return=t,s.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=s,t.memoizedState=null,s}function zo(e,t){return(t=Lu({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function Bo(e,t,n,r){return null!==r&&fa(r),Ya(t,e.child,null,n),(e=zo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Vo(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),ka(e.return,t,n)}function Uo(e,t,n,r,s){var a=e.memoizedState;null===a?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function jo(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(xo(e,t,r.children,n),2&(r=oi.current))r=1&r|2,t.flags|=128;else{if(null!==e&&128&e.flags)e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Vo(e,n,t);else if(19===e.tag)Vo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Is(oi,r),1&t.mode)switch(s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===li(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),Uo(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===li(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}Uo(t,!0,n,null,a);break;case"together":Uo(t,!1,null,null,void 0);break;default:t.memoizedState=null}else t.memoizedState=null;return t.child}function Wo(e,t){!(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Go(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ll|=t.lanes,!(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(a(153));if(null!==t.child){for(n=Fu(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Fu(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Ho(e,t){if(!sa)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function qo(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=14680064&s.subtreeFlags,r|=14680064&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function Zo(e,t,n){var r=t.pendingProps;switch(ta(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qo(t),null;case 1:case 17:return Os(t.type)&&Ds(),qo(t),null;case 3:return r=t.stateNode,si(),Ts(Cs),Ts(As),ci(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(da(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&!(256&t.flags)||(t.flags|=1024,null!==aa&&(ou(aa),aa=null))),Do(e,t),qo(t),null;case 5:ii(t);var s=ni(ti.current);if(n=t.type,null!==e&&null!=t.stateNode)Fo(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(a(166));return qo(t),null}if(e=ni(Ja.current),da(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[hs]=t,r[ps]=i,e=!!(1&t.mode),n){case"dialog":zr("cancel",r),zr("close",r);break;case"iframe":case"object":case"embed":zr("load",r);break;case"video":case"audio":for(s=0;s<Rr.length;s++)zr(Rr[s],r);break;case"source":zr("error",r);break;case"img":case"image":case"link":zr("error",r),zr("load",r);break;case"details":zr("toggle",r);break;case"input":Y(r,i),zr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},zr("invalid",r);break;case"textarea":se(r,i),zr("invalid",r)}for(var l in ye(n,i),s=null,i)if(i.hasOwnProperty(l)){var u=i[l];"children"===l?"string"==typeof u?r.textContent!==u&&(!0!==i.suppressHydrationWarning&&Qr(r.textContent,u,e),s=["children",u]):"number"==typeof u&&r.textContent!==""+u&&(!0!==i.suppressHydrationWarning&&Qr(r.textContent,u,e),s=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zr("scroll",r)}switch(n){case"input":H(r),J(r,i,!0);break;case"textarea":H(r),ie(r);break;case"select":case"option":break;default:"function"==typeof i.onClick&&(r.onclick=Jr)}r=s,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===s.nodeType?s:s.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[hs]=t,e[ps]=r,Oo(e,t,!1,!1),t.stateNode=e;e:{switch(l=we(n,r),n){case"dialog":zr("cancel",e),zr("close",e),s=r;break;case"iframe":case"object":case"embed":zr("load",e),s=r;break;case"video":case"audio":for(s=0;s<Rr.length;s++)zr(Rr[s],e);s=r;break;case"source":zr("error",e),s=r;break;case"img":case"image":case"link":zr("error",e),zr("load",e),s=r;break;case"details":zr("toggle",e),s=r;break;case"input":Y(e,r),s=K(e,r),zr("invalid",e);break;case"option":default:s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=L({},r,{value:void 0}),zr("invalid",e);break;case"textarea":se(e,r),s=re(e,r),zr("invalid",e)}for(i in ye(n,s),u=s)if(u.hasOwnProperty(i)){var c=u[i];"style"===i?ge(e,c):"dangerouslySetInnerHTML"===i?null!=(c=c?c.__html:void 0)&&de(e,c):"children"===i?"string"==typeof c?("textarea"!==n||""!==c)&&he(e,c):"number"==typeof c&&he(e,""+c):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=c&&"onScroll"===i&&zr("scroll",e):null!=c&&w(e,i,c,l))}switch(n){case"input":H(e),J(e,r,!1);break;case"textarea":H(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+W(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"==typeof s.onClick&&(e.onclick=Jr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return qo(t),null;case 6:if(e&&null!=t.stateNode)Ro(e,t,e.memoizedProps,r);else{if("string"!=typeof r&&null===t.stateNode)throw Error(a(166));if(n=ni(ti.current),ni(Ja.current),da(t)){if(r=t.stateNode,n=t.memoizedProps,r[hs]=t,(i=r.nodeValue!==n)&&null!==(e=na))switch(e.tag){case 3:Qr(r.nodeValue,n,!!(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Qr(r.nodeValue,n,!!(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[hs]=t,t.stateNode=r}return qo(t),null;case 13:if(Ts(oi),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(sa&&null!==ra&&1&t.mode&&!(128&t.flags))ha(),pa(),t.flags|=98560,i=!1;else if(i=da(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(a(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(a(317));i[hs]=t}else pa(),!(128&t.flags)&&(t.memoizedState=null),t.flags|=4;qo(t),i=!1}else null!==aa&&(ou(aa),aa=null),i=!0;if(!i)return 65536&t.flags?t:null}return 128&t.flags?(t.lanes=n,t):((r=null!==r)!=(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,1&t.mode&&(null===e||1&oi.current?0===Rl&&(Rl=3):gu())),null!==t.updateQueue&&(t.flags|=4),qo(t),null);case 4:return si(),Do(e,t),null===e&&Ur(t.stateNode.containerInfo),qo(t),null;case 10:return _a(t.type._context),qo(t),null;case 19:if(Ts(oi),null===(i=t.memoizedState))return qo(t),null;if(r=!!(128&t.flags),null===(l=i.rendering))if(r)Ho(i,!1);else{if(0!==Rl||null!==e&&128&e.flags)for(e=t.child;null!==e;){if(null!==(l=li(e))){for(t.flags|=128,Ho(i,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Is(oi,1&oi.current|2),t.child}e=e.sibling}null!==i.tail&&Xe()>jl&&(t.flags|=128,r=!0,Ho(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=li(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Ho(i,!0),null===i.tail&&"hidden"===i.tailMode&&!l.alternate&&!sa)return qo(t),null}else 2*Xe()-i.renderingStartTime>jl&&1073741824!==n&&(t.flags|=128,r=!0,Ho(i,!1),t.lanes=4194304);i.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=i.last)?n.sibling=l:t.child=l,i.last=l)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Xe(),t.sibling=null,n=oi.current,Is(oi,r?1&n|2:1&n),t):(qo(t),null);case 22:case 23:return hu(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&1&t.mode?!!(1073741824&Dl)&&(qo(t),6&t.subtreeFlags&&(t.flags|=8192)):qo(t),null;case 24:case 25:return null}throw Error(a(156,t.tag))}function Ko(e,t){switch(ta(t),t.tag){case 1:return Os(t.type)&&Ds(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return si(),Ts(Cs),Ts(As),ci(),65536&(e=t.flags)&&!(128&e)?(t.flags=-65537&e|128,t):null;case 5:return ii(t),null;case 13:if(Ts(oi),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(a(340));pa()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ts(oi),null;case 4:return si(),null;case 10:return _a(t.type._context),null;case 22:case 23:return hu(),null;default:return null}}Oo=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Do=function(){},Fo=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,ni(Ja.current);var a,i=null;switch(n){case"input":s=K(e,s),r=K(e,r),i=[];break;case"select":s=L({},s,{value:void 0}),r=L({},r,{value:void 0}),i=[];break;case"textarea":s=re(e,s),r=re(e,r),i=[];break;default:"function"!=typeof s.onClick&&"function"==typeof r.onClick&&(e.onclick=Jr)}for(c in ye(n,r),n=null,s)if(!r.hasOwnProperty(c)&&s.hasOwnProperty(c)&&null!=s[c])if("style"===c){var l=s[c];for(a in l)l.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?i||(i=[]):(i=i||[]).push(c,null));for(c in r){var u=r[c];if(l=null!=s?s[c]:void 0,r.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(a in l)!l.hasOwnProperty(a)||u&&u.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in u)u.hasOwnProperty(a)&&l[a]!==u[a]&&(n||(n={}),n[a]=u[a])}else n||(i||(i=[]),i.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(c,u)):"children"===c?"string"!=typeof u&&"number"!=typeof u||(i=i||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&zr("scroll",e),i||l===u||(i=[])):(i=i||[]).push(c,u))}n&&(i=i||[]).push("style",n);var c=i;(t.updateQueue=c)&&(t.flags|=4)}},Ro=function(e,t,n,r){n!==r&&(t.flags|=4)};var Yo=!1,Xo=!1,Qo="function"==typeof WeakSet?WeakSet:Set,Jo=null;function el(e,t){var n=e.ref;if(null!==n)if("function"==typeof n)try{n(null)}catch(n){Tu(e,t,n)}else n.current=null}function tl(e,t,n){try{n()}catch(n){Tu(e,t,n)}}var nl=!1;function rl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var s=r=r.next;do{if((s.tag&e)===e){var a=s.destroy;s.destroy=void 0,void 0!==a&&tl(t,n,a)}s=s.next}while(s!==r)}}function sl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function al(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"==typeof t?t(e):t.current=e}}function il(e){var t=e.alternate;null!==t&&(e.alternate=null,il(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&null!==(t=e.stateNode)&&(delete t[hs],delete t[ps],delete t[ms],delete t[gs],delete t[bs]),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function ol(e){return 5===e.tag||3===e.tag||4===e.tag}function ll(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||ol(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ul(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=Jr));else if(4!==r&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}function cl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(cl(e,t,n),e=e.sibling;null!==e;)cl(e,t,n),e=e.sibling}var dl=null,hl=!1;function pl(e,t,n){for(n=n.child;null!==n;)fl(e,t,n),n=n.sibling}function fl(e,t,n){if(at&&"function"==typeof at.onCommitFiberUnmount)try{at.onCommitFiberUnmount(st,n)}catch(e){}switch(n.tag){case 5:Xo||el(n,t);case 6:var r=dl,s=hl;dl=null,pl(e,t,n),hl=s,null!==(dl=r)&&(hl?(e=dl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):dl.removeChild(n.stateNode));break;case 18:null!==dl&&(hl?(e=dl,n=n.stateNode,8===e.nodeType?ls(e.parentNode,n):1===e.nodeType&&ls(e,n),Ut(e)):ls(dl,n.stateNode));break;case 4:r=dl,s=hl,dl=n.stateNode.containerInfo,hl=!0,pl(e,t,n),dl=r,hl=s;break;case 0:case 11:case 14:case 15:if(!Xo&&null!==(r=n.updateQueue)&&null!==(r=r.lastEffect)){s=r=r.next;do{var a=s,i=a.destroy;a=a.tag,void 0!==i&&(2&a||4&a)&&tl(n,t,i),s=s.next}while(s!==r)}pl(e,t,n);break;case 1:if(!Xo&&(el(n,t),"function"==typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(e){Tu(n,t,e)}pl(e,t,n);break;case 21:pl(e,t,n);break;case 22:1&n.mode?(Xo=(r=Xo)||null!==n.memoizedState,pl(e,t,n),Xo=r):pl(e,t,n);break;default:pl(e,t,n)}}function ml(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var r=Cu.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function gl(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var s=n[r];try{var i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:dl=l.stateNode,hl=!1;break e;case 3:case 4:dl=l.stateNode.containerInfo,hl=!0;break e}l=l.return}if(null===dl)throw Error(a(160));fl(i,o,s),dl=null,hl=!1;var u=s.alternate;null!==u&&(u.return=null),s.return=null}catch(e){Tu(s,t,e)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)bl(t,e),t=t.sibling}function bl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(gl(t,e),yl(e),4&r){try{rl(3,e,e.return),sl(3,e)}catch(t){Tu(e,e.return,t)}try{rl(5,e,e.return)}catch(t){Tu(e,e.return,t)}}break;case 1:gl(t,e),yl(e),512&r&&null!==n&&el(n,n.return);break;case 5:if(gl(t,e),yl(e),512&r&&null!==n&&el(n,n.return),32&e.flags){var s=e.stateNode;try{he(s,"")}catch(t){Tu(e,e.return,t)}}if(4&r&&null!=(s=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===i.type&&null!=i.name&&X(s,i),we(l,o);var c=we(l,i);for(o=0;o<u.length;o+=2){var d=u[o],h=u[o+1];"style"===d?ge(s,h):"dangerouslySetInnerHTML"===d?de(s,h):"children"===d?he(s,h):w(s,d,h,c)}switch(l){case"input":Q(s,i);break;case"textarea":ae(s,i);break;case"select":var p=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(s,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(s,!!i.multiple,i.defaultValue,!0):ne(s,!!i.multiple,i.multiple?[]:"",!1))}s[ps]=i}catch(t){Tu(e,e.return,t)}}break;case 6:if(gl(t,e),yl(e),4&r){if(null===e.stateNode)throw Error(a(162));s=e.stateNode,i=e.memoizedProps;try{s.nodeValue=i}catch(t){Tu(e,e.return,t)}}break;case 3:if(gl(t,e),yl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Ut(t.containerInfo)}catch(t){Tu(e,e.return,t)}break;case 4:default:gl(t,e),yl(e);break;case 13:gl(t,e),yl(e),8192&(s=e.child).flags&&(i=null!==s.memoizedState,s.stateNode.isHidden=i,!i||null!==s.alternate&&null!==s.alternate.memoizedState||(Ul=Xe())),4&r&&ml(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Xo=(c=Xo)||d,gl(t,e),Xo=c):gl(t,e),yl(e),8192&r){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!d&&1&e.mode)for(Jo=e,d=e.child;null!==d;){for(h=Jo=d;null!==Jo;){switch(f=(p=Jo).child,p.tag){case 0:case 11:case 14:case 15:rl(4,p,p.return);break;case 1:el(p,p.return);var m=p.stateNode;if("function"==typeof m.componentWillUnmount){r=p,n=p.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(e){Tu(r,n,e)}}break;case 5:el(p,p.return);break;case 22:if(null!==p.memoizedState){_l(h);continue}}null!==f?(f.return=p,Jo=f):_l(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{s=h.stateNode,c?"function"==typeof(i=s.style).setProperty?i.setProperty("display","none","important"):i.display="none":(l=h.stateNode,o=null!=(u=h.memoizedProps.style)&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(t){Tu(e,e.return,t)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(t){Tu(e,e.return,t)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:gl(t,e),yl(e),4&r&&ml(e);case 21:}}function yl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(ol(n)){var r=n;break e}n=n.return}throw Error(a(160))}switch(r.tag){case 5:var s=r.stateNode;32&r.flags&&(he(s,""),r.flags&=-33),cl(e,ll(e),s);break;case 3:case 4:var i=r.stateNode.containerInfo;ul(e,ll(e),i);break;default:throw Error(a(161))}}catch(t){Tu(e,e.return,t)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function wl(e,t,n){Jo=e,vl(e,t,n)}function vl(e,t,n){for(var r=!!(1&e.mode);null!==Jo;){var s=Jo,a=s.child;if(22===s.tag&&r){var i=null!==s.memoizedState||Yo;if(!i){var o=s.alternate,l=null!==o&&null!==o.memoizedState||Xo;o=Yo;var u=Xo;if(Yo=i,(Xo=l)&&!u)for(Jo=s;null!==Jo;)l=(i=Jo).child,22===i.tag&&null!==i.memoizedState?kl(s):null!==l?(l.return=i,Jo=l):kl(s);for(;null!==a;)Jo=a,vl(a,t,n),a=a.sibling;Jo=s,Yo=o,Xo=u}xl(e)}else 8772&s.subtreeFlags&&null!==a?(a.return=s,Jo=a):xl(e)}}function xl(e){for(;null!==Jo;){var t=Jo;if(8772&t.flags){var n=t.alternate;try{if(8772&t.flags)switch(t.tag){case 0:case 11:case 15:Xo||sl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Xo)if(null===n)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:ga(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Pa(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Pa(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var d=c.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Ut(h)}}}break;default:throw Error(a(163))}Xo||512&t.flags&&al(t)}catch(e){Tu(t,t.return,e)}}if(t===e){Jo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Jo=n;break}Jo=t.return}}function _l(e){for(;null!==Jo;){var t=Jo;if(t===e){Jo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Jo=n;break}Jo=t.return}}function kl(e){for(;null!==Jo;){var t=Jo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{sl(4,t)}catch(e){Tu(t,n,e)}break;case 1:var r=t.stateNode;if("function"==typeof r.componentDidMount){var s=t.return;try{r.componentDidMount()}catch(e){Tu(t,s,e)}}var a=t.return;try{al(t)}catch(e){Tu(t,a,e)}break;case 5:var i=t.return;try{al(t)}catch(e){Tu(t,i,e)}}}catch(e){Tu(t,t.return,e)}if(t===e){Jo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Jo=o;break}Jo=t.return}}var Sl,Tl=Math.ceil,Il=v.ReactCurrentDispatcher,El=v.ReactCurrentOwner,Al=v.ReactCurrentBatchConfig,Cl=0,Nl=null,$l=null,Ol=0,Dl=0,Fl=Ss(0),Rl=0,Ml=null,Ll=0,Pl=0,zl=0,Bl=null,Vl=null,Ul=0,jl=1/0,Wl=null,Gl=!1,Hl=null,ql=null,Zl=!1,Kl=null,Yl=0,Xl=0,Ql=null,Jl=-1,eu=0;function tu(){return 6&Cl?Xe():-1!==Jl?Jl:Jl=Xe()}function nu(e){return 1&e.mode?2&Cl&&0!==Ol?Ol&-Ol:null!==ma.transition?(0===eu&&(eu=mt()),eu):0!==(e=wt)?e:e=void 0===(e=window.event)?16:Yt(e.type):1}function ru(e,t,n,r){if(50<Xl)throw Xl=0,Ql=null,Error(a(185));bt(e,n,r),2&Cl&&e===Nl||(e===Nl&&(!(2&Cl)&&(Pl|=n),4===Rl&&lu(e,Ol)),su(e,r),1===n&&0===Cl&&!(1&t.mode)&&(jl=Xe()+500,zs&&Us()))}function su(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-it(a),o=1<<i,l=s[i];-1===l?o&n&&!(o&r)||(s[i]=pt(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}}(e,t);var r=ht(e,e===Nl?Ol:0);if(0===r)null!==n&&Ze(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ze(n),1===t)0===e.tag?function(e){zs=!0,Vs(e)}(uu.bind(null,e)):Vs(uu.bind(null,e)),is((function(){!(6&Cl)&&Us()})),n=null;else{switch(vt(r)){case 1:n=Je;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Nu(n,au.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function au(e,t){if(Jl=-1,eu=0,6&Cl)throw Error(a(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var r=ht(e,e===Nl?Ol:0);if(0===r)return null;if(30&r||r&e.expiredLanes||t)t=bu(e,r);else{t=r;var s=Cl;Cl|=2;var i=mu();for(Nl===e&&Ol===t||(Wl=null,jl=Xe()+500,pu(e,t));;)try{wu();break}catch(t){fu(e,t)}xa(),Il.current=i,Cl=s,null!==$l?t=0:(Nl=null,Ol=0,t=Rl)}if(0!==t){if(2===t&&0!==(s=ft(e))&&(r=s,t=iu(e,s)),1===t)throw n=Ml,pu(e,0),lu(e,r),su(e,Xe()),n;if(6===t)lu(e,r);else{if(s=e.current.alternate,!(30&r||function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!or(a(),s))return!1}catch(e){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(s)||(t=bu(e,r),2===t&&(i=ft(e),0!==i&&(r=i,t=iu(e,i))),1!==t)))throw n=Ml,pu(e,0),lu(e,r),su(e,Xe()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(a(345));case 2:case 5:_u(e,Vl,Wl);break;case 3:if(lu(e,r),(130023424&r)===r&&10<(t=Ul+500-Xe())){if(0!==ht(e,0))break;if(((s=e.suspendedLanes)&r)!==r){tu(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=rs(_u.bind(null,e,Vl,Wl),t);break}_u(e,Vl,Wl);break;case 4:if(lu(e,r),(4194240&r)===r)break;for(t=e.eventTimes,s=-1;0<r;){var o=31-it(r);i=1<<o,(o=t[o])>s&&(s=o),r&=~i}if(r=s,10<(r=(120>(r=Xe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Tl(r/1960))-r)){e.timeoutHandle=rs(_u.bind(null,e,Vl,Wl),r);break}_u(e,Vl,Wl);break;default:throw Error(a(329))}}}return su(e,Xe()),e.callbackNode===n?au.bind(null,e):null}function iu(e,t){var n=Bl;return e.current.memoizedState.isDehydrated&&(pu(e,t).flags|=256),2!==(e=bu(e,t))&&(t=Vl,Vl=n,null!==t&&ou(t)),e}function ou(e){null===Vl?Vl=e:Vl.push.apply(Vl,e)}function lu(e,t){for(t&=~zl,t&=~Pl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function uu(e){if(6&Cl)throw Error(a(327));ku();var t=ht(e,0);if(!(1&t))return su(e,Xe()),null;var n=bu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=iu(e,r))}if(1===n)throw n=Ml,pu(e,0),lu(e,t),su(e,Xe()),n;if(6===n)throw Error(a(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,_u(e,Vl,Wl),su(e,Xe()),null}function cu(e,t){var n=Cl;Cl|=1;try{return e(t)}finally{0===(Cl=n)&&(jl=Xe()+500,zs&&Us())}}function du(e){null!==Kl&&0===Kl.tag&&!(6&Cl)&&ku();var t=Cl;Cl|=1;var n=Al.transition,r=wt;try{if(Al.transition=null,wt=1,e)return e()}finally{wt=r,Al.transition=n,!(6&(Cl=t))&&Us()}}function hu(){Dl=Fl.current,Ts(Fl)}function pu(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,ss(n)),null!==$l)for(n=$l.return;null!==n;){var r=n;switch(ta(r),r.tag){case 1:null!=(r=r.type.childContextTypes)&&Ds();break;case 3:si(),Ts(Cs),Ts(As),ci();break;case 5:ii(r);break;case 4:si();break;case 13:case 19:Ts(oi);break;case 10:_a(r.type._context);break;case 22:case 23:hu()}n=n.return}if(Nl=e,$l=e=Fu(e.current,null),Ol=Dl=t,Rl=0,Ml=null,zl=Pl=Ll=0,Vl=Bl=null,null!==Ia){for(t=0;t<Ia.length;t++)if(null!==(r=(n=Ia[t]).interleaved)){n.interleaved=null;var s=r.next,a=n.pending;if(null!==a){var i=a.next;a.next=s,r.next=i}n.pending=r}Ia=null}return e}function fu(e,t){for(;;){var n=$l;try{if(xa(),di.current=ao,bi){for(var r=fi.memoizedState;null!==r;){var s=r.queue;null!==s&&(s.pending=null),r=r.next}bi=!1}if(pi=0,gi=mi=fi=null,yi=!1,wi=0,El.current=null,null===n||null===n.return){Rl=1,Ml=t,$l=null;break}e:{var i=e,o=n.return,l=n,u=t;if(t=Ol,l.flags|=32768,null!==u&&"object"==typeof u&&"function"==typeof u.then){var c=u,d=l,h=d.tag;if(!(1&d.mode||0!==h&&11!==h&&15!==h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=bo(o);if(null!==f){f.flags&=-257,yo(f,o,l,0,t),1&f.mode&&go(i,c,t),u=c;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(!(1&t)){go(i,c,t),gu();break e}u=Error(a(426))}else if(sa&&1&l.mode){var b=bo(o);if(null!==b){!(65536&b.flags)&&(b.flags|=256),yo(b,o,l,0,t),fa(uo(u,l));break e}}i=u=uo(u,l),4!==Rl&&(Rl=2),null===Bl?Bl=[i]:Bl.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Ma(i,fo(0,u,t));break e;case 1:l=u;var y=i.type,w=i.stateNode;if(!(128&i.flags||"function"!=typeof y.getDerivedStateFromError&&(null===w||"function"!=typeof w.componentDidCatch||null!==ql&&ql.has(w)))){i.flags|=65536,t&=-t,i.lanes|=t,Ma(i,mo(i,l,t));break e}}i=i.return}while(null!==i)}xu(n)}catch(e){t=e,$l===n&&null!==n&&($l=n=n.return);continue}break}}function mu(){var e=Il.current;return Il.current=ao,null===e?ao:e}function gu(){0!==Rl&&3!==Rl&&2!==Rl||(Rl=4),null===Nl||!(268435455&Ll)&&!(268435455&Pl)||lu(Nl,Ol)}function bu(e,t){var n=Cl;Cl|=2;var r=mu();for(Nl===e&&Ol===t||(Wl=null,pu(e,t));;)try{yu();break}catch(t){fu(e,t)}if(xa(),Cl=n,Il.current=r,null!==$l)throw Error(a(261));return Nl=null,Ol=0,Rl}function yu(){for(;null!==$l;)vu($l)}function wu(){for(;null!==$l&&!Ke();)vu($l)}function vu(e){var t=Sl(e.alternate,e,Dl);e.memoizedProps=e.pendingProps,null===t?xu(e):$l=t,El.current=null}function xu(e){var t=e;do{var n=t.alternate;if(e=t.return,32768&t.flags){if(null!==(n=Ko(n,t)))return n.flags&=32767,void($l=n);if(null===e)return Rl=6,void($l=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}else if(null!==(n=Zo(n,t,Dl)))return void($l=n);if(null!==(t=t.sibling))return void($l=t);$l=t=e}while(null!==t);0===Rl&&(Rl=5)}function _u(e,t,n){var r=wt,s=Al.transition;try{Al.transition=null,wt=1,function(e,t,n,r){do{ku()}while(null!==Kl);if(6&Cl)throw Error(a(327));n=e.finishedWork;var s=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(a(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-it(n),a=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~a}}(e,i),e===Nl&&($l=Nl=null,Ol=0),!(2064&n.subtreeFlags)&&!(2064&n.flags)||Zl||(Zl=!0,Nu(tt,(function(){return ku(),null}))),i=!!(15990&n.flags),15990&n.subtreeFlags||i){i=Al.transition,Al.transition=null;var o=wt;wt=1;var l=Cl;Cl|=4,El.current=null,function(e,t){if(es=Wt,pr(e=hr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var s=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(e){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==s&&3!==h.nodeType||(l=o+s),h!==i||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===s&&(l=o),p===i&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ts={focusedElem:e,selectionRange:n},Wt=!1,Jo=t;null!==Jo;)if(e=(t=Jo).child,1028&t.subtreeFlags&&null!==e)e.return=t,Jo=e;else for(;null!==Jo;){t=Jo;try{var m=t.alternate;if(1024&t.flags)switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,b=m.memoizedState,y=t.stateNode,w=y.getSnapshotBeforeUpdate(t.elementType===t.type?g:ga(t.type,g),b);y.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(a(163))}}catch(e){Tu(t,t.return,e)}if(null!==(e=t.sibling)){e.return=t.return,Jo=e;break}Jo=t.return}m=nl,nl=!1}(e,n),bl(n,e),fr(ts),Wt=!!es,ts=es=null,e.current=n,wl(n,e,s),Ye(),Cl=l,wt=o,Al.transition=i}else e.current=n;if(Zl&&(Zl=!1,Kl=e,Yl=s),0===(i=e.pendingLanes)&&(ql=null),function(e){if(at&&"function"==typeof at.onCommitFiberRoot)try{at.onCommitFiberRoot(st,e,void 0,!(128&~e.current.flags))}catch(e){}}(n.stateNode),su(e,Xe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)r((s=t[n]).value,{componentStack:s.stack,digest:s.digest});if(Gl)throw Gl=!1,e=Hl,Hl=null,e;!!(1&Yl)&&0!==e.tag&&ku(),1&(i=e.pendingLanes)?e===Ql?Xl++:(Xl=0,Ql=e):Xl=0,Us()}(e,t,n,r)}finally{Al.transition=s,wt=r}return null}function ku(){if(null!==Kl){var e=vt(Yl),t=Al.transition,n=wt;try{if(Al.transition=null,wt=16>e?16:e,null===Kl)var r=!1;else{if(e=Kl,Kl=null,Yl=0,6&Cl)throw Error(a(331));var s=Cl;for(Cl|=4,Jo=e.current;null!==Jo;){var i=Jo,o=i.child;if(16&Jo.flags){var l=i.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Jo=c;null!==Jo;){var d=Jo;switch(d.tag){case 0:case 11:case 15:rl(8,d,i)}var h=d.child;if(null!==h)h.return=d,Jo=h;else for(;null!==Jo;){var p=(d=Jo).sibling,f=d.return;if(il(d),d===c){Jo=null;break}if(null!==p){p.return=f,Jo=p;break}Jo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var b=g.sibling;g.sibling=null,g=b}while(null!==g)}}Jo=i}}if(2064&i.subtreeFlags&&null!==o)o.return=i,Jo=o;else e:for(;null!==Jo;){if(2048&(i=Jo).flags)switch(i.tag){case 0:case 11:case 15:rl(9,i,i.return)}var y=i.sibling;if(null!==y){y.return=i.return,Jo=y;break e}Jo=i.return}}var w=e.current;for(Jo=w;null!==Jo;){var v=(o=Jo).child;if(2064&o.subtreeFlags&&null!==v)v.return=o,Jo=v;else e:for(o=w;null!==Jo;){if(2048&(l=Jo).flags)try{switch(l.tag){case 0:case 11:case 15:sl(9,l)}}catch(e){Tu(l,l.return,e)}if(l===o){Jo=null;break e}var x=l.sibling;if(null!==x){x.return=l.return,Jo=x;break e}Jo=l.return}}if(Cl=s,Us(),at&&"function"==typeof at.onPostCommitFiberRoot)try{at.onPostCommitFiberRoot(st,e)}catch(e){}r=!0}return r}finally{wt=n,Al.transition=t}}return!1}function Su(e,t,n){e=Fa(e,t=fo(0,t=uo(n,t),1),1),t=tu(),null!==e&&(bt(e,1,t),su(e,t))}function Tu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"==typeof t.type.getDerivedStateFromError||"function"==typeof r.componentDidCatch&&(null===ql||!ql.has(r))){t=Fa(t,e=mo(t,e=uo(n,e),1),1),e=tu(),null!==t&&(bt(t,1,e),su(t,e));break}}t=t.return}}function Iu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=tu(),e.pingedLanes|=e.suspendedLanes&n,Nl===e&&(Ol&n)===n&&(4===Rl||3===Rl&&(130023424&Ol)===Ol&&500>Xe()-Ul?pu(e,0):zl|=n),su(e,t)}function Eu(e,t){0===t&&(1&e.mode?(t=ct,!(130023424&(ct<<=1))&&(ct=4194304)):t=1);var n=tu();null!==(e=Ca(e,t))&&(bt(e,t,n),su(e,n))}function Au(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Eu(e,n)}function Cu(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(a(314))}null!==r&&r.delete(t),Eu(e,n)}function Nu(e,t){return qe(e,t)}function $u(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ou(e,t,n,r){return new $u(e,t,n,r)}function Du(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Fu(e,t){var n=e.alternate;return null===n?((n=Ou(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Ru(e,t,n,r,s,i){var o=2;if(r=e,"function"==typeof e)Du(e)&&(o=1);else if("string"==typeof e)o=5;else e:switch(e){case k:return Mu(n.children,s,i,t);case S:o=8,s|=8;break;case T:return(e=Ou(12,n,t,2|s)).elementType=T,e.lanes=i,e;case C:return(e=Ou(13,n,t,s)).elementType=C,e.lanes=i,e;case N:return(e=Ou(19,n,t,s)).elementType=N,e.lanes=i,e;case D:return Lu(n,s,i,t);default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case I:o=10;break e;case E:o=9;break e;case A:o=11;break e;case $:o=14;break e;case O:o=16,r=null;break e}throw Error(a(130,null==e?e:typeof e,""))}return(t=Ou(o,n,t,s)).elementType=e,t.type=r,t.lanes=i,t}function Mu(e,t,n,r){return(e=Ou(7,e,r,t)).lanes=n,e}function Lu(e,t,n,r){return(e=Ou(22,e,r,t)).elementType=D,e.lanes=n,e.stateNode={isHidden:!1},e}function Pu(e,t,n){return(e=Ou(6,e,null,t)).lanes=n,e}function zu(e,t,n){return(t=Ou(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Bu(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Vu(e,t,n,r,s,a,i,o,l){return e=new Bu(e,t,n,o,l),1===t?(t=1,!0===a&&(t|=8)):t=0,a=Ou(3,null,null,t),e.current=a,a.stateNode=e,a.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},$a(a),e}function Uu(e){if(!e)return Es;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(a(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Os(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(a(171))}if(1===e.tag){var n=e.type;if(Os(n))return Rs(e,n,t)}return t}function ju(e,t,n,r,s,a,i,o,l){return(e=Vu(n,r,!0,e,0,a,0,o,l)).context=Uu(null),n=e.current,(a=Da(r=tu(),s=nu(n))).callback=null!=t?t:null,Fa(n,a,s),e.current.lanes=s,bt(e,s,r),su(e,r),e}function Wu(e,t,n,r){var s=t.current,a=tu(),i=nu(s);return n=Uu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Da(a,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=Fa(s,t,i))&&(ru(e,s,i,a),Ra(e,s,i)),i}function Gu(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function qu(e,t){Hu(e,t),(e=e.alternate)&&Hu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Cs.current)vo=!0;else{if(!(e.lanes&n||128&t.flags))return vo=!1,function(e,t,n){switch(t.tag){case 3:No(t),pa();break;case 5:ai(t);break;case 1:Os(t.type)&&Ms(t);break;case 4:ri(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;Is(ba,r._currentValue),r._currentValue=s;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Is(oi,1&oi.current),t.flags|=128,null):n&t.child.childLanes?Po(e,t,n):(Is(oi,1&oi.current),null!==(e=Go(e,t,n))?e.sibling:null);Is(oi,1&oi.current);break;case 19:if(r=!!(n&t.childLanes),128&e.flags){if(r)return jo(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),Is(oi,oi.current),r)break;return null;case 22:case 23:return t.lanes=0,To(e,t,n)}return Go(e,t,n)}(e,t,n);vo=!!(131072&e.flags)}else vo=!1,sa&&1048576&t.flags&&Js(t,Hs,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Wo(e,t),e=t.pendingProps;var s=$s(t,As.current);Sa(t,n),s=ki(null,t,r,e,s,n);var i=Si();return t.flags|=1,"object"==typeof s&&null!==s&&"function"==typeof s.render&&void 0===s.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Os(r)?(i=!0,Ms(t)):i=!1,t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,$a(t),s.updater=Va,t.stateNode=s,s._reactInternals=t,Ga(t,r,e,n),t=Co(null,t,r,!0,i,n)):(t.tag=0,sa&&i&&ea(t),xo(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Wo(e,t),e=t.pendingProps,r=(s=r._init)(r._payload),t.type=r,s=t.tag=function(e){if("function"==typeof e)return Du(e)?1:0;if(null!=e){if((e=e.$$typeof)===A)return 11;if(e===$)return 14}return 2}(r),e=ga(r,e),s){case 0:t=Eo(null,t,r,e,n);break e;case 1:t=Ao(null,t,r,e,n);break e;case 11:t=_o(null,t,r,e,n);break e;case 14:t=ko(null,t,r,ga(r.type,e),n);break e}throw Error(a(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,Eo(e,t,r,s=t.elementType===r?s:ga(r,s),n);case 1:return r=t.type,s=t.pendingProps,Ao(e,t,r,s=t.elementType===r?s:ga(r,s),n);case 3:e:{if(No(t),null===e)throw Error(a(387));r=t.pendingProps,s=(i=t.memoizedState).element,Oa(e,t),La(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=$o(e,t,r,n,s=uo(Error(a(423)),t));break e}if(r!==s){t=$o(e,t,r,n,s=uo(Error(a(424)),t));break e}for(ra=us(t.stateNode.containerInfo.firstChild),na=t,sa=!0,aa=null,n=Xa(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pa(),r===s){t=Go(e,t,n);break e}xo(e,t,r,n)}t=t.child}return t;case 5:return ai(t),null===e&&ua(t),r=t.type,s=t.pendingProps,i=null!==e?e.memoizedProps:null,o=s.children,ns(r,s)?o=null:null!==i&&ns(r,i)&&(t.flags|=32),Io(e,t),xo(e,t,o,n),t.child;case 6:return null===e&&ua(t),null;case 13:return Po(e,t,n);case 4:return ri(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=Ya(t,null,r,n):xo(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,_o(e,t,r,s=t.elementType===r?s:ga(r,s),n);case 7:return xo(e,t,t.pendingProps,n),t.child;case 8:case 12:return xo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,i=t.memoizedProps,o=s.value,Is(ba,r._currentValue),r._currentValue=o,null!==i)if(or(i.value,o)){if(i.children===s.children&&!Cs.current){t=Go(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var l=i.dependencies;if(null!==l){o=i.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===i.tag){(u=Da(-1,n&-n)).tag=2;var c=i.updateQueue;if(null!==c){var d=(c=c.shared).pending;null===d?u.next=u:(u.next=d.next,d.next=u),c.pending=u}}i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),ka(i.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(a(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),ka(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}xo(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,Sa(t,n),r=r(s=Ta(s)),t.flags|=1,xo(e,t,r,n),t.child;case 14:return s=ga(r=t.type,t.pendingProps),ko(e,t,r,s=ga(r.type,s),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:ga(r,s),Wo(e,t),t.tag=1,Os(r)?(e=!0,Ms(t)):e=!1,Sa(t,n),ja(t,r,s),Ga(t,r,s,n),Co(null,t,r,!0,e,n);case 19:return jo(e,t,n);case 22:return To(e,t,n)}throw Error(a(156,t.tag))};var Zu="function"==typeof reportError?reportError:function(e){console.error(e)};function Ku(e){this._internalRoot=e}function Yu(e){this._internalRoot=e}function Xu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Ju(){}function ec(e,t,n,r,s){var a=n._reactRootContainer;if(a){var i=a;if("function"==typeof s){var o=s;s=function(){var e=Gu(i);o.call(e)}}Wu(t,i,e,s)}else i=function(e,t,n,r,s){if(s){if("function"==typeof r){var a=r;r=function(){var e=Gu(i);a.call(e)}}var i=ju(t,r,e,0,null,!1,0,"",Ju);return e._reactRootContainer=i,e[fs]=i.current,Ur(8===e.nodeType?e.parentNode:e),du(),i}for(;s=e.lastChild;)e.removeChild(s);if("function"==typeof r){var o=r;r=function(){var e=Gu(l);o.call(e)}}var l=Vu(e,0,!1,null,0,!1,0,"",Ju);return e._reactRootContainer=l,e[fs]=l.current,Ur(8===e.nodeType?e.parentNode:e),du((function(){Wu(t,l,n,r)})),l}(n,t,e,s,r);return Gu(i)}Yu.prototype.render=Ku.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(a(409));Wu(e,t,null,null)},Yu.prototype.unmount=Ku.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;du((function(){Wu(null,e,null,null)})),t[fs]=null}},Yu.prototype.unstable_scheduleHydration=function(e){if(e){var t=St();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Dt.length&&0!==t&&t<Dt[n].priority;n++);Dt.splice(n,0,e),0===n&&Lt(e)}},xt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(yt(t,1|n),su(t,Xe()),!(6&Cl)&&(jl=Xe()+500,Us()))}break;case 13:du((function(){var t=Ca(e,1);if(null!==t){var n=tu();ru(t,e,1,n)}})),qu(e,1)}},_t=function(e){if(13===e.tag){var t=Ca(e,134217728);null!==t&&ru(t,e,134217728,tu()),qu(e,134217728)}},kt=function(e){if(13===e.tag){var t=nu(e),n=Ca(e,t);null!==n&&ru(n,e,t,tu()),qu(e,t)}},St=function(){return wt},Tt=function(e,t){var n=wt;try{return wt=e,t()}finally{wt=n}},_e=function(e,t,n){switch(t){case"input":if(Q(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=xs(r);if(!s)throw Error(a(90));q(r),Q(r,s)}}}break;case"textarea":ae(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ae=cu,Ce=du;var tc={usingClientEntryPoint:!1,Events:[ws,vs,xs,Ie,Ee,cu]},nc={findFiberByHostInstance:ys,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},rc={bundleType:nc.bundleType,version:nc.version,rendererPackageName:nc.rendererPackageName,rendererConfig:nc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:nc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var sc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!sc.isDisabled&&sc.supportsFiber)try{st=sc.inject(rc),at=sc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tc,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Xu(t))throw Error(a(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:_,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Xu(e))throw Error(a(299));var n=!1,r="",s=Zu;return null!=t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(s=t.onRecoverableError)),t=Vu(e,1,!1,null,0,n,0,r,s),e[fs]=t.current,Ur(8===e.nodeType?e.parentNode:e),new Ku(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(a(188));throw e=Object.keys(e).join(","),Error(a(268,e))}return null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return du(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(a(200));return ec(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Xu(e))throw Error(a(405));var r=null!=n&&n.hydratedSources||null,s=!1,i="",o=Zu;if(null!=n&&(!0===n.unstable_strictMode&&(s=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=ju(t,null,e,1,null!=n?n:null,s,0,i,o),e[fs]=t.current,Ur(e),r)for(e=0;e<r.length;e++)s=(s=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new Yu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(a(200));return ec(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(a(40));return!!e._reactRootContainer&&(du((function(){ec(null,null,e,!1,(function(){e._reactRootContainer=null,e[fs]=null}))})),!0)},t.unstable_batchedUpdates=cu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qu(n))throw Error(a(200));if(null==e||void 0===e._reactInternals)throw Error(a(38));return ec(e,t,n,!1,r)},t.version="18.2.0-next-9e3b772b8-20220608"},4140:(e,t,n)=>{"use strict";var r=n(2483);t.createRoot=r.createRoot,t.hydrateRoot=r.hydrateRoot},2483:(e,t,n)=>{"use strict";!function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(e){console.error(e)}}(),e.exports=n(7045)},5677:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator,f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function b(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function y(){}function w(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var v=w.prototype=new y;v.constructor=w,m(v,b.prototype),v.isPureReactComponent=!0;var x=Array.isArray,_=Object.prototype.hasOwnProperty,k={current:null},S={key:!0,ref:!0,__self:!0,__source:!0};function T(e,t,r){var s,a={},i=null,o=null;if(null!=t)for(s in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)_.call(t,s)&&!S.hasOwnProperty(s)&&(a[s]=t[s]);var l=arguments.length-2;if(1===l)a.children=r;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];a.children=u}if(e&&e.defaultProps)for(s in l=e.defaultProps)void 0===a[s]&&(a[s]=l[s]);return{$$typeof:n,type:e,key:i,ref:o,props:a,_owner:k.current}}function I(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var E=/\/+/g;function A(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function C(e,t,s,a,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return i=i(l=e),e=""===a?"."+A(l,0):a,x(i)?(s="",null!=e&&(s=e.replace(E,"$&/")+"/"),C(i,t,s,"",(function(e){return e}))):null!=i&&(I(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,s+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(E,"$&/")+"/")+e)),t.push(i)),1;if(l=0,a=""===a?".":a+":",x(e))for(var u=0;u<e.length;u++){var c=a+A(o=e[u],u);l+=C(o,t,s,c,i)}else if(c=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"==typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=C(o=o.value,t,s,c=a+A(o,u++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function N(e,t,n){if(null==e)return e;var r=[],s=0;return C(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function $(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var O={current:null},D={transition:null},F={ReactCurrentDispatcher:O,ReactCurrentBatchConfig:D,ReactCurrentOwner:k};t.Children={map:N,forEach:function(e,t,n){N(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return N(e,(function(){t++})),t},toArray:function(e){return N(e,(function(e){return e}))||[]},only:function(e){if(!I(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=s,t.Profiler=i,t.PureComponent=w,t.StrictMode=a,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,t.cloneElement=function(e,t,r){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=m({},e.props),a=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=k.current),void 0!==t.key&&(a=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)_.call(t,u)&&!S.hasOwnProperty(u)&&(s[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)s.children=r;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];s.children=l}return{$$typeof:n,type:e.type,key:a,ref:i,props:s,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=T,t.createFactory=function(e){var t=T.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=I,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:$}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=D.transition;D.transition={};try{e()}finally{D.transition=t}},t.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},t.useCallback=function(e,t){return O.current.useCallback(e,t)},t.useContext=function(e){return O.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return O.current.useDeferredValue(e)},t.useEffect=function(e,t){return O.current.useEffect(e,t)},t.useId=function(){return O.current.useId()},t.useImperativeHandle=function(e,t,n){return O.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return O.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return O.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return O.current.useMemo(e,t)},t.useReducer=function(e,t,n){return O.current.useReducer(e,t,n)},t.useRef=function(e){return O.current.useRef(e)},t.useState=function(e){return O.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return O.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return O.current.useTransition()},t.version="18.2.0"},7810:(e,t,n)=>{"use strict";e.exports=n(5677)},1613:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,s=e[r];if(!(0<a(s,t)))break e;e[r]=t,e[n]=s,n=r}}function r(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,s=e.length,i=s>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>a(l,n))u<s&&0>a(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<s&&0>a(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function a(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"==typeof performance&&"function"==typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,b="function"==typeof setTimeout?setTimeout:null,y="function"==typeof clearTimeout?clearTimeout:null,w="undefined"!=typeof setImmediate?setImmediate:null;function v(e){for(var t=r(c);null!==t;){if(null===t.callback)s(c);else{if(!(t.startTime<=e))break;s(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function x(e){if(g=!1,v(e),!m)if(null!==r(u))m=!0,D(_);else{var t=r(c);null!==t&&F(x,t.startTime-e)}}function _(e,n){m=!1,g&&(g=!1,y(I),I=-1),f=!0;var a=p;try{for(v(n),h=r(u);null!==h&&(!(h.expirationTime>n)||e&&!C());){var i=h.callback;if("function"==typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=n);n=t.unstable_now(),"function"==typeof o?h.callback=o:h===r(u)&&s(u),v(n)}else s(u);h=r(u)}if(null!==h)var l=!0;else{var d=r(c);null!==d&&F(x,d.startTime-n),l=!1}return l}finally{h=null,p=a,f=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var k,S=!1,T=null,I=-1,E=5,A=-1;function C(){return!(t.unstable_now()-A<E)}function N(){if(null!==T){var e=t.unstable_now();A=e;var n=!0;try{n=T(!0,e)}finally{n?k():(S=!1,T=null)}}else S=!1}if("function"==typeof w)k=function(){w(N)};else if("undefined"!=typeof MessageChannel){var $=new MessageChannel,O=$.port2;$.port1.onmessage=N,k=function(){O.postMessage(null)}}else k=function(){b(N,0)};function D(e){T=e,S||(S=!0,k())}function F(e,n){I=b((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,D(_))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,a){var i=t.unstable_now();switch(a="object"==typeof a&&null!==a&&"number"==typeof(a=a.delay)&&0<a?i+a:i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:s,priorityLevel:e,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>i?(e.sortIndex=a,n(c,e),null===r(u)&&e===r(c)&&(g?(y(I),I=-1):g=!0,F(x,a-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,D(_))),e},t.unstable_shouldYield=C,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},2328:(e,t,n)=>{"use strict";e.exports=n(1613)},8273:(e,t,n)=>{var r=n(6713),s=n(7315),a=n(7957),i=n(3829),o=n(4011),l=n(3771),u=n(2771);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},6713:function(e,t,n){var r;!function(e,s,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,s))||(s.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},3771:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,s))||(s.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},7315:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,s))||(s.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},4011:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,s))||(s.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},3829:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,s))||(s.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},7957:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,s))||(s.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},2771:function(e,t,n){var r;!function(s,a,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=l-1;function p(e,t,n){var r=[],h=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(s.crypto||s.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,y(a)]}}():e,3),r),p=new f(r),w=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return w.int32=function(){return 0|p.g(4)},w.quick=function(){return p.g(4)/4294967296},w.double=w,b(y(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(w,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=h&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=h&s+1],n=n*l+i[h&(i[s]=i[a=h&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function b(e,t){for(var n,r=e+"",s=0;s<r.length;)t[h&s]=h&(n^=19*t[h&s])+r.charCodeAt(s++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(b(i.random(),a),e.exports){e.exports=p;try{o=n(1234)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},6186:e=>{"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],o=0;o<e.length;o++){var l=e[o],u=r.base?l[0]+r.base:l[0],c=a[u]||0,d="".concat(u," ").concat(c);a[u]=c+1;var h=n(d),p={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==h)t[h].references++,t[h].updater(p);else{var f=s(p,r);r.byIndex=o,t.splice(o,0,{identifier:d,updater:f,references:1})}i.push(d)}return i}function s(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,s){var a=r(e=e||[],s=s||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var o=n(a[i]);t[o].references--}for(var l=r(e,s),u=0;u<a.length;u++){var c=n(a[u]);0===t[c].references&&(t[c].updater(),t.splice(c,1))}a=l}}},7433:e=>{"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},8990:e=>{"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},8626:(e,t,n)=>{"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},2155:e=>{"use strict";e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var s=void 0!==n.layer;s&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,s&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},9827:e=>{"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},9397:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>b});var r=n(6186),s=n.n(r),a=n(2155),i=n.n(a),o=n(7433),l=n.n(o),u=n(8626),c=n.n(u),d=n(8990),h=n.n(d),p=n(9827),f=n.n(p),m=n(6348),g={};g.styleTagTransform=f(),g.setAttributes=c(),g.insert=l().bind(null,"head"),g.domAPI=i(),g.insertStyleElement=h(),s()(m.A,g);const b=m.A&&m.A.locals?m.A.locals:void 0},6998:(e,t,n)=>{"use strict";function r(e,t){e&&e(t)}function s(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}n.r(t),n.d(t,{ASTFeatureExtractor:()=>hh,ASTForAudioClassification:()=>Ci,ASTModel:()=>Ai,ASTPreTrainedModel:()=>Ei,AlbertForMaskedLM:()=>Pa,AlbertForQuestionAnswering:()=>La,AlbertForSequenceClassification:()=>Ma,AlbertModel:()=>Ra,AlbertPreTrainedModel:()=>Fa,AlbertTokenizer:()=>On,AudioClassificationPipeline:()=>Ph,AutoConfig:()=>Ar,AutoModel:()=>Nc,AutoModelForAudioClassification:()=>Zc,AutoModelForAudioFrameClassification:()=>Yc,AutoModelForCTC:()=>qc,AutoModelForCausalLM:()=>Lc,AutoModelForDepthEstimation:()=>ed,AutoModelForDocumentQuestionAnswering:()=>Xc,AutoModelForImageClassification:()=>Vc,AutoModelForImageFeatureExtraction:()=>td,AutoModelForImageMatting:()=>Qc,AutoModelForImageSegmentation:()=>Uc,AutoModelForImageToImage:()=>Jc,AutoModelForMaskGeneration:()=>Hc,AutoModelForMaskedLM:()=>Pc,AutoModelForObjectDetection:()=>Wc,AutoModelForQuestionAnswering:()=>zc,AutoModelForSemanticSegmentation:()=>jc,AutoModelForSeq2SeqLM:()=>Dc,AutoModelForSequenceClassification:()=>$c,AutoModelForSpeechSeq2Seq:()=>Fc,AutoModelForTextToSpectrogram:()=>Rc,AutoModelForTextToWaveform:()=>Mc,AutoModelForTokenClassification:()=>Oc,AutoModelForVision2Seq:()=>Bc,AutoModelForXVector:()=>Kc,AutoModelForZeroShotObjectDetection:()=>Gc,AutoProcessor:()=>xh,AutoTokenizer:()=>Ir,AutomaticSpeechRecognitionPipeline:()=>Bh,BartForConditionalGeneration:()=>Ya,BartForSequenceClassification:()=>Xa,BartModel:()=>Ka,BartPretrainedModel:()=>Za,BartTokenizer:()=>Hn,BaseModelOutput:()=>gs,BeitFeatureExtractor:()=>th,BeitForImageClassification:()=>Ho,BeitModel:()=>Go,BeitPreTrainedModel:()=>Wo,BertForMaskedLM:()=>ws,BertForQuestionAnswering:()=>_s,BertForSequenceClassification:()=>vs,BertForTokenClassification:()=>xs,BertModel:()=>ys,BertPreTrainedModel:()=>bs,BertTokenizer:()=>$n,BitImageProcessor:()=>Vd,BlenderbotForConditionalGeneration:()=>ai,BlenderbotModel:()=>si,BlenderbotPreTrainedModel:()=>ri,BlenderbotSmallForConditionalGeneration:()=>li,BlenderbotSmallModel:()=>oi,BlenderbotSmallPreTrainedModel:()=>ii,BlenderbotSmallTokenizer:()=>xr,BlenderbotTokenizer:()=>vr,BloomForCausalLM:()=>ko,BloomModel:()=>_o,BloomPreTrainedModel:()=>xo,BloomTokenizer:()=>Yn,CLIPFeatureExtractor:()=>jd,CLIPModel:()=>Ri,CLIPPreTrainedModel:()=>Fi,CLIPSegForImageSegmentation:()=>Hi,CLIPSegModel:()=>Gi,CLIPSegPreTrainedModel:()=>Wi,CLIPTextModelWithProjection:()=>Mi,CLIPTokenizer:()=>gr,CLIPVisionModelWithProjection:()=>Li,CamembertForMaskedLM:()=>Gs,CamembertForQuestionAnswering:()=>Zs,CamembertForSequenceClassification:()=>Hs,CamembertForTokenClassification:()=>qs,CamembertModel:()=>Ws,CamembertPreTrainedModel:()=>js,CamembertTokenizer:()=>Vn,CausalLMOutput:()=>ld,CausalLMOutputWithPast:()=>ud,ChineseCLIPFeatureExtractor:()=>Wd,ChineseCLIPModel:()=>ji,ChineseCLIPPreTrainedModel:()=>Ui,ClapAudioModelWithProjection:()=>Bu,ClapFeatureExtractor:()=>ph,ClapModel:()=>Pu,ClapPreTrainedModel:()=>Lu,ClapTextModelWithProjection:()=>zu,CodeGenForCausalLM:()=>co,CodeGenModel:()=>uo,CodeGenPreTrainedModel:()=>lo,CodeGenTokenizer:()=>mr,CodeLlamaTokenizer:()=>Jn,CohereTokenizer:()=>Tr,ConvBertForMaskedLM:()=>Ds,ConvBertForQuestionAnswering:()=>Ms,ConvBertForSequenceClassification:()=>Fs,ConvBertForTokenClassification:()=>Rs,ConvBertModel:()=>Os,ConvBertPreTrainedModel:()=>$s,ConvBertTokenizer:()=>Pn,ConvNextFeatureExtractor:()=>Hd,ConvNextForImageClassification:()=>El,ConvNextImageProcessor:()=>qd,ConvNextModel:()=>Il,ConvNextPreTrainedModel:()=>Tl,ConvNextV2ForImageClassification:()=>Nl,ConvNextV2Model:()=>Cl,ConvNextV2PreTrainedModel:()=>Al,DPTFeatureExtractor:()=>zd,DPTForDepthEstimation:()=>bl,DPTImageProcessor:()=>Bd,DPTModel:()=>gl,DPTPreTrainedModel:()=>ml,DebertaForMaskedLM:()=>Xs,DebertaForQuestionAnswering:()=>ea,DebertaForSequenceClassification:()=>Qs,DebertaForTokenClassification:()=>Js,DebertaModel:()=>Ys,DebertaPreTrainedModel:()=>Ks,DebertaTokenizer:()=>Rn,DebertaV2ForMaskedLM:()=>ra,DebertaV2ForQuestionAnswering:()=>ia,DebertaV2ForSequenceClassification:()=>sa,DebertaV2ForTokenClassification:()=>aa,DebertaV2Model:()=>na,DebertaV2PreTrainedModel:()=>ta,DebertaV2Tokenizer:()=>Mn,DeiTFeatureExtractor:()=>eh,DeiTForImageClassification:()=>al,DeiTModel:()=>sl,DeiTPreTrainedModel:()=>rl,DepthAnythingForDepthEstimation:()=>wl,DepthAnythingPreTrainedModel:()=>yl,DepthEstimationPipeline:()=>Yh,DetrFeatureExtractor:()=>sh,DetrForObjectDetection:()=>Ko,DetrForSegmentation:()=>Yo,DetrModel:()=>Zo,DetrObjectDetectionOutput:()=>Xo,DetrPreTrainedModel:()=>qo,DetrSegmentationOutput:()=>Qo,Dinov2ForImageClassification:()=>Dl,Dinov2Model:()=>Ol,Dinov2PreTrainedModel:()=>$l,DistilBertForMaskedLM:()=>ha,DistilBertForQuestionAnswering:()=>da,DistilBertForSequenceClassification:()=>ua,DistilBertForTokenClassification:()=>ca,DistilBertModel:()=>la,DistilBertPreTrainedModel:()=>oa,DistilBertTokenizer:()=>Bn,DocumentQuestionAnsweringPipeline:()=>qh,DonutFeatureExtractor:()=>nh,DonutSwinModel:()=>Sl,DonutSwinPreTrainedModel:()=>kl,EfficientNetForImageClassification:()=>Qu,EfficientNetImageProcessor:()=>Yd,EfficientNetModel:()=>Xu,EfficientNetPreTrainedModel:()=>Yu,ElectraForMaskedLM:()=>zs,ElectraForQuestionAnswering:()=>Us,ElectraForSequenceClassification:()=>Bs,ElectraForTokenClassification:()=>Vs,ElectraModel:()=>Ps,ElectraPreTrainedModel:()=>Ls,ElectraTokenizer:()=>jn,EsmForMaskedLM:()=>ma,EsmForSequenceClassification:()=>ga,EsmForTokenClassification:()=>ba,EsmModel:()=>fa,EsmPreTrainedModel:()=>pa,EsmTokenizer:()=>sr,FFT:()=>re,FalconForCausalLM:()=>Mu,FalconModel:()=>Ru,FalconPreTrainedModel:()=>Fu,FalconTokenizer:()=>nr,FeatureExtractionPipeline:()=>Mh,FeatureExtractor:()=>Md,FillMaskPipeline:()=>Ch,GLPNFeatureExtractor:()=>Ud,GLPNForDepthEstimation:()=>_l,GLPNModel:()=>xl,GLPNPreTrainedModel:()=>vl,GPT2LMHeadModel:()=>Ki,GPT2Model:()=>Zi,GPT2PreTrainedModel:()=>qi,GPT2Tokenizer:()=>Gn,GPTBigCodeForCausalLM:()=>oo,GPTBigCodeModel:()=>io,GPTBigCodePreTrainedModel:()=>ao,GPTJForCausalLM:()=>so,GPTJModel:()=>ro,GPTJPreTrainedModel:()=>no,GPTNeoForCausalLM:()=>Qi,GPTNeoModel:()=>Xi,GPTNeoPreTrainedModel:()=>Yi,GPTNeoXForCausalLM:()=>to,GPTNeoXModel:()=>eo,GPTNeoXPreTrainedModel:()=>Ji,GPTNeoXTokenizer:()=>rr,GemmaTokenizer:()=>ir,Grok1Tokenizer:()=>or,HerbertTokenizer:()=>Ln,HubertForCTC:()=>pu,HubertForSequenceClassification:()=>fu,HubertModel:()=>hu,HubertPreTrainedModel:()=>du,ImageClassificationPipeline:()=>Uh,ImageFeatureExtractionPipeline:()=>Lh,ImageFeatureExtractor:()=>Ld,ImageMattingOutput:()=>cd,ImageSegmentationPipeline:()=>jh,ImageToImagePipeline:()=>Kh,ImageToTextPipeline:()=>Vh,LlamaForCausalLM:()=>fo,LlamaModel:()=>po,LlamaPreTrainedModel:()=>ho,LlamaTokenizer:()=>Qn,LongT5ForConditionalGeneration:()=>Wa,LongT5Model:()=>ja,LongT5PreTrainedModel:()=>Ua,M2M100ForConditionalGeneration:()=>Hl,M2M100Model:()=>Gl,M2M100PreTrainedModel:()=>Wl,M2M100Tokenizer:()=>cr,MBart50Tokenizer:()=>Zn,MBartForCausalLM:()=>ni,MBartForConditionalGeneration:()=>ei,MBartForSequenceClassification:()=>ti,MBartModel:()=>Ja,MBartPreTrainedModel:()=>Qa,MBartTokenizer:()=>qn,MPNetForMaskedLM:()=>Ta,MPNetForQuestionAnswering:()=>Aa,MPNetForSequenceClassification:()=>Ia,MPNetForTokenClassification:()=>Ea,MPNetModel:()=>Sa,MPNetPreTrainedModel:()=>ka,MPNetTokenizer:()=>tr,MT5ForConditionalGeneration:()=>qa,MT5Model:()=>Ha,MT5PreTrainedModel:()=>Ga,MarianMTModel:()=>jl,MarianModel:()=>Ul,MarianPreTrainedModel:()=>Vl,MarianTokenizer:()=>yr,MaskedLMOutput:()=>id,MistralForCausalLM:()=>Nu,MistralModel:()=>Cu,MistralPreTrainedModel:()=>Au,MobileBertForMaskedLM:()=>va,MobileBertForQuestionAnswering:()=>_a,MobileBertForSequenceClassification:()=>xa,MobileBertModel:()=>wa,MobileBertPreTrainedModel:()=>ya,MobileBertTokenizer:()=>Dn,MobileViTFeatureExtractor:()=>Xd,MobileViTForImageClassification:()=>Lo,MobileViTModel:()=>Mo,MobileViTPreTrainedModel:()=>Ro,ModelOutput:()=>ms,MptForCausalLM:()=>Io,MptModel:()=>To,MptPreTrainedModel:()=>So,NllbTokenizer:()=>ur,NomicBertModel:()=>Ss,NomicBertPreTrainedModel:()=>ks,NougatImageProcessor:()=>rh,NougatTokenizer:()=>kr,OPTForCausalLM:()=>Co,OPTModel:()=>Ao,OPTPreTrainedModel:()=>Eo,ObjectDetectionPipeline:()=>Gh,OwlViTFeatureExtractor:()=>Qd,OwlViTForObjectDetection:()=>Bo,OwlViTModel:()=>zo,OwlViTPreTrainedModel:()=>Po,OwlViTProcessor:()=>vh,Owlv2ForObjectDetection:()=>jo,Owlv2ImageProcessor:()=>Jd,Owlv2Model:()=>Uo,Owlv2PreTrainedModel:()=>Vo,PhiForCausalLM:()=>vo,PhiModel:()=>wo,PhiPreTrainedModel:()=>yo,Pipeline:()=>Th,PreTrainedModel:()=>fs,PreTrainedTokenizer:()=>Nn,PretrainedConfig:()=>Er,PretrainedMixin:()=>Ju,Processor:()=>mh,QuestionAnsweringModelOutput:()=>od,QuestionAnsweringPipeline:()=>Ah,Qwen2ForCausalLM:()=>bo,Qwen2Model:()=>go,Qwen2PreTrainedModel:()=>mo,Qwen2Tokenizer:()=>ar,RawImage:()=>vd,ResNetForImageClassification:()=>ll,ResNetModel:()=>ol,ResNetPreTrainedModel:()=>il,RoFormerForMaskedLM:()=>Es,RoFormerForQuestionAnswering:()=>Ns,RoFormerForSequenceClassification:()=>As,RoFormerForTokenClassification:()=>Cs,RoFormerModel:()=>Is,RoFormerPreTrainedModel:()=>Ts,RoFormerTokenizer:()=>zn,RobertaForMaskedLM:()=>di,RobertaForQuestionAnswering:()=>fi,RobertaForSequenceClassification:()=>hi,RobertaForTokenClassification:()=>pi,RobertaModel:()=>ci,RobertaPreTrainedModel:()=>ui,RobertaTokenizer:()=>Kn,SamImageProcessor:()=>ih,SamImageSegmentationOutput:()=>Bl,SamModel:()=>zl,SamPreTrainedModel:()=>Pl,SamProcessor:()=>gh,SeamlessM4TFeatureExtractor:()=>dh,SegformerFeatureExtractor:()=>Pd,SegformerForImageClassification:()=>Gu,SegformerForSemanticSegmentation:()=>Hu,SegformerModel:()=>Wu,SegformerPreTrainedModel:()=>ju,Seq2SeqLMOutput:()=>nd,SequenceClassifierOutput:()=>rd,SiglipImageProcessor:()=>Gd,SiglipModel:()=>zi,SiglipPreTrainedModel:()=>Pi,SiglipTextModel:()=>Bi,SiglipTokenizer:()=>br,SiglipVisionModel:()=>Vi,SpeechT5FeatureExtractor:()=>fh,SpeechT5ForSpeechToText:()=>ku,SpeechT5ForTextToSpeech:()=>Su,SpeechT5HifiGan:()=>Tu,SpeechT5Model:()=>_u,SpeechT5PreTrainedModel:()=>xu,SpeechT5Processor:()=>wh,SpeechT5Tokenizer:()=>_r,SqueezeBertForMaskedLM:()=>$a,SqueezeBertForQuestionAnswering:()=>Da,SqueezeBertForSequenceClassification:()=>Oa,SqueezeBertModel:()=>Na,SqueezeBertPreTrainedModel:()=>Ca,SqueezeBertTokenizer:()=>Fn,StableLmForCausalLM:()=>Ku,StableLmModel:()=>Zu,StableLmPreTrainedModel:()=>qu,Starcoder2ForCausalLM:()=>Du,Starcoder2Model:()=>Ou,Starcoder2PreTrainedModel:()=>$u,SummarizationPipeline:()=>$h,Swin2SRForImageSuperResolution:()=>fl,Swin2SRImageProcessor:()=>oh,Swin2SRModel:()=>pl,Swin2SRPreTrainedModel:()=>hl,SwinForImageClassification:()=>dl,SwinModel:()=>cl,SwinPreTrainedModel:()=>ul,T5ForConditionalGeneration:()=>Va,T5Model:()=>Ba,T5PreTrainedModel:()=>za,T5Tokenizer:()=>Wn,TableTransformerForObjectDetection:()=>tl,TableTransformerModel:()=>el,TableTransformerObjectDetectionOutput:()=>nl,TableTransformerPreTrainedModel:()=>Jo,Tensor:()=>ue,Text2TextGenerationPipeline:()=>Nh,TextClassificationPipeline:()=>Ih,TextGenerationPipeline:()=>Fh,TextToAudioPipeline:()=>Zh,TokenClassificationPipeline:()=>Eh,TokenClassifierOutput:()=>ad,TokenizerModel:()=>Ot,TrOCRForCausalLM:()=>Eu,TrOCRPreTrainedModel:()=>Iu,TranslationPipeline:()=>Oh,UniSpeechForCTC:()=>eu,UniSpeechForSequenceClassification:()=>tu,UniSpeechModel:()=>Jl,UniSpeechPreTrainedModel:()=>Ql,UniSpeechSatForAudioFrameClassification:()=>iu,UniSpeechSatForCTC:()=>su,UniSpeechSatForSequenceClassification:()=>au,UniSpeechSatModel:()=>ru,UniSpeechSatPreTrainedModel:()=>nu,ViTFeatureExtractor:()=>Zd,ViTForImageClassification:()=>Oo,ViTImageProcessor:()=>Kd,ViTModel:()=>$o,ViTPreTrainedModel:()=>No,VisionEncoderDecoderModel:()=>Di,VitMatteForImageMatting:()=>Fo,VitMatteImageProcessor:()=>lh,VitMattePreTrainedModel:()=>Do,VitsModel:()=>Uu,VitsModelOutput:()=>dd,VitsPreTrainedModel:()=>Vu,VitsTokenizer:()=>Sr,Wav2Vec2BertForCTC:()=>uu,Wav2Vec2BertForSequenceClassification:()=>cu,Wav2Vec2BertModel:()=>lu,Wav2Vec2BertPreTrainedModel:()=>ou,Wav2Vec2CTCTokenizer:()=>wr,Wav2Vec2FeatureExtractor:()=>ch,Wav2Vec2ForAudioFrameClassification:()=>Xl,Wav2Vec2ForCTC:()=>Kl,Wav2Vec2ForSequenceClassification:()=>Yl,Wav2Vec2Model:()=>Zl,Wav2Vec2PreTrainedModel:()=>ql,Wav2Vec2ProcessorWithLM:()=>yh,WavLMForAudioFrameClassification:()=>vu,WavLMForCTC:()=>bu,WavLMForSequenceClassification:()=>yu,WavLMForXVector:()=>wu,WavLMModel:()=>gu,WavLMPreTrainedModel:()=>mu,WhisperFeatureExtractor:()=>uh,WhisperForConditionalGeneration:()=>Oi,WhisperModel:()=>$i,WhisperPreTrainedModel:()=>Ni,WhisperProcessor:()=>bh,WhisperTokenizer:()=>fr,XLMForQuestionAnswering:()=>vi,XLMForSequenceClassification:()=>yi,XLMForTokenClassification:()=>wi,XLMModel:()=>gi,XLMPreTrainedModel:()=>mi,XLMRobertaForMaskedLM:()=>ki,XLMRobertaForQuestionAnswering:()=>Ii,XLMRobertaForSequenceClassification:()=>Si,XLMRobertaForTokenClassification:()=>Ti,XLMRobertaModel:()=>_i,XLMRobertaPreTrainedModel:()=>xi,XLMRobertaTokenizer:()=>er,XLMTokenizer:()=>Un,XLMWithLMHeadModel:()=>bi,XVectorOutput:()=>sd,YolosFeatureExtractor:()=>ah,YolosForObjectDetection:()=>Ml,YolosModel:()=>Rl,YolosObjectDetectionOutput:()=>Ll,YolosPreTrainedModel:()=>Fl,ZeroShotAudioClassificationPipeline:()=>zh,ZeroShotClassificationPipeline:()=>Rh,ZeroShotImageClassificationPipeline:()=>Wh,ZeroShotObjectDetectionPipeline:()=>Hh,bankers_round:()=>ie,cat:()=>be,cos_sim:()=>Y,dot:()=>Z,dynamicTimeWarping:()=>xe,env:()=>F,getTopItems:()=>K,hanning:()=>_d,interpolate:()=>de,interpolate_data:()=>W,layer_norm:()=>pe,log_softmax:()=>q,magnitude:()=>X,max:()=>J,mean:()=>ve,mean_pooling:()=>he,medianFilter:()=>se,mel_filter_bank:()=>Ed,min:()=>Q,ones:()=>_e,ones_like:()=>ke,permute:()=>ce,permute_data:()=>G,pipeline:()=>Jh,quantize_embeddings:()=>Se,read_audio:()=>xd,round:()=>ae,softmax:()=>H,spectrogram:()=>Cd,stack:()=>ye,std_mean:()=>we,window_function:()=>Nd});const a=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}};function i(e){return Number.isInteger(e)||"bigint"==typeof e}function o(e){const t=[];let n=e;for(;Array.isArray(n);)t.push(n.length),n=n[0];return t}function l(e,t,n=void 0){const r=e[t];if(void 0!==r)return delete e[t],r;if(void 0===n)throw Error(`Key ${t} does not exist in object.`);return n}function u(...e){return Array.prototype.concat.apply([],e)}function c(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,t]))))))}function d(e,t){return Math.abs((e+t)%(2*t)-t)}var h=n(143),p=n(2603),f=n(2853),m=n(2009),g=n(6837),b=n(2499),y=n(3052),w=n.t(y,2),v=n(9570),x=n.t(v,2);let _;const k=["wasm"];"undefined"!=typeof process&&"node"===process?.release?.name?(_=y??w,k.unshift("cpu")):(_=v??x,"undefined"!=typeof navigator&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(_.env.wasm.simd=!1));const{env:S}=_,T="2.17.1",I="undefined"!=typeof self&&"caches"in self,E=!R(m),A=!R(g),C=E&&A,N=C?g.dirname(g.dirname(b.fileURLToPath("file:///home/runner/work/web-llm/web-llm/node_modules/@xenova/transformers/src/env.js"))):"./",$=C?g.join(N,"/.cache/"):null,O="/models/",D=C?g.join(N,O):O;S?.wasm&&(S.wasm.wasmPaths=C?g.join(N,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${T}/dist/`);const F={backends:{onnx:S,tfjs:{}},__dirname:N,version:T,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath:D,useFS:E,useBrowserCache:I,useFSCache:E,cacheDir:$,useCustomCache:!1,customCache:null};function R(e){return 0===Object.keys(e).length}globalThis.ReadableStream||(globalThis.ReadableStream=f.ReadableStream);class M{_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=h.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=h.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();let n=this;this.body=new ReadableStream({start(e){n.arrayBuffer().then((t=>{e.enqueue(new Uint8Array(t)),e.close()}))}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[e]??"application/octet-stream")}clone(){let e=new M(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await h.promises.readFile(this.filePath)).buffer}async blob(){const e=await h.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await h.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function L(e,t=null){let n;try{n=new URL(e)}catch(e){return!1}return!(t&&!t.includes(n.hostname)||"http:"!==n.protocol&&"https:"!==n.protocol)}async function P(e){if(F.useFS&&!L(e))return new M(e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=F.version,r=new Headers;if(r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`),L(e,["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const z={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class B{constructor(e){this.path=e}async match(e){let t=p.join(this.path,e),n=new M(t);return n.exists?n:void 0}async put(e,t){const n=Buffer.from(await t.arrayBuffer());let r=p.join(this.path,e);try{await h.promises.mkdir(p.dirname(r),{recursive:!0}),await h.promises.writeFile(r,n)}catch(e){console.warn("An error occurred while writing the file to cache:",e)}}}async function V(e,t,n=!0,s={}){if(!F.allowLocalModels){if(s.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!F.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let a;if(r(s.progress_callback,{status:"initiate",name:e,file:t}),!a&&F.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{a=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!a&&F.useFSCache&&(a=new B(s.cache_dir??F.cacheDir)),!a&&F.useCustomCache){if(!F.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!F.customCache.match||!F.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");a=F.customCache}const i=s.revision??"main";let o,l,u=j(e,t),c=j(F.localModelPath,u),d=j(F.remoteHost,F.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(i)),t),h="main"===i?u:j(e,i,t),p=a instanceof B?h:d,f=!1;a&&(l=await async function(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(a,c,p));const m=void 0!==l;if(void 0===l){if(F.allowLocalModels)if(L(u)){if(s.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${u}.`);if(!F.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${u}.`)}else try{l=await P(c),o=c}catch(e){console.warn(`Unable to load from local path "${c}": "${e}"`)}if(void 0===l||404===l.status){if(s.local_files_only||!F.allowRemoteModels){if(n)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${c}".`);return null}if(l=await P(d),200!==l.status)return function(e,t,n){if(!n)return null;const r=z[e]??`Error (${e}) occurred while trying to load file`;throw Error(`${r}: "${t}".`)}(l.status,d,n);o=p}f=a&&"undefined"!=typeof Response&&l instanceof Response&&200===l.status}r(s.progress_callback,{status:"download",name:e,file:t});const g={status:"progress",name:e,file:t};let b;return s.progress_callback?m&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(b=new Uint8Array(await l.arrayBuffer()),r(s.progress_callback,{...g,progress:100,loaded:b.length,total:b.length})):b=await async function(e,t){const n=e.headers.get("Content-Length");null===n&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let a=parseInt(n??"0"),i=new Uint8Array(a),o=0;const l=e.body.getReader();return await async function e(){const{done:t,value:n}=await l.read();if(t)return;let u=o+n.length;if(u>a){a=u;let e=new Uint8Array(a);e.set(i),i=e}return i.set(n,o),o=u,(e=>{r(s.progress_callback,{...g,...e})})({progress:o/a*100,loaded:o,total:a}),e()}(),i}(l):b=new Uint8Array(await l.arrayBuffer()),f&&o&&void 0===await a.match(o)&&await a.put(o,new Response(b,{headers:l.headers})).catch((e=>{console.warn(`Unable to add response to browser cache: ${e}.`)})),r(s.progress_callback,{status:"done",name:e,file:t}),b}async function U(e,t,n=!0,r={}){let s=await V(e,t,n,r);if(null===s)return{};let a=new TextDecoder("utf-8").decode(s);return JSON.parse(a)}function j(...e){return(e=e.map(((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t)))).join("/")}function W(e,[t,n,r],[s,a],i="bilinear",o=!1){const l=a/r,u=s/n,c=new e.constructor(s*a*t),d=n*r,h=s*a;for(let i=0;i<s;++i)for(let s=0;s<a;++s){const o=i*a+s,p=(s+.5)/l-.5,f=(i+.5)/u-.5;let m=Math.floor(p),g=Math.floor(f);const b=Math.min(m+1,r-1),y=Math.min(g+1,n-1);m=Math.max(m,0),g=Math.max(g,0);const w=p-m,v=f-g,x=(1-w)*(1-v),_=w*(1-v),k=(1-w)*v,S=w*v,T=g*r,I=y*r,E=T+m,A=T+b,C=I+m,N=I+b;for(let n=0;n<t;++n){const t=n*d;c[n*h+o]=x*e[t+E]+_*e[t+A]+k*e[t+C]+S*e[t+N]}}return c}function G(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,a=1;e>=0;--e)s[e]=a,r[e]=t[n[e]],a*=r[e];const a=n.map(((e,t)=>s[n.indexOf(t)])),i=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*a[e],s=Math.floor(s/t[e]);i[r]=e[n]}return[i,r]}function H(e){const t=J(e)[0],n=e.map((e=>Math.exp(e-t))),r=n.reduce(((e,t)=>e+t),0);return n.map((e=>e/r))}function q(e){return H(e).map((e=>Math.log(e)))}function Z(e,t){let n=0;for(let r=0;r<e.length;++r)n+=e[r]*t[r];return n}function K(e,t=0){return e=Array.from(e).map(((e,t)=>[t,e])).sort(((e,t)=>t[1]-e[1])),null!==t&&t>0&&(e=e.slice(0,t)),e}function Y(e,t){return Z(e,t)/(X(e)*X(t))}function X(e){return Math.sqrt(e.reduce(((e,t)=>e+t*t),0))}function Q(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}function J(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[Number(t),n]}function ee(e){return e>0&&!(e&e-1)}class te{constructor(e){if(this.size=0|e,this.size<=1||!ee(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const n=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<n}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const n=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)n[t>>>1]=e[t];return n}toComplexArray(e,t){const n=t||this.createComplexArray();for(let t=0;t<n.length;t+=2)n[t]=e[t>>>1],n[t+1]=0;return n}completeSpectrum(e){const t=this._csize,n=t>>>1;for(let r=2;r<n;r+=2)e[t-r]=e[r],e[t-r+1]=-e[r+1]}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,n){const r=this._csize;let s,a,i=1<<this._width,o=r/i<<1;const l=this._bitrev;if(4===o)for(s=0,a=0;s<r;s+=o,++a){const n=l[a];this._singleTransform2(t,e,s,n,i)}else for(s=0,a=0;s<r;s+=o,++a){const r=l[a];this._singleTransform4(t,e,s,r,i,n)}for(i>>=2;i>=2;i>>=2){o=r/i<<1;const t=o>>>2;for(s=0;s<r;s+=o){const r=s+t-1;for(let a=s,o=0;a<r;a+=2,o+=i){const r=a,s=r+t,i=s+t,l=i+t,u=e[r],c=e[r+1],d=e[s],h=e[s+1],p=e[i],f=e[i+1],m=e[l],g=e[l+1],b=this.table[o],y=n*this.table[o+1],w=d*b-h*y,v=d*y+h*b,x=this.table[2*o],_=n*this.table[2*o+1],k=p*x-f*_,S=p*_+f*x,T=this.table[3*o],I=n*this.table[3*o+1],E=m*T-g*I,A=m*I+g*T,C=u+k,N=c+S,$=u-k,O=c-S,D=w+E,F=v+A,R=n*(w-E),M=n*(v-A);e[r]=C+D,e[r+1]=N+F,e[s]=$+M,e[s+1]=O-R,e[i]=C-D,e[i+1]=N-F,e[l]=$-M,e[l+1]=O+R}}}}_singleTransform2(e,t,n,r,s){const a=e[r],i=e[r+1],o=e[r+s],l=e[r+s+1];t[n]=a+o,t[n+1]=i+l,t[n+2]=a-o,t[n+3]=i-l}_singleTransform4(e,t,n,r,s,a){const i=2*s,o=3*s,l=e[r],u=e[r+1],c=e[r+s],d=e[r+s+1],h=e[r+i],p=e[r+i+1],f=e[r+o],m=e[r+o+1],g=l+h,b=u+p,y=l-h,w=u-p,v=c+f,x=d+m,_=a*(c-f),k=a*(d-m);t[n]=g+v,t[n+1]=b+x,t[n+2]=y+k,t[n+3]=w-_,t[n+4]=g-v,t[n+5]=b-x,t[n+6]=y-k,t[n+7]=w+_}_realTransform4(e,t,n){const r=this._csize;let s,a,i=1<<this._width,o=r/i<<1;const l=this._bitrev;if(4===o)for(s=0,a=0;s<r;s+=o,++a){const n=l[a];this._singleRealTransform2(t,e,s,n>>>1,i>>>1)}else for(s=0,a=0;s<r;s+=o,++a){const r=l[a];this._singleRealTransform4(t,e,s,r>>>1,i>>>1,n)}for(i>>=2;i>=2;i>>=2){o=r/i<<1;const t=o>>>2;for(s=0;s<r;s+=o){const r=s+t-1;for(let a=s,o=0;a<r;a+=2,o+=i){const r=a,s=r+t,i=s+t,l=i+t,u=e[r],c=e[r+1],d=e[s],h=e[s+1],p=e[i],f=e[i+1],m=e[l],g=e[l+1],b=this.table[o],y=n*this.table[o+1],w=d*b-h*y,v=d*y+h*b,x=this.table[2*o],_=n*this.table[2*o+1],k=p*x-f*_,S=p*_+f*x,T=this.table[3*o],I=n*this.table[3*o+1],E=m*T-g*I,A=m*I+g*T,C=u+k,N=c+S,$=u-k,O=c-S,D=w+E,F=v+A,R=n*(w-E),M=n*(v-A);e[r]=C+D,e[r+1]=N+F,e[s]=$+M,e[s+1]=O-R,e[i]=C-D,e[i+1]=N-F,e[l]=$-M,e[l+1]=O+R}}}}_singleRealTransform2(e,t,n,r,s){const a=e[r],i=e[r+s];t[n]=a+i,t[n+1]=0,t[n+2]=a-i,t[n+3]=0}_singleRealTransform4(e,t,n,r,s,a){const i=2*s,o=3*s,l=e[r],u=e[r+s],c=e[r+i],d=e[r+o],h=l+c,p=l-c,f=u+d,m=a*(u-d);t[n]=h+f,t[n+1]=0,t[n+2]=p,t[n+3]=-m,t[n+4]=h-f,t[n+5]=0,t[n+6]=p,t[n+7]=m}}class ne{constructor(e){const t=2*(e-1),n=2*(2*e-1),r=2**Math.ceil(Math.log2(n));this.bufferSize=r,this._a=t;const s=new Float64Array(n),a=new Float64Array(r);this._chirpBuffer=new Float64Array(r),this._buffer1=new Float64Array(r),this._buffer2=new Float64Array(r),this._outBuffer1=new Float64Array(r),this._outBuffer2=new Float64Array(r);const i=-2*Math.PI/e,o=Math.cos(i),l=Math.sin(i);for(let t=0;t<n>>1;++t){const n=(t+1-e)**2/2,r=Math.sqrt(o**2+l**2)**n,i=n*Math.atan2(l,o),u=2*t;s[u]=r*Math.cos(i),s[u+1]=r*Math.sin(i),a[u]=s[u],a[u+1]=-s[u+1]}this._slicedChirpBuffer=s.subarray(t,n),this._f=new te(r>>1),this._f.transform(this._chirpBuffer,a)}_transform(e,t,n){const r=this._buffer1,s=this._buffer2,a=this._outBuffer1,i=this._outBuffer2,o=this._chirpBuffer,l=this._slicedChirpBuffer,u=this._a;if(n)for(let e=0;e<l.length;e+=2){const n=e+1,s=t[e>>1];r[e]=s*l[e],r[n]=s*l[n]}else for(let e=0;e<l.length;e+=2){const n=e+1;r[e]=t[e]*l[e]-t[n]*l[n],r[n]=t[e]*l[n]+t[n]*l[e]}this._f.transform(a,r);for(let e=0;e<o.length;e+=2){const t=e+1;s[e]=a[e]*o[e]-a[t]*o[t],s[t]=a[e]*o[t]+a[t]*o[e]}this._f.inverseTransform(i,s);for(let t=0;t<i.length;t+=2){const n=i[t+u],r=i[t+u+1],s=l[t],a=l[t+1];e[t]=n*s-r*a,e[t+1]=n*a+r*s}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class re{constructor(e){this.fft_length=e,this.isPowerOfTwo=ee(e),this.isPowerOfTwo?(this.fft=new te(e),this.outputBufferSize=2*e):(this.fft=new ne(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function se(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let a=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[a++]=e[s]}r.sort(),n[t]=r[s]}return n}function ae(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}function ie(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}const oe=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),le=_.Tensor;class ue{dims;type;data;size;constructor(...e){return e[0]instanceof le?Object.assign(this,e[0]):Object.assign(this,new le(e[0],e[1],e[2])),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce(((e,t)=>e*t));for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=ge(e,t),n.length>0){const t=n.reduce(((e,t)=>e*t));return this._subarray(e,t,n)}return new ue(this.type,[this.data[e]],n)}indexOf(e){for(let t=0;t<this.data.length;++t)if(this.data[t]==e)return t;return-1}_subarray(e,t,n){const r=e*t,s=(e+1)*t,a="subarray"in this.data?this.data.subarray(r,s):this.data.slice(r,s);return new ue(this.type,a,n)}item(){if(1!==this.data.length)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return function(e,t){const n=e.length;if(n!==t.reduce(((e,t)=>e*t)))throw Error(`cannot reshape array of size ${n} into shape (${t})`);let r=e;for(let e=t.length-1;e>=0;e--)r=r.reduce(((n,r)=>{let s=n[n.length-1];return s.length<t[e]?s.push(r):n.push([r]),n}),[[]]);return r[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let e=0;e<this.data.length;++e)this.data[e]=1/(1+Math.exp(-this.data[e]));return this}mul(e){return this.clone().mul_(e)}mul_(e){for(let t=0;t<this.data.length;++t)this.data[t]*=e;return this}add(e){return this.clone().add_(e)}add_(e){for(let t=0;t<this.data.length;++t)this.data[t]+=e;return this}clone(){return new ue(this.type,this.data.slice(),this.dims.slice())}slice(...e){let t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=ge(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{if(s[0]>s[1])throw new Error(`Invalid slice: ${s}`);let e=[Math.max(s[0],0),Math.min(s[1],this.dims[r])];n.push(e),t.push(e[1]-e[0])}}}let r=n.map((([e,t])=>t-e)),s=r.reduce(((e,t)=>e*t)),a=new this.data.constructor(s);const i=this.stride();for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,a=e;s>=0;--s){const e=r[s];t+=(a%e+n[s][0])*i[s],a=Math.floor(a/e)}a[e]=this.data[t]}return new ue(this.type,a,t)}permute(...e){return ce(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);if(null===t){let t=this.data.reduce(((t,n)=>t+n**e),0)**(1/e);return new ue(this.type,[t],[])}t=ge(t,this.dims.length);const r=this.dims.slice();r[t]=1;const s=new this.data.constructor(this.data.length/this.dims[t]);for(let n=0;n<this.data.length;++n){let a=0;for(let e=this.dims.length-1,s=n,i=1;e>=0;--e){const n=this.dims[e];e!==t&&(a+=s%n*i,i*=r[e]),s=Math.floor(s/n)}s[a]+=this.data[n]**e}if(1!==e)for(let t=0;t<s.length;++t)s[t]=s[t]**(1/e);return n||r.splice(t,1),new ue(this.type,s,r)}normalize_(e=2,t=1){t=ge(t,this.dims.length);const n=this.norm(e,t,!0);for(let e=0;e<this.data.length;++e){let r=0;for(let n=this.dims.length-1,s=e,a=1;n>=0;--n){const e=this.dims[n];n!==t&&(r+=s%e*a,a*=this.dims[n]),s=Math.floor(s/e)}this.data[e]/=n.data[r]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function(e){const t=new Array(e.length);for(let n=e.length-1,r=1;n>=0;--n)t[n]=r,r*=e[n];return t}(this.dims)}squeeze(e=null){return new ue(this.type,this.data,fe(this.dims,e))}squeeze_(e=null){return this.dims=fe(this.dims,e),this}unsqueeze(e=null){return new ue(this.type,this.data,me(this.dims,e))}unsqueeze_(e=null){return this.dims=me(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce(((e,t)=>e*t),1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}if(-1!==t){const n=e.reduce(((e,n,r)=>r!==t?e*n:e),1);e[t]=this.data.length/n}return new ue(this.type,this.data,e)}neg_(){for(let e=0;e<this.data.length;++e)this.data[e]=-this.data[e];return this}neg(){return this.clone().neg_()}clamp_(e,t){for(let n=0;n<this.data.length;++n)this.data[n]=Math.min(Math.max(this.data[n],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){for(let e=0;e<this.data.length;++e)this.data[e]=Math.round(this.data[e]);return this}round(){return this.clone().round_()}to(e){if(this.type===e)return this;if(!oe.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);return new ue(e,oe[e].from(this.data),this.dims)}}function ce(e,t){const[n,r]=G(e.data,e.dims,t);return new ue(e.type,n,r)}function de(e,[t,n],r="bilinear",s=!1){const a=e.dims.at(-3)??1,i=e.dims.at(-2),o=e.dims.at(-1);let l=W(e.data,[a,i,o],[t,n],r,s);return new ue(e.type,l,[a,t,n])}function he(e,t){let n=[e.dims[0],e.dims[2]],r=new e.data.constructor(n[0]*n[1]),[s,a,i]=e.dims,o=0;for(let n=0;n<s;++n){let s=n*i*a;for(let l=0;l<i;++l){let u=0,c=0,d=n*a,h=s+l;for(let n=0;n<a;++n){let r=Number(t.data[d+n]);c+=r,u+=e.data[h+n*i]*r}let p=u/c;r[o++]=p}}return new ue(e.type,r,n)}function pe(e,t,{eps:n=1e-5}={}){if(2!==e.dims.length)throw new Error("`layer_norm` currently only supports 2D input.");const[r,s]=e.dims;if(1!==t.length&&t[0]!==s)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[a,i]=we(e,1,0,!0),o=new e.data.constructor(e.data.length);for(let t=0;t<r;++t){const r=t*s;for(let l=0;l<s;++l){const s=r+l;o[s]=(e.data[s]-i.data[t])/(a.data[t]+n)}}return new ue(e.type,o,e.dims)}function fe(e,t){return e=e.slice(),null===t?e=e.filter((e=>1!==e)):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter(((e,n)=>1!==e||!t.includes(n)))),e}function me(e,t){return t=ge(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function ge(e,t,n=null){if(e<-t||e>=t)throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<0&&(e=(e%t+t)%t),e}function be(e,t=0){t=ge(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce(((e,n)=>e+n.dims[t]),0);const r=n.reduce(((e,t)=>e*t),1),s=new e[0].data.constructor(r),a=e[0].type;if(0===t){let t=0;for(let n of e)s.set(n.data,t),t+=n.data.length}else{let r=0;for(let a=0;a<e.length;++a){let i=e[a];for(let e=0;e<i.data.length;++e){let a=0;for(let s=i.dims.length-1,o=e,l=1;s>=0;--s){const e=i.dims[s];let u=o%e;s===t&&(u+=r),a+=u*l,l*=n[s],o=Math.floor(o/e)}s[a]=i.data[e]}r+=i.dims[t]}}return new ue(a,s,n)}function ye(e,t=0){return be(e.map((e=>e.unsqueeze(t))),t)}function we(e,t=null,n=1,r=!1){if(null===t){const t=e.data.reduce(((e,t)=>e+t),0)/e.data.length,r=Math.sqrt(e.data.reduce(((e,n)=>e+(n-t)**2),0)/(e.data.length-n)),s=new ue(e.type,[t],[]);return[new ue(e.type,[r],[]),s]}const s=ve(e,t=ge(t,e.dims.length),r),a=e.dims.slice();a[t]=1;const i=new e.data.constructor(e.data.length/e.dims[t]);for(let n=0;n<e.data.length;++n){let r=0;for(let s=e.dims.length-1,i=n,o=1;s>=0;--s){const n=e.dims[s];s!==t&&(r+=i%n*o,o*=a[s]),i=Math.floor(i/n)}i[r]+=(e.data[n]-s.data[r])**2}for(let r=0;r<i.length;++r)i[r]=Math.sqrt(i[r]/(e.dims[t]-n));return r||a.splice(t,1),[new ue(e.type,i,a),s]}function ve(e,t=null,n=!1){if(null===t){let t=e.data.reduce(((e,t)=>e+t),0);return new ue(e.type,[t/e.data.length],[])}t=ge(t,e.dims.length);const r=e.dims.slice();r[t]=1;const s=new e.data.constructor(e.data.length/e.dims[t]);for(let n=0;n<e.data.length;++n){let a=0;for(let s=e.dims.length-1,i=n,o=1;s>=0;--s){const n=e.dims[s];s!==t&&(a+=i%n*o,o*=r[s]),i=Math.floor(i/n)}s[a]+=e.data[n]}if(1!==e.dims[t])for(let n=0;n<s.length;++n)s[n]=s[n]/e.dims[t];return n||r.splice(t,1),new ue(e.type,s,r)}function xe(e){const[t,n]=e.dims,r=[t+1,n+1],s=new ue("float32",new Float32Array(r[0]*r[1]).fill(1/0),r),a=new ue("float32",new Float32Array(r[0]*r[1]).fill(-1),r);s[0].data[0]=0;for(let r=1;r<n+1;++r)for(let n=1;n<t+1;++n){const t=s[n-1][r-1].item(),i=s[n-1][r].item(),o=s[n][r-1].item();let l,u;t<i&&t<o?(l=t,u=0):i<t&&i<o?(l=i,u=1):(l=o,u=2),s[n].data[r]=e[n-1][r-1].item()+l,a[n].data[r]=u}let i=t,o=n;a.data.fill(2,0,r[1]);for(let e=0;e<r[0];++e)a[e].data[0]=1;let l=[],u=[];for(;i>0||o>0;)switch(l.push(i-1),u.push(o-1),a[i][o].item()){case 0:--i,--o;break;case 1:--i;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${i}, ${o}]. Please file a bug report.`)}return l.reverse(),u.reverse(),[l,u]}function _e(e){const t=e.reduce(((e,t)=>e*t),1);return new ue("int64",new BigInt64Array(t).fill(1n),e)}function ke(e){return _e(e.dims)}function Se(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either 'binary' or 'ubinary'");const n="binary"===t,r=n?"int8":"uint8",s=n?Int8Array:Uint8Array,a=e.data,i=new s(a.length/8);for(let e=0;e<a.length;++e){const t=a[e]>0?1:0,r=Math.floor(e/8),s=e%8;i[r]|=t<<7-s,n&&0===s&&(i[r]-=128)}return new ue(r,i,[e.dims[0],e.dims[1]/8])}class Te{constructor(e=((e,t)=>e>t)){this._heap=[],this._comparator=e}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)this._heap.push(t),this._siftUp();return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){let e=this.size-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}}class Ie{constructor(){this.root=Ee.default()}extend(e){for(let t of e)this.push(t)}push(e){let t=this.root;for(let n of e){let e=t.children.get(n);void 0===e&&(e=Ee.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root,n="";for(let r=0;r<e.length&&void 0!==t;++r){const s=e[r];n+=s,t=t.children.get(s),void 0!==t&&t.isLeaf&&(yield n)}}}class Ee{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new Ee(!1,new Map)}}class Ae{constructor(e,t,n){this.sentence=e,this.len=e.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},(()=>[])),this.endNodes=Array.from({length:this.len+1},(()=>[]));const r=new Ce(this.bosTokenId,0,0,0,0),s=new Ce(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,a=new Ce(r,s,e,t,n);this.beginNodes[e].push(a),this.endNodes[e+t].push(a),this.nodes.push(a)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.sentence.slice(e.pos,e.pos+e.length)}tokens(){return this.viterbi().map((e=>this.piece(e)))}tokenIds(){return this.viterbi().map((e=>e.tokenId))}}class Ce{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new Ce(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var Ne=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),$e=Object.freeze({set:Ne.Set,for:Ne.For,in:Ne.In,is:Ne.Is,if:Ne.If,else:Ne.Else,endif:Ne.EndIf,elif:Ne.ElseIf,endfor:Ne.EndFor,and:Ne.And,or:Ne.Or,not:Ne.Not,"not in":Ne.NotIn,true:Ne.BooleanLiteral,false:Ne.BooleanLiteral}),Oe=class{constructor(e,t){this.value=e,this.type=t}};function De(e){return/\w/.test(e)}function Fe(e){return/[0-9]/.test(e)}var Re=[["{%",Ne.OpenStatement],["%}",Ne.CloseStatement],["{{",Ne.OpenExpression],["}}",Ne.CloseExpression],["(",Ne.OpenParen],[")",Ne.CloseParen],["{",Ne.OpenCurlyBracket],["}",Ne.CloseCurlyBracket],["[",Ne.OpenSquareBracket],["]",Ne.CloseSquareBracket],[",",Ne.Comma],[".",Ne.Dot],[":",Ne.Colon],["|",Ne.Pipe],["<=",Ne.ComparisonBinaryOperator],[">=",Ne.ComparisonBinaryOperator],["==",Ne.ComparisonBinaryOperator],["!=",Ne.ComparisonBinaryOperator],["<",Ne.ComparisonBinaryOperator],[">",Ne.ComparisonBinaryOperator],["+",Ne.AdditiveBinaryOperator],["-",Ne.AdditiveBinaryOperator],["*",Ne.MultiplicativeBinaryOperator],["/",Ne.MultiplicativeBinaryOperator],["%",Ne.MultiplicativeBinaryOperator],["=",Ne.Equals]],Me=new Map([["n","\n"],["t","\t"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]),Le=class{type="Statement"},Pe=class extends Le{constructor(e){super(),this.body=e}type="Program"},ze=class extends Le{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},Be=class extends Le{constructor(e,t,n){super(),this.loopvar=e,this.iterable=t,this.body=n}type="For"},Ve=class extends Le{constructor(e,t){super(),this.assignee=e,this.value=t}type="Set"},Ue=class extends Le{type="Expression"},je=class extends Ue{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},We=class extends Ue{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},Ge=class extends Ue{constructor(e){super(),this.value=e}type="Identifier"},He=class extends Ue{constructor(e){super(),this.value=e}type="Literal"},qe=class extends He{type="NumericLiteral"},Ze=class extends He{type="StringLiteral"},Ke=class extends He{type="BooleanLiteral"},Ye=class extends He{type="ArrayLiteral"},Xe=class extends He{type="TupleLiteral"},Qe=class extends He{type="ObjectLiteral"},Je=class extends Ue{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},et=class extends Ue{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},tt=class extends Ue{constructor(e,t,n){super(),this.operand=e,this.negate=t,this.test=n}type="TestExpression"},nt=class extends Ue{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},rt=class extends Ue{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"},st=class extends Ue{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"};function at(e){const t=new Pe([]);let n=0;function r(t,r){const s=e[n++];if(!s||s.type!==t)throw new Error(`Parser Error: ${r}. ${s.type} !== ${t}.`);return s}function s(){switch(e[n].type){case Ne.Text:return new Ze(r(Ne.Text,"Expected text token").value);case Ne.OpenStatement:return function(){let t;switch(r(Ne.OpenStatement,"Expected opening statement token"),e[n].type){case Ne.Set:++n,t=o(),r(Ne.CloseStatement,"Expected closing statement token");break;case Ne.If:++n,t=l(),r(Ne.OpenStatement,"Expected {% token"),r(Ne.EndIf,"Expected endif token"),r(Ne.CloseStatement,"Expected %} token");break;case Ne.For:++n,t=function(){const e=u(!0);if(!(e instanceof Ge||e instanceof Xe))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);r(Ne.In,"Expected `in` keyword following loop variable");const t=c();r(Ne.CloseStatement,"Expected closing statement token");const n=[];for(;a(Ne.OpenStatement,Ne.EndFor);)n.push(s());return new Be(e,t,n)}(),r(Ne.OpenStatement,"Expected {% token"),r(Ne.EndFor,"Expected endfor token"),r(Ne.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${e[n].type}`)}return t}();case Ne.OpenExpression:return function(){r(Ne.OpenExpression,"Expected opening expression token");const e=c();return r(Ne.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[n].type}`)}}function a(...t){return n+t.length<=e.length&&t.some(((t,r)=>t!==e[n+r].type))}function i(...t){return n+t.length<=e.length&&t.every(((t,r)=>t===e[n+r].type))}function o(){const e=c();if(i(Ne.Equals)){++n;const t=o();return new Ve(e,t)}return e}function l(){const t=c();r(Ne.CloseStatement,"Expected closing statement token");const a=[],o=[];for(;e[n]?.type!==Ne.OpenStatement||e[n+1]?.type!==Ne.ElseIf&&e[n+1]?.type!==Ne.Else&&e[n+1]?.type!==Ne.EndIf;)a.push(s());if(e[n]?.type===Ne.OpenStatement&&e[n+1]?.type!==Ne.EndIf)if(++n,i(Ne.ElseIf))r(Ne.ElseIf,"Expected elseif token"),o.push(l());else for(r(Ne.Else,"Expected else token"),r(Ne.CloseStatement,"Expected closing statement token");e[n]?.type!==Ne.OpenStatement||e[n+1]?.type!==Ne.EndIf;)o.push(s());return new ze(t,a,o)}function u(e=!1){const t=e?w:c,r=[t()],s=i(Ne.Comma);for(;s&&(++n,r.push(t()),i(Ne.Comma)););return s?new Xe(r):r[0]}function c(){return function(){const e=d();if(i(Ne.If)){++n;const t=d();r(Ne.Else,"Expected else token");const s=d();return new ze(t,[e],[s])}return e}()}function d(){let t=h();for(;i(Ne.Or);){const r=e[n];++n;const s=h();t=new Je(r,t,s)}return t}function h(){let t=p();for(;i(Ne.And);){const r=e[n];++n;const s=p();t=new Je(r,t,s)}return t}function p(){let t;for(;i(Ne.Not);){const r=e[n];++n;const s=p();t=new nt(r,s)}return t??function(){let t=f();for(;i(Ne.ComparisonBinaryOperator)||i(Ne.In)||i(Ne.NotIn);){const r=e[n];++n;const s=f();t=new Je(r,t,s)}return t}()}function f(){let t=b();for(;i(Ne.AdditiveBinaryOperator);){const r=e[n];++n;const s=b();t=new Je(r,t,s)}return t}function m(e){let t=new We(e,function(){r(Ne.OpenParen,"Expected opening parenthesis for arguments list");const e=function(){const e=[];for(;!i(Ne.CloseParen);){let t=c();if(i(Ne.Equals)){if(++n,!(t instanceof Ge))throw new SyntaxError("Expected identifier for keyword argument");const e=c();t=new st(t,e)}e.push(t),i(Ne.Comma)&&++n}return e}();return r(Ne.CloseParen,"Expected closing parenthesis for arguments list"),e}());return i(Ne.OpenParen)&&(t=m(t)),t}function g(){const e=[];let t=!1;for(;!i(Ne.CloseSquareBracket);)i(Ne.Colon)?(e.push(void 0),++n,t=!0):(e.push(c()),i(Ne.Colon)&&(++n,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new rt(...e)}return e[0]}function b(){let t=y();for(;i(Ne.MultiplicativeBinaryOperator);){const r=e[n];++n;const s=y();t=new Je(r,t,s)}return t}function y(){let t=function(){let t=function(){const t=function(){let t=w();for(;i(Ne.Dot)||i(Ne.OpenSquareBracket);){const s=e[n];let a;++n;const i=s.type!==Ne.Dot;if(i)a=g(),r(Ne.CloseSquareBracket,"Expected closing square bracket");else if(a=w(),"Identifier"!==a.type)throw new SyntaxError("Expected identifier following dot operator");t=new je(t,a,i)}return t}();return i(Ne.OpenParen)?m(t):t}();for(;i(Ne.Pipe);){++n;let e=w();if(!(e instanceof Ge))throw new SyntaxError("Expected identifier for the filter");i(Ne.OpenParen)&&(e=m(e)),t=new et(t,e)}return t}();for(;i(Ne.Is);){++n;const e=i(Ne.Not);e&&++n;let r=w();if(r instanceof Ke&&(r=new Ge(r.value.toString())),!(r instanceof Ge))throw new SyntaxError("Expected identifier for the test");t=new tt(t,e,r)}return t}function w(){const t=e[n];switch(t.type){case Ne.NumericLiteral:return++n,new qe(Number(t.value));case Ne.StringLiteral:return++n,new Ze(t.value);case Ne.BooleanLiteral:return++n,new Ke("true"===t.value);case Ne.Identifier:return++n,new Ge(t.value);case Ne.OpenParen:{++n;const t=u();if(e[n].type!==Ne.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${e[n].type} instead`);return++n,t}case Ne.OpenSquareBracket:{++n;const e=[];for(;!i(Ne.CloseSquareBracket);)e.push(c()),i(Ne.Comma)&&++n;return++n,new Ye(e)}case Ne.OpenCurlyBracket:{++n;const e=new Map;for(;!i(Ne.CloseCurlyBracket);){const t=c();r(Ne.Colon,"Expected colon between key and value in object literal");const s=c();e.set(t,s),i(Ne.Comma)&&++n}return++n,new Qe(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;n<e.length;)t.body.push(s());return t}function it(e,t,n=1){void 0===t&&(t=e,e=0);const r=[];for(let s=e;s<t;s+=n)r.push(s);return r}function ot(e,t,n,r=1){const s=Math.sign(r);s>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const a=[];for(let i=t;s*i<s*n;i+=r)a.push(e[i]);return a}function lt(e){return e.replace(/\b\w/g,(e=>e.toUpperCase()))}var ut=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new ht(!!this.value)}},ct=class extends ut{type="NumericValue"},dt=class extends ut{type="StringValue";builtins=new Map([["upper",new gt((()=>new dt(this.value.toUpperCase())))],["lower",new gt((()=>new dt(this.value.toLowerCase())))],["strip",new gt((()=>new dt(this.value.trim())))],["title",new gt((()=>new dt(lt(this.value))))],["length",new ct(this.value.length)]])},ht=class extends ut{type="BooleanValue"},pt=class extends ut{type="ObjectValue";__bool__(){return new ht(this.value.size>0)}builtins=new Map([["get",new gt((([e,t])=>{if(!(e instanceof dt))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new bt}))],["items",new gt((()=>new ft(Array.from(this.value.entries()).map((([e,t])=>new ft([new dt(e),t]))))))]])},ft=class extends ut{type="ArrayValue";builtins=new Map([["length",new ct(this.value.length)]]);__bool__(){return new ht(this.value.length>0)}},mt=class extends ft{type="TupleValue"},gt=class extends ut{type="FunctionValue"},bt=class extends ut{type="NullValue"},yt=class extends ut{type="UndefinedValue"},wt=class{constructor(e){this.parent=e}variables=new Map([["namespace",new gt((e=>{if(0===e.length)return new pt(new Map);if(1!==e.length||!(e[0]instanceof pt))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]}))]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof gt],["odd",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "odd" to type: ${e.type}`);return e.value%2!=0}],["even",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "even" to type: ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["number",e=>"NumericValue"===e.type],["integer",e=>"NumericValue"===e.type&&Number.isInteger(e.value)],["iterable",e=>e instanceof ft||e instanceof dt],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,xt(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new yt}catch{return new yt}}},vt=class{global;constructor(e){this.global=e??new wt}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t);switch(e.operator.value){case"and":return n.__bool__().value?this.evaluate(e.right,t):n;case"or":return n.__bool__().value?n:this.evaluate(e.right,t)}const r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new ht(n.value==r.value);case"!=":return new ht(n.value!=r.value)}if(n instanceof yt||r instanceof yt)throw new Error("Cannot perform operation on undefined values");if(n instanceof bt||r instanceof bt)throw new Error("Cannot perform operation on null values");if(n instanceof ct&&r instanceof ct)switch(e.operator.value){case"+":return new ct(n.value+r.value);case"-":return new ct(n.value-r.value);case"*":return new ct(n.value*r.value);case"/":return new ct(n.value/r.value);case"%":return new ct(n.value%r.value);case"<":return new ht(n.value<r.value);case">":return new ht(n.value>r.value);case">=":return new ht(n.value>=r.value);case"<=":return new ht(n.value<=r.value)}else if(n instanceof ft&&r instanceof ft){if("+"===e.operator.value)return new ft(n.value.concat(r.value))}else if(r instanceof ft){const t=void 0!==r.value.find((e=>e.value===n.value));switch(e.operator.value){case"in":return new ht(t);case"not in":return new ht(!t)}}if((n instanceof dt||r instanceof dt)&&"+"===e.operator.value)return new dt(n.value.toString()+r.value.toString());if(n instanceof dt&&r instanceof dt)switch(e.operator.value){case"in":return new ht(r.value.includes(n.value));case"not in":return new ht(!r.value.includes(n.value))}if(n instanceof dt&&r instanceof pt)switch(e.operator.value){case"in":return new ht(r.value.has(n.value));case"not in":return new ht(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);if("Identifier"===e.filter.type){const t=e.filter;if(n instanceof ft)switch(t.value){case"list":return n;case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new ct(n.value.length);case"reverse":return new ft(n.value.reverse());case"sort":return new ft(n.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));default:throw new Error(`Unknown ArrayValue filter: ${t.value}`)}else if(n instanceof dt)switch(t.value){case"length":return new ct(n.value.length);case"upper":return new dt(n.value.toUpperCase());case"lower":return new dt(n.value.toLowerCase());case"title":return new dt(lt(n.value));case"capitalize":return new dt(n.value.charAt(0).toUpperCase()+n.value.slice(1));case"trim":return new dt(n.value.trim());default:throw new Error(`Unknown StringValue filter: ${t.value}`)}else{if(n instanceof ct){if("abs"===t.value)return new ct(Math.abs(n.value));throw new Error(`Unknown NumericValue filter: ${t.value}`)}if(n instanceof pt)switch(t.value){case"items":return new ft(Array.from(n.value.entries()).map((([e,t])=>new ft([new dt(e),t]))));case"length":return new ct(n.value.size);default:throw new Error(`Unknown ObjectValue filter: ${t.value}`)}}throw new Error(`Cannot apply filter "${t.value}" to type: ${n.type}`)}if("CallExpression"===e.filter.type){const r=e.filter;if("Identifier"!==r.callee.type)throw new Error(`Unknown filter: ${r.callee.type}`);const s=r.callee.value;if(n instanceof ft){if("selectattr"===s){if(n.value.some((e=>!(e instanceof pt))))throw new Error("`selectattr` can only be applied to array of objects");if(r.args.some((e=>"StringLiteral"!==e.type)))throw new Error("arguments of `selectattr` must be strings");const[e,s,a]=r.args.map((e=>this.evaluate(e,t)));let i;if(s){const e=t.tests.get(s.value);if(!e)throw new Error(`Unknown test: ${s.value}`);i=e}else i=(...e)=>e[0].__bool__().value;const o=n.value.filter((t=>{const n=t.value.get(e.value);return!!n&&i(n,a)}));return new ft(o)}throw new Error(`Unknown ArrayValue filter: ${s}`)}throw new Error(`Cannot apply filter "${s}" to type: ${n.type}`)}throw new Error(`Unknown filter: ${e.filter.type}`)}evaluateTestExpression(e,t){const n=this.evaluate(e.operand,t),r=t.tests.get(e.test.value);if(!r)throw new Error(`Unknown test: ${e.test.value}`);const s=r(n);return new ht(e.negate?!s:s)}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new ht(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(n+=e.value)}return new dt(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const n=[],r=new Map;for(const s of e.args)if("KeywordArgumentExpression"===s.type){const e=s;r.set(e.key.value,this.evaluate(e.value,t))}else n.push(this.evaluate(s,t));r.size>0&&n.push(new pt(r));const s=this.evaluate(e.callee,t);if("FunctionValue"!==s.type)throw new Error(`Cannot call something that is not a function: got ${s.type}`);return s.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof ft||e instanceof dt))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),s=this.evaluate(t.stop,n),a=this.evaluate(t.step,n);if(!(r instanceof ct||r instanceof yt))throw new Error("Slice start must be numeric or undefined");if(!(s instanceof ct||s instanceof yt))throw new Error("Slice stop must be numeric or undefined");if(!(a instanceof ct||a instanceof yt))throw new Error("Slice step must be numeric or undefined");return e instanceof ft?new ft(ot(e.value,r.value,s.value,a.value)):new dt(ot(Array.from(e.value),r.value,s.value,a.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,s;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new dt(e.property.value);if(n instanceof pt){if(!(r instanceof dt))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof ft||n instanceof dt)if(r instanceof ct)s=n.value.at(r.value),n instanceof dt&&(s=new dt(n.value.at(r.value)));else{if(!(r instanceof dt))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);s=n.builtins.get(r.value)}else{if(!(r instanceof dt))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.builtins.get(r.value)}return s instanceof ut?s:new yt}evaluateSet(e,t){const n=this.evaluate(e.value,t);if("Identifier"===e.assignee.type){const r=e.assignee.value;t.setVariable(r,n)}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const r=e.assignee,s=this.evaluate(r.object,t);if(!(s instanceof pt))throw new Error("Cannot assign to member of non-object");if("Identifier"!==r.property.type)throw new Error("Cannot assign to member with non-identifier property");s.value.set(r.property.value,n)}}return new bt}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new wt(t),r=this.evaluate(e.iterable,n);if(!(r instanceof ft))throw new Error(`Expected iterable type in for loop: got ${r.type}`);let s="";for(let t=0;t<r.value.length;++t){const a=new Map([["index",new ct(t+1)],["index0",new ct(t)],["revindex",new ct(r.value.length-t)],["revindex0",new ct(r.value.length-t-1)],["first",new ht(0===t)],["last",new ht(t===r.value.length-1)],["length",new ct(r.value.length)],["previtem",t>0?r.value[t-1]:new yt],["nextitem",t<r.value.length-1?r.value[t+1]:new yt]]);n.setVariable("loop",new pt(a));const i=r.value[t];if("Identifier"===e.loopvar.type)n.setVariable(e.loopvar.value,i);else if("TupleLiteral"===e.loopvar.type){const t=e.loopvar;if("ArrayValue"!==i.type)throw new Error(`Cannot unpack non-iterable type: ${i.type}`);const r=i;if(t.value.length!==r.value.length)throw new Error(`Too ${t.value.length>r.value.length?"few":"many"} items to unpack`);for(let e=0;e<t.value.length;++e){if("Identifier"!==t.value[e].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[e].type}`);n.setVariable(t.value[e].value,r.value[e])}}s+=this.evaluateBlock(e.body,n).value}return new dt(s)}evaluate(e,t){if(void 0===e)return new yt;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"NumericLiteral":return new ct(Number(e.value));case"StringLiteral":return new dt(e.value);case"BooleanLiteral":return new ht(e.value);case"ArrayLiteral":return new ft(e.value.map((e=>this.evaluate(e,t))));case"TupleLiteral":return new mt(e.value.map((e=>this.evaluate(e,t))));case"ObjectLiteral":{const n=new Map;for(const[r,s]of e.value){const e=this.evaluate(r,t);if(!(e instanceof dt))throw new Error(`Object keys must be strings: got ${e.type}`);n.set(e.value,this.evaluate(s,t))}return new pt(n)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function xt(e){switch(typeof e){case"number":return new ct(e);case"string":return new dt(e);case"boolean":return new ht(e);case"object":return null===e?new bt:Array.isArray(e)?new ft(e.map(xt)):new pt(new Map(Object.entries(e).map((([e,t])=>[e,xt(t)]))));case"function":return new gt(((t,n)=>xt(e(...t.map((e=>e.value)))??null)));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}var _t=class{parsed;constructor(e){const t=function(e,t={}){const n=[],r=function(e,t={}){return e.endsWith("\n")&&(e=e.slice(0,-1)),e=e.replace(/{#.*?#}/gs,"{##}"),t.lstrip_blocks&&(e=e.replace(/^[ \t]*({[#%])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%]})\n/g,"$1")),e.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}(e,t);let s=0;const a=e=>{let t="";for(;e(r[s]);)if("\\"!==r[s]){if(t+=r[s++],s>=r.length)throw new SyntaxError("Unexpected end of input")}else{if(++s,s>=r.length)throw new SyntaxError("Unexpected end of input");const e=r[s++],n=Me.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n}return t};e:for(;s<r.length;){const e=n.at(-1)?.type;if(void 0===e||e===Ne.CloseStatement||e===Ne.CloseExpression){let e="";for(;s<r.length&&("{"!==r[s]||"%"!==r[s+1]&&"{"!==r[s+1]);)e+=r[s++];if(e.length>0){n.push(new Oe(e,Ne.Text));continue}}a((e=>/\s/.test(e)));const t=r[s];if("-"===t||"+"===t){const e=n.at(-1)?.type;if(e===Ne.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case Ne.Identifier:case Ne.NumericLiteral:case Ne.BooleanLiteral:case Ne.StringLiteral:case Ne.CloseParen:case Ne.CloseSquareBracket:break;default:{++s;const e=a(Fe);n.push(new Oe(`${t}${e}`,e.length>0?Ne.NumericLiteral:Ne.UnaryOperator));continue}}}for(const[e,t]of Re)if(r.slice(s,s+e.length)===e){n.push(new Oe(e,t)),s+=e.length;continue e}if("'"!==t&&'"'!==t)if(Fe(t)){const e=a(Fe);n.push(new Oe(e,Ne.NumericLiteral))}else{if(!De(t))throw new SyntaxError(`Unexpected character: ${t}`);{const e=a(De),t=Object.hasOwn($e,e)?$e[e]:Ne.Identifier;t===Ne.In&&n.at(-1)?.type===Ne.Not?(n.pop(),n.push(new Oe("not in",Ne.NotIn))):n.push(new Oe(e,t))}}else{++s;const e=a((e=>e!==t));n.push(new Oe(e,Ne.StringLiteral)),++s}}return n}(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=at(t)}render(e){const t=new wt;t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)})),t.set("range",it);for(const[n,r]of Object.entries(e))t.set(n,r);return new vt(t).run(this.parsed).value}};async function kt(e,t){const n=await Promise.all([U(e,"tokenizer.json",!0,t),U(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(n[1].legacy=t.legacy),n}function St(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\([#&~])/g,"$1");for(const[e,n]of Nt)t=t.replaceAll(e,n);return new RegExp(t,"gu")}if(void 0!==e.String){const n=s(e.String);return new RegExp(t?n:`(${n})`,"gu")}return console.warn("Unknown pattern type:",e),null}function Tt(e){return new Map(Object.entries(e))}function It(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function Et(e){return e.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function At(e){return e.replace(/[\u0300-\u036f]/g,"")}const Ct="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",Nt=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class $t{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class Ot extends a{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new Dt(e);case"Unigram":return new Ft(e,...t);case"BPE":return new Pt(e);default:if(e.vocab)return new zt(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){let t=this.encode(e);return this.fuse_unk&&(t=function(e,t,n){const r=[];let s=0;for(;s<e.length;)if(r.push(e[s]),(n.get(e[s])??t)===t)for(;s<e.length&&(n.get(e[s])??t)===t;)++s;else++s;return r}(t,this.unk_token_id,this.tokens_to_ids)),t}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map((e=>this.tokens_to_ids.get(e)??this.unk_token_id))}convert_ids_to_tokens(e){return e.map((e=>this.vocab[e]??this.unk_token))}}class Dt extends Ot{constructor(e){super(e),this.tokens_to_ids=Tt(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const n of e){const e=[...n];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let r=!1,s=0;const a=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}a.push(n),s=t}r?t.push(this.unk_token):t.push(...a)}return t}}class Ft extends Ot{constructor(e,t){super(e);const n=e.vocab.length;this.vocab=new Array(n),this.scores=new Array(n);for(let t=0;t<n;++t){const n=e.vocab[t];this.vocab[t]=n[0],this.scores[t]=n[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map(((e,t)=>[e,t]))),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=t.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=Q(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new Ie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.sentence,n=t.length;let r=0;for(;r<n;){const n=1;let s=!1;const a=[];for(let i of this.trie.commonPrefixSearch(t.slice(r))){a.push(i);const t=this.tokens_to_ids.get(i),o=this.scores[t],l=i.length;e.insert(r,l,o,t),s||l!==n||(s=!0)}s||e.insert(r,n,this.unkScore,this.unk_token_id),r+=n}}tokenize(e){const t=new Ae(e,this.bosTokenId,this.eosTokenId);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const n of e){const e=this.tokenize(n);t.push(...e)}return t}}const Rt=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},((e,t)=>t+"!".charCodeAt(0))),...Array.from({length:"¬".charCodeAt(0)-"¡".charCodeAt(0)+1},((e,t)=>t+"¡".charCodeAt(0))),...Array.from({length:"ÿ".charCodeAt(0)-"®".charCodeAt(0)+1},((e,t)=>t+"®".charCodeAt(0)))],t=e.slice();let n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);const r=t.map((e=>String.fromCharCode(e)));return Object.fromEntries(e.map(((e,t)=>[e,r[t]])))})(),Mt=(Lt=Rt,Object.fromEntries(Object.entries(Lt).map((([e,t])=>[t,e]))));var Lt;class Pt extends Ot{constructor(e){super(e),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=Tt(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;this.bpe_ranks=new Map(e.merges.map(((e,t)=>[e,t]))),this.merges=e.merges.map((e=>e.split(this.BPE_SPLIT_TOKEN))),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new Te(((e,t)=>e.score<t.score));let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;if(this.continuing_subword_suffix)for(let e=0;e<r.length-1;++e)r[e]+=this.continuing_subword_suffix;return this.cache.set(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(t.token+this.BPE_SPLIT_TOKEN+t.next.token);void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){const t=[];for(const n of e){if(this.ignore_merges&&this.tokens_to_ids.has(n)){t.push(n);continue}const e=this.bpe(n);for(const n of e)this.tokens_to_ids.has(n)?t.push(n):this.byte_fallback?t.push(...Array.from(this.text_encoder.encode(n)).map((e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`))):t.push(this.unk_token)}return t}}class zt extends Ot{constructor(e,t){super(e),this.tokens_to_ids=Tt(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class Bt extends a{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new Yt(e);case"Precompiled":return new _n(e);case"Sequence":return new Kt(e);case"Replace":return new Vt(e);case"NFC":return new Ut(e);case"NFKC":return new jt(e);case"NFKD":return new Wt(e);case"Strip":return new Gt(e);case"StripAccents":return new Ht(e);case"Lowercase":return new qt(e);case"Prepend":return new Zt(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class Vt extends Bt{normalize(e){const t=St(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class Ut extends Bt{normalize(e){return e.normalize("NFC")}}class jt extends Bt{normalize(e){return e.normalize("NFKC")}}class Wt extends Bt{normalize(e){return e.normalize("NFKD")}}class Gt extends Bt{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class Ht extends Bt{normalize(e){return At(e)}}class qt extends Bt{normalize(e){return e.toLowerCase()}}class Zt extends Bt{normalize(e){return this.config.prepend+e}}class Kt extends Bt{constructor(e){super(e),this.normalizers=e.normalizers.map((e=>Bt.fromConfig(e)))}normalize(e){return this.normalizers.reduce(((e,t)=>t.normalize(e)),e)}}class Yt extends Bt{_tokenize_chinese_chars(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n],s=r.charCodeAt(0);this._is_chinese_char(s)?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}_is_chinese_char(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}stripAccents(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(e){switch(e){case"\t":case"\n":case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const n of e){const e=n.charCodeAt(0);0===e||65533===e||this._is_control(n)||(/^\s$/.test(n)?t.push(" "):t.push(n))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class Xt extends a{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new Qt(e);case"Sequence":return new kn(e);case"Whitespace":return new Sn(e);case"WhitespaceSplit":return new Tn(e);case"Metaspace":return new vn(e);case"ByteLevel":return new Jt(e);case"Split":return new en(e);case"Punctuation":return new tn(e);case"Digits":return new nn(e);case"Replace":return new In(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map((e=>this.pre_tokenize_text(e,t))):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class Qt extends Xt{constructor(e){super(),this.pattern=new RegExp(`[^\\s${Ct}]+|[${Ct}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class Jt extends Xt{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=Rt,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){return this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),(this.use_regex?e.match(this.pattern)||[]:[e]).map((e=>Array.from(this.text_encoder.encode(e),(e=>this.byte_encoder[e])).join("")))}}class en extends Xt{constructor(e){super(),this.config=e,this.pattern=St(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:function(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push(e.slice(r,s.index)),t.length>0&&n.push(t),r=s.index+t.length}return r<e.length&&n.push(e.slice(r)),n}(e,this.pattern)}}class tn extends Xt{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${Ct}]+|[${Ct}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class nn extends Xt{constructor(e){super(),this.config=e;const t="[^\\d]+|\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class rn extends a{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new on(e);case"ByteLevel":return new ln(e);case"RobertaProcessing":return new an(e);case"BertProcessing":return new sn(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class sn extends rn{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:n=!0}={}){n&&(e=u([this.cls],e,[this.sep]));let r=new Array(e.length).fill(0);if(null!==t){const s=n&&this instanceof an?[this.sep]:[],a=n?[this.sep]:[];e=u(e,s,t,a),r=u(r,new Array(t.length+s.length+a.length).fill(1))}return{tokens:e,token_type_ids:r}}}class an extends sn{}class on extends rn{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:n=!0}={}){const r=null===t?this.single:this.pair;let s=[],a=[];for(const i of r)"SpecialToken"in i?n&&(s.push(i.SpecialToken.id),a.push(i.SpecialToken.type_id)):"Sequence"in i&&("A"===i.Sequence.id?(s=u(s,e),a=u(a,new Array(e.length).fill(i.Sequence.type_id))):"B"===i.Sequence.id&&(s=u(s,t),a=u(a,new Array(t.length).fill(i.Sequence.type_id))));return{tokens:s,token_type_ids:a}}}class ln extends rn{post_process(e,t=null){return t&&(e=u(e,t)),{tokens:e}}}class un extends a{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new fn(e);case"Metaspace":return new xn(e);case"ByteLevel":return new mn(e);case"Replace":return new cn(e);case"ByteFallback":return new dn(e);case"Fuse":return new hn(e);case"Strip":return new pn(e);case"Sequence":return new bn(e);case"CTC":return new gn(e);case"BPEDecoder":return new yn(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class cn extends un{decode_chain(e){const t=St(this.config.pattern);return null===t?e:e.map((e=>e.replaceAll(t,this.config.content)))}}class dn extends un{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let n=[];for(const r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){const t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class hn extends un{decode_chain(e){return[e.join("")]}}class pn extends un{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map((e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)}))}}class fn extends un{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map(((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=Et(e)),e)))}}class mn extends un{constructor(e){super(e),this.byte_decoder=Mt,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),n=new Uint8Array([...t].map((e=>this.byte_decoder[e])));return this.text_decoder.decode(n)}decode_chain(e){const t=[];let n=[];for(const r of e)void 0!==this.added_tokens.find((e=>e.content===r))?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class gn extends un{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let n=1;n<e.length;++n)e[n]!==t.at(-1)&&t.push(e[n]);let n=t.filter((e=>e!==this.pad_token)).join("");return this.cleanup&&(n=Et(n).replaceAll(this.word_delimiter_token," ").trim()),n}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class bn extends un{constructor(e){super(e),this.decoders=e.decoders.map((e=>un.fromConfig(e)))}decode_chain(e){return this.decoders.reduce(((e,t)=>t.decode_chain(e)),e)}}class yn extends un{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map(((t,n)=>t.replaceAll(this.suffix,n===e.length-1?"":" ")))}}class wn extends un{decode_chain(e){let t="";for(let n=1;n<e.length;n+=2)t+=e[n];return[t]}}class vn extends Xt{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let n=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!n.startsWith(this.replacement)&&("always"===this.prepend_scheme||"first"===this.prepend_scheme&&0===t)&&(n=this.strRep+n),[n]}}class xn extends un{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");this.addPrefixSpace&&0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class _n extends Bt{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,"")).replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," ")).includes("～")){const t=e.split("～");e=t.map((e=>e.normalize("NFKC"))).join("～")}else e=e.normalize("NFKC");return e}}class kn extends Xt{constructor(e){super(),this.tokenizers=e.pretokenizers.map((e=>Xt.fromConfig(e)))}pre_tokenize_text(e,t){return this.tokenizers.reduce(((e,n)=>n.pre_tokenize(e,t)),[e])}}class Sn extends Xt{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\w+|[^\w\s]+/g)||[]}}class Tn extends Xt{constructor(e){super()}pre_tokenize_text(e,t){return function(e){return e.match(/\S+/g)||[]}(e)}}class In extends Xt{constructor(e){super(),this.config=e,this.pattern=St(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const En=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function An(e,t,n,r){for(const s of Object.keys(e)){const a=t-e[s].length,i=n(s),o=new Array(a).fill(i);e[s]="right"===r?u(e[s],o):u(o,e[s])}}function Cn(e,t){for(const n of Object.keys(e))e[n].length=t}class Nn extends a{return_token_type_ids=!1;_default_chat_template="{% for message in messages %}{{'<|im_start|>' + message['role'] + '\n' + message['content'] + '<|im_end|>' + '\n'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant\n' }}{% endif %}";constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=Bt.fromConfig(e.normalizer),this.pre_tokenizer=Xt.fromConfig(e.pre_tokenizer),this.model=Ot.fromConfig(e.model,t),this.post_processor=rn.fromConfig(e.post_processor),this.decoder=un.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new $t(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map((e=>`${e.lstrip?"\\s*":""}(${s(e.content)})${e.rstrip?"\\s*":""}`)).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:n}of this.chat_template){if("string"!=typeof t||"string"!=typeof n)throw new Error('Chat template must be a list of objects with "name" and "template" properties');e[t]=n}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this._tokenizer_config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main",legacy:i=null}={}){return new this(...await kt(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a,legacy:i}))}_call(e,{text_pair:t=null,add_special_tokens:n=!0,padding:r=!1,truncation:s=null,max_length:a=null,return_tensor:i=!0}={}){const o=Array.isArray(e);let l;if(o){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");l=e.map(((e,r)=>this._encode_plus(e,t[r],{add_special_tokens:n})))}else l=e.map((e=>this._encode_plus(e,null,{add_special_tokens:n})))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");l=[this._encode_plus(e,t,{add_special_tokens:n})]}if(null===a?a="max_length"===r?this.model_max_length:J(l.map((e=>e.input_ids.length)))[0]:s||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),a=Math.min(a,this.model_max_length),r||s)for(let e=0;e<l.length;++e)l[e].input_ids.length!==a&&(l[e].input_ids.length>a?s&&Cn(l[e],a):r&&An(l[e],a,(e=>"input_ids"===e?this.pad_token_id:0),this.padding_side));const u={};if(i){if((!r||!s)&&l.some((e=>{for(const t of Object.keys(e))if(e[t].length!==l[0][t]?.length)return!0;return!1})))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const e=[l.length,l[0].input_ids.length];for(const t of Object.keys(l[0]))u[t]=new ue("int64",BigInt64Array.from(l.flatMap((e=>e[t])).map(BigInt)),e)}else{for(const e of Object.keys(l[0]))u[e]=l.map((t=>t[e]));if(!o)for(const e of Object.keys(u))u[e]=u[e][0]}return u}_encode_text(e){if(null===e)return null;const t=(this.added_tokens_regex?e.split(this.added_tokens_regex).filter((e=>e)):[e]).map(((e,t)=>{if(void 0!==this.added_tokens.find((t=>t.content===e)))return e;{if(!0===this.remove_space&&(e=e.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function(e){return At(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const n=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(n)}})).flat();return t}_encode_plus(e,t=null,{add_special_tokens:n=!0}={}){const r=this._encode_text(e),s=this._encode_text(t),a=this.post_processor?this.post_processor(r,s,{add_special_tokens:n}):{tokens:u(r??[],s??[])},i=this.model.convert_tokens_to_ids(a.tokens),o={input_ids:i,attention_mask:new Array(i.length).fill(1)};return this.return_token_type_ids&&a.token_type_ids&&(o.token_type_ids=a.token_type_ids),o}encode(e,t=null,{add_special_tokens:n=!0}={}){const{input_ids:r}=this._encode_plus(e,t,{add_special_tokens:n});return r}batch_decode(e,t={}){return e instanceof ue&&(e=e.tolist()),e.map((e=>this.decode(e,t)))}decode(e,t={}){if(e instanceof ue&&(e=It(e)),!Array.isArray(e)||0===e.length||!i(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter((e=>!this.special_tokens.includes(e))));let s=this.decoder?this.decoder(r):r.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=Et(s)),s}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(e,{chat_template:t=null,add_generation_prompt:n=!1,tokenize:r=!0,padding:s=!1,truncation:a=!1,max_length:i=null,return_tensor:o=!0,tokenizer_kwargs:l={},...u}={}){if(this.chat_template&&"object"==typeof this.chat_template||null===this.chat_template&&this.default_chat_template&&"object"==typeof this.default_chat_template){const e=this.chat_template??this.default_chat_template;if(null!==t&&Object.hasOwn(e,t))t=e[t];else if(null===t&&"default"in e)t=e.default;else if(null===t)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(e).sort()}.`)}else t??=this.chat_template??this.default_chat_template;if("string"!=typeof t)throw Error("chat_template must be a string, but got "+typeof t);let c=this._compiled_template_cache.get(t);void 0===c&&(c=new _t(t),this._compiled_template_cache.set(t,c));const d=Object.create(null);for(const e of En){const t=this.getToken(e);t&&(d[e]=t)}const h=c.render({messages:e,add_generation_prompt:n,...d,...u});return r?this._call(h,{add_special_tokens:!1,padding:s,truncation:a,max_length:i,return_tensor:o,...l}).input_ids:h}}class $n extends Nn{return_token_type_ids=!0}class On extends Nn{return_token_type_ids=!0}class Dn extends Nn{return_token_type_ids=!0}class Fn extends Nn{return_token_type_ids=!0}class Rn extends Nn{return_token_type_ids=!0}class Mn extends Nn{return_token_type_ids=!0}class Ln extends Nn{return_token_type_ids=!0}class Pn extends Nn{return_token_type_ids=!0}class zn extends Nn{return_token_type_ids=!0}class Bn extends Nn{}class Vn extends Nn{}class Un extends Nn{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class jn extends Nn{return_token_type_ids=!0}class Wn extends Nn{}class Gn extends Nn{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}'}class Hn extends Nn{}class qn extends Nn{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return lr(this,e,t,n)}}class Zn extends qn{}class Kn extends Nn{}class Yn extends Gn{constructor(e,t){const n=".,!?…。，、।۔،",r=e.pre_tokenizer?.pretokenizers[0]?.pattern;r&&r.Regex===` ?[^(\\s|[${n}])]+`&&(r.Regex=` ?[^\\s${n}]+`),super(e,t)}}const Xn="▁";class Qn extends Nn{_default_chat_template="{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>\n' + system_message + '\n<</SYS>>\n\n' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>\n' + content.strip() + '\n<</SYS>>\n\n' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}";DEFAULT_SYSTEM_PROMPT="You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.\n\nIf a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.";constructor(e,t){super(e,t),this.use_default_system_prompt=t.use_default_system_prompt??!1,this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new vn({replacement:Xn,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(Xn+e.replaceAll(Xn," "));return t.length>1&&t[0]===Xn&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll("\n","\\n").replaceAll("'","\\'"))}}class Jn extends Qn{}class er extends Nn{}class tr extends Nn{}class nr extends Nn{}class rr extends Nn{}class sr extends Nn{}class ar extends Nn{}class ir extends Nn{_default_chat_template="{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '\n' + message['content'] | trim + '<end_of_turn>\n' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model\n'}}{% endif %}"}class or extends Nn{}function lr(e,t,n,r){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const s=r.src_lang,a=r.tgt_lang;if(!e.language_codes.includes(a))throw new Error(`Target language code "${a}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==s){if(!e.language_codes.includes(s))throw new Error(`Source language code "${s}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(s);break}}return r.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(a)])[0],e._call(t,n)}class ur extends Nn{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return lr(this,e,t,n)}}class cr extends Nn{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))).map((e=>e.slice(2,-2))),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,n){return lr(this,e,t,n)}}const dr=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],hr=new Map(dr),pr=new Map([...dr.map((([e,t])=>[t,e])),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class fr extends Nn{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let a=null;const i="word"===t;function o(){return{language:a,timestamp:[null,null],text:""}}const l=[];let u=o(),c=0;const d=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let h=[],p=[],f=!1,m=null;const g=new Set(this.all_special_ids);for(const n of e){const e=n.tokens,s=i?n.token_timestamps:null;let b=null,y=d;if("stride"in n){const[t,s,a]=n.stride;if(c-=s,m=t-a,s&&(y=s/r+d),a)for(let t=e.length-1;t>=0;--t){const n=e[t];if(n>=d){if(null!==b&&(n-d)*r<m)break;b=n}}}let w=[],v=[];for(let n=0;n<e.length;++n){const m=e[n];if(g.has(m)){const e=this.decode([m]),n=hr.get(e.slice(2,-2));if(void 0!==n){if(null!==a&&n!==a&&!t){h.push(w);const e=this.findLongestCommonSequence(h)[0],t=this.decode(e);u.text=t,l.push(u),h=[],w=[],u=o()}a=u.language=n}}else if(m>=d){const e=ae((m-d)*r+c,2);if(null!==b&&m>=b)f=!0;else if(f||h.length>0&&m<y)f=!1;else if(null===u.timestamp[0])u.timestamp[0]=e;else if(e===u.timestamp[0]);else{u.timestamp[1]=e,h.push(w),i&&p.push(v);const[t,n]=this.findLongestCommonSequence(h,p),r=this.decode(t);u.text=r,i&&(u.words=this.collateWordTimestamps(t,n,a)),l.push(u),h=[],w=[],p=[],v=[],u=o()}}else if(w.push(m),i){let e,t=ae(s[n]+c,2);e=n+1<s.length?ae(s[n+1]+c,2):null,v.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;c+=e-r}w.length>0?(h.push(w),i&&p.push(v)):h.every((e=>0===e.length))&&(u=o(),h=[],w=[],p=[],v=[])}if(h.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(h,p),r=this.decode(e);u.text=r,i&&(u.words=this.collateWordTimestamps(e,n,a)),l.push(u)}let b=Object.create(null);const y=l.map((e=>e.text)).join("");if(t||n){for(let e=0;e<l.length;++e){const r=l[e];t||delete r.timestamp,n||delete r.language}if(i){const e=[];for(const t of l)for(const n of t.words)e.push(n);b={chunks:e}}else b={chunks:l}}return[y,b]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const a=Array.isArray(t)&&t.length>0;let i=a?[]:null,o=a?t[0]:null;for(let l=1;l<e.length;++l){const u=e[l];let c=0,d=[r,r,0,0];const h=u.length;for(let e=1;e<r+h;++e){const t=e/1e4,s=Math.max(0,r-e),a=Math.min(r,r+h-e),i=n.slice(s,a),o=Math.max(0,e-r),l=Math.min(h,e),p=u.slice(o,l);if(i.length!==p.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const f=i.filter(((e,t)=>e===p[t])).length,m=f/e+t;f>1&&m>c&&(c=m,d=[s,a,o,l])}const[p,f,m,g]=d,b=Math.floor((f+p)/2),y=Math.floor((g+m)/2);s.push(...n.slice(0,b)),n=u.slice(y),r=n.length,a&&(i.push(...o.slice(0,b)),o=t[l].slice(y))}return s.push(...n),a?(i.push(...o),[s,i]):[s,[]]}collateWordTimestamps(e,t,n){const[r,s,a]=this.combineTokensIntoWords(e,n),i=[];for(let e=0;e<r.length;++e){const n=a[e];i.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return i}combineTokensIntoWords(e,t,n="\"'“¡¿([{-",r="\"'.。,，!！?？:：”)]}、"){let s,a,i;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,a,i]=this.splitTokensOnUnicode(e):[s,a,i]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,a,i,n,r)}decode(e,t){let n;return t&&t.decode_with_timestamps?(e instanceof ue&&(e=It(e)),n=this.decodeWithTimestamps(e,t)):n=super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(const t of e)if(t>=r){const e=ae((t-r)*n,2);s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map((e=>"string"==typeof e?e:super.decode(e,t))),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),n=[],r=[],s=[];let a=[],i=[],o=0;for(let l=0;l<e.length;++l){const u=e[l];a.push(u),i.push(l);const c=this.decode(a,{decode_with_timestamps:!0});c.includes("�")&&"�"!==t[o+c.indexOf("�")]||(n.push(c),r.push(a),s.push(i),a=[],i=[],o+=c.length)}return[n,r,s]}splitTokensOnSpaces(e){const[t,n,r]=this.splitTokensOnUnicode(e),s=[],a=[],i=[],o=new RegExp(`^[${Ct}]$`,"gu");for(let e=0;e<t.length;++e){const l=t[e],u=n[e],c=r[e],d=u[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),h=l.startsWith(" "),p=l.trim(),f=o.test(p);if(d||h||f||0===s.length)s.push(l),a.push(u),i.push(c);else{const e=s.length-1;s[e]+=l,a[e].push(...u),i[e].push(...c)}}return[s,a,i]}mergePunctuations(e,t,n,r,s){const a=structuredClone(e),i=structuredClone(t),o=structuredClone(n);let l=a.length-2,c=a.length-1;for(;l>=0;)a[l].startsWith(" ")&&r.includes(a[l].trim())?(a[c]=a[l]+a[c],i[c]=u(i[l],i[c]),o[c]=u(o[l],o[c]),a[l]="",i[l]=[],o[l]=[]):c=l,--l;for(l=0,c=1;c<a.length;)!a[l].endsWith(" ")&&s.includes(a[c])?(a[l]+=a[c],i[l]=u(i[l],i[c]),o[l]=u(o[l],o[c]),a[c]="",i[c]=[],o[c]=[]):l=c,++c;return[a.filter((e=>e)),i.filter((e=>e.length>0)),o.filter((e=>e.length>0))]}get_decoder_prompt_ids({language:e=null,task:t=null,no_timestamps:n=!0}={}){const r=[];if(e){e=e.toLowerCase();let t=pr.get(e);if(void 0===t){if(!hr.has(e)){const t=2===e.length?hr.keys():hr.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(t)}`)}t=e}const n=this.model.tokens_to_ids.get(`<|${t}|>`);if(void 0===n)throw new Error(`Unable to find language "${t}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);r.push(n)}else r.push(null);if(t){if("transcribe"!==(t=t.toLowerCase())&&"translate"!==t)throw new Error(`Task "${t}" is not supported. Must be one of: ["transcribe", "translate"]`);const e=this.model.tokens_to_ids.get(`<|${t}|>`);if(void 0===e)throw new Error(`Unable to find task "${t}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);r.push(e)}else r.push(null);if(n){const e=this.model.tokens_to_ids.get("<|notimestamps|>");if(void 0===e)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');r.push(e)}return r.map(((e,t)=>[t+1,e])).filter((e=>null!==e[1]))}}class mr extends Nn{}class gr extends Nn{}class br extends Nn{}class yr extends Nn{constructor(e,t){super(e,t),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter((e=>this.languageRegex.test(e))),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(null===e)return null;const[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){const[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),u([e],super._encode_text(t))}}}class wr extends Nn{}class vr extends Nn{_default_chat_template="{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}"}class xr extends vr{}class _r extends Nn{}class kr extends Nn{}class Sr extends Nn{constructor(e,t){super(e,t),this.decoder=new wn({})}}class Tr extends Nn{}class Ir{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:Wn,DistilBertTokenizer:Bn,CamembertTokenizer:Vn,DebertaTokenizer:Rn,DebertaV2Tokenizer:Mn,BertTokenizer:$n,HerbertTokenizer:Ln,ConvBertTokenizer:Pn,RoFormerTokenizer:zn,XLMTokenizer:Un,ElectraTokenizer:jn,MobileBertTokenizer:Dn,SqueezeBertTokenizer:Fn,AlbertTokenizer:On,GPT2Tokenizer:Gn,BartTokenizer:Hn,MBartTokenizer:qn,MBart50Tokenizer:Zn,RobertaTokenizer:Kn,WhisperTokenizer:fr,CodeGenTokenizer:mr,CLIPTokenizer:gr,SiglipTokenizer:br,MarianTokenizer:yr,BloomTokenizer:Yn,NllbTokenizer:ur,M2M100Tokenizer:cr,LlamaTokenizer:Qn,CodeLlamaTokenizer:Jn,XLMRobertaTokenizer:er,MPNetTokenizer:tr,FalconTokenizer:nr,GPTNeoXTokenizer:rr,EsmTokenizer:sr,Wav2Vec2CTCTokenizer:wr,BlenderbotTokenizer:vr,BlenderbotSmallTokenizer:xr,SpeechT5Tokenizer:_r,NougatTokenizer:kr,VitsTokenizer:Sr,Qwen2Tokenizer:ar,GemmaTokenizer:ir,Grok1Tokenizer:or,CohereTokenizer:Tr,PreTrainedTokenizer:Nn};static async from_pretrained(e,{quantized:t=!0,progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",legacy:o=null}={}){const[l,u]=await kt(e,{quantized:t,progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i,legacy:o}),c=u.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let d=this.TOKENIZER_CLASS_MAPPING[c];return d||(console.warn(`Unknown tokenizer class "${c}", attempting to construct from base class.`),d=Nn),new d(l,u)}}class Er{constructor(e){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main"}={}){let i=n??await async function(e,t){return await U(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a});return new this(i)}}class Ar{static async from_pretrained(...e){return Er.from_pretrained(...e)}}class Cr extends a{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){for(let n of t)this.processors.forEach((t=>t(e,n)))}[Symbol.iterator](){return this.processors.values()}}class Nr extends a{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class $r extends Nr{constructor(e){super(),this.force_token_map=Object.fromEntries(e??[])}_call(e,t){let n=this.force_token_map[e.length];return null!=n&&(t.data.fill(-1/0),t.data[n]=0),t}}class Or extends Nr{constructor(e){super(),this.bos_token_id=e}_call(e,t){return 1===e.length&&(t.data.fill(-1/0),t.data[this.bos_token_id]=0),t}}class Dr extends Nr{constructor(e,t){super(),this.max_length=e,this.forced_eos_token_id=t}_call(e,t){}}class Fr extends Nr{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){if(e.length===this.begin_index)for(let e of this.begin_suppress_tokens)t.data[e]=-1/0;return t}}class Rr extends Nr{constructor(e){super(),this.eos_token_id=e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(e.forced_decoder_ids||[]).length+2,e.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){const n=t.data;if(n[this.no_timestamps_token_id]=-1/0,e.length===this.begin_index-1)return n.fill(-1/0),n[this.timestamp_begin]=0,t;const r=e.slice(this.begin_index),s=r.length>=1&&r[r.length-1]>=this.timestamp_begin,a=r.length<2||r[r.length-2]>=this.timestamp_begin;if(s&&(a?n.subarray(this.timestamp_begin).fill(-1/0):n.subarray(0,this.eos_token_id).fill(-1/0)),e.length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;n.subarray(e+1).fill(-1/0)}const i=q(n);return Math.log(i.subarray(this.timestamp_begin).map(Math.exp).reduce(((e,t)=>e+t)))>J(i.subarray(0,this.timestamp_begin))[0]&&n.subarray(0,this.timestamp_begin).fill(-1/0),t}}class Mr extends Nr{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t)}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n))??[]}calcBannedNgramTokens(e){if(e.length+1<this.no_repeat_ngram_size)return[];{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){const n=this.calcBannedNgramTokens(e);for(const e of n)t.data[e]=-1/0;return t}}class Lr extends Nr{constructor(e){super(),this.penalty=e}_call(e,t){for(const n of e)t.data[n]<0?t.data[n]*=this.penalty:t.data[n]/=this.penalty;return t}}class Pr extends Nr{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){if(e.length<this.min_length)for(const e of this.eos_token_id)t.data[e]=-1/0;return t}}class zr extends Nr{constructor(e,t,n){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,t){if(e.length-this.prompt_length_to_skip<this.min_new_tokens)for(const e of this.eos_token_id)t.data[e]=-1/0;return t}}class Br extends Nr{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(const n of this.bad_words_ids){let r=!0;for(let t=1;t<=n.length-1&&n.length<e.length;++t)if(n.at(-t-1)!==e.at(-t)){r=!1;break}r&&(t.data[n.at(-1)]=-1/0)}return t}}const Vr=class{constructor(e={}){this.max_length=e.max_length??20,this.max_new_tokens=e.max_new_tokens??null,this.min_length=e.min_length??0,this.min_new_tokens=e.min_new_tokens??null,this.early_stopping=e.early_stopping??!1,this.max_time=e.max_time??null,this.do_sample=e.do_sample??!1,this.num_beams=e.num_beams??1,this.num_beam_groups=e.num_beam_groups??1,this.penalty_alpha=e.penalty_alpha??null,this.use_cache=e.use_cache??!0,this.temperature=e.temperature??1,this.top_k=e.top_k??50,this.top_p=e.top_p??1,this.typical_p=e.typical_p??1,this.epsilon_cutoff=e.epsilon_cutoff??0,this.eta_cutoff=e.eta_cutoff??0,this.diversity_penalty=e.diversity_penalty??0,this.repetition_penalty=e.repetition_penalty??1,this.encoder_repetition_penalty=e.encoder_repetition_penalty??1,this.length_penalty=e.length_penalty??1,this.no_repeat_ngram_size=e.no_repeat_ngram_size??0,this.bad_words_ids=e.bad_words_ids??null,this.force_words_ids=e.force_words_ids??null,this.renormalize_logits=e.renormalize_logits??!1,this.constraints=e.constraints??null,this.forced_bos_token_id=e.forced_bos_token_id??null,this.forced_eos_token_id=e.forced_eos_token_id??null,this.remove_invalid_values=e.remove_invalid_values??!1,this.exponential_decay_length_penalty=e.exponential_decay_length_penalty??null,this.suppress_tokens=e.suppress_tokens??null,this.begin_suppress_tokens=e.begin_suppress_tokens??null,this.forced_decoder_ids=e.forced_decoder_ids??null,this.num_return_sequences=e.num_return_sequences??1,this.output_attentions=e.output_attentions??!1,this.output_hidden_states=e.output_hidden_states??!1,this.output_scores=e.output_scores??!1,this.return_dict_in_generate=e.return_dict_in_generate??!1,this.pad_token_id=e.pad_token_id??null,this.bos_token_id=e.bos_token_id??null,this.eos_token_id=e.eos_token_id??null,this.encoder_no_repeat_ngram_size=e.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=e.decoder_start_token_id??null,this.generation_kwargs=e.generation_kwargs??{}}};class Ur extends a{constructor(e){super(),this.generation_config=e}_call(e,t=-1){return this.sample(e,t)}sample(e,t){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return this.generation_config.temperature>0&&(r=r.map((e=>e/this.generation_config.temperature))),r}randomSelect(e){let t=e.reduce(((e,t)=>e+t),0),n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new Wr(e);if(e.num_beams>1)return new Gr(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new jr(e)}}class jr extends Ur{sample(e,t=-1){return[[J(this.getLogits(e,t))[1],0]]}}class Wr extends Ur{sample(e,t=-1){let n=e.dims.at(-1);this.generation_config.top_k>0&&(n=Math.min(this.generation_config.top_k,n));const r=K(this.getLogits(e,t),n),s=H(r.map((e=>e[1])));return Array.from({length:this.generation_config.num_beams},(()=>{const e=this.randomSelect(s);return[r[e][0],Math.log(s[e])]}))}}class Gr extends Ur{sample(e,t=-1){let n=e.dims.at(-1);this.generation_config.top_k>0&&(n=Math.min(this.generation_config.top_k,n));const r=K(this.getLogits(e,t),n),s=H(r.map((e=>e[1])));return Array.from({length:this.generation_config.num_beams},((e,t)=>[r[t][0],Math.log(s[t])]))}}const{InferenceSession:Hr,Tensor:qr,env:Zr}=_,Kr=new Map,Yr=new Map,Xr=new Map;async function Qr(e,t,n){let r=`onnx/${t}${n.quantized?"_quantized":""}.onnx`,s=await V(e,r,!0,n);try{return await Hr.create(s,{executionProviders:k})}catch(e){if(1===k.length&&"wasm"===k[0])throw e;return console.warn(e),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await Hr.create(s,{executionProviders:["wasm"]})}}async function Jr(e,t){const n=function(e,t){const n=Object.create(null),r=[];for(const s of e.inputNames){const e=t[s];e instanceof ue?n[s]=Zr.wasm.proxy?e.clone():e:r.push(s)}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const s=Object.keys(t).length,a=e.inputNames.length;if(s>a){let n=Object.keys(t).filter((t=>!e.inputNames.includes(t)));console.warn(`WARNING: Too many inputs were provided (${s} > ${a}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{let t=await e.run(n);return t=es(t),t}catch(e){throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",n),e}}function es(e){for(let t in e)e[t]instanceof qr?e[t]=new ue(e[t]):"object"==typeof e[t]&&es(e[t]);return e}function ts(e){if(e instanceof ue)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some((t=>t.length!==e[0].length)))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new ue("int64",BigInt64Array.from(e.flat().map((e=>BigInt(e)))),[e.length,e[0].length])}return new ue("int64",BigInt64Array.from(e.map((e=>BigInt(e)))),[1,e.length])}function ns(e,t){let n=e.config.pad_token_id??null,r=e.config.eos_token_id??null;i(r)&&(r=[r]);let s=-1!==t.indexOf(n),a=null===r||!r.includes(n);if(s&&a){let e=BigInt64Array.from(t.data.map((e=>e!=n)));return new ue("int64",e,t.dims)}return ke(t)}function rs(e,t,n){if(!e.inputNames.includes("position_ids"))return;const r=new BigInt64Array(t.attention_mask.data.length);for(let e=0;e<t.attention_mask.dims[0];++e){let n=e*t.attention_mask.dims[1],s=BigInt(0);for(let e=0;e<t.attention_mask.dims[1];++e){const a=n+e;0n===t.attention_mask.data[a]?r[a]=BigInt(1):(r[a]=s,s+=t.attention_mask.data[a])}}t.position_ids=new ue("int64",r,t.attention_mask.dims),n&&(t.position_ids=t.position_ids.slice(null,-1).unsqueeze_(-1))}function ss(e){return new ue("bool",[e],[1])}async function as(e,t){let{encoder_outputs:n,past_key_values:r}=t;n||(n=(await us(e,t)).last_hidden_state);let s={input_ids:t.decoder_input_ids,encoder_hidden_states:n};const a=!!r;e.decoder_merged_session.inputNames.includes("use_cache_branch")&&(s.use_cache_branch=ss(a)),e.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(s.encoder_attention_mask=t.attention_mask),rs(e.decoder_merged_session,s,a),e.addPastKeyValues(s,r);const i=await Jr(e.decoder_merged_session,s);let o=i.logits;r=e.getPastKeyValues(i,r);const l=e.getAttentions(i);return new nd({logits:o,past_key_values:r,encoder_outputs:n,...l})}function is(e,t,n,r){let s=[],a=0;const i=e.requires_attention_mask??!0;let o=n.decoder_input_ids??n.decoder_start_token_id??n.bos_token_id??n.eos_token_id;o instanceof ue?o=o.tolist().flat():Array.isArray(o)||(o=[o]);for(let n of t){n.dims=[1,...n.dims];let t={inputs:n,encoder_outputs:null,prev_model_outputs:null,output_token_ids:o,done:!1,score:0,id:a++};i&&(t.attention_mask=ns(e,n)),s.push(t)}return s}async function os(e,t){const n=e.main_input_name;let r=t.output_token_ids;t.prev_model_outputs&&(r=r.slice(-1));let s={[n]:t.inputs,decoder_input_ids:ts(r),encoder_outputs:t.encoder_outputs,past_key_values:t.prev_model_outputs?.past_key_values};t.attention_mask&&(s.attention_mask=t.attention_mask);let a=await e.forward(s);return t.prev_model_outputs=a,t.encoder_outputs=a.encoder_outputs,a}function ls(e,t){e.output_token_ids=[...e.output_token_ids,t]}async function us(e,t){const n=Object.create(null);for(const r of e.session.inputNames)n[r]=t[r];return e.session.inputNames.includes("token_type_ids")&&!n.token_type_ids&&(n.token_type_ids=new ue("int64",new BigInt64Array(n.input_ids.data.length),n.input_ids.dims)),await Jr(e.session,n)}async function cs(e,t){let{input_ids:n,past_key_values:r,attention_mask:s}=t,a={input_ids:n,attention_mask:s??ns(e,n)};const i=!!r;e.session.inputNames.includes("use_cache_branch")&&(a.use_cache_branch=ss(i)),rs(e.session,a,i),e.addPastKeyValues(a,r);let o=await Jr(e.session,a),l=o.logits;return r=e.getPastKeyValues(o,r),{logits:l,past_key_values:r}}function ds(e,t,n,r,s){let a=[],i=0;for(let n of t){let t,o=n.tolist().map(Number);n.dims=[1,...n.dims],s?(t=s[i],t.dims=[1,...t.dims]):t=ns(e,n);let l={input:n,model_input_ids:n,attention_mask:t,prev_model_outputs:null,output_token_ids:o,num_output_tokens:r,done:!1,score:0,id:i++};a.push(l)}return a}async function hs(e,t){let n=new BigInt64Array(t.output_token_ids.length).fill(1n),r={input_ids:t.model_input_ids,attention_mask:new ue("int64",n,[1,n.length]),past_key_values:t.prev_model_outputs?.past_key_values},s=await e.forward(r);return t.prev_model_outputs=s,s}function ps(e,t){e.output_token_ids=[...e.output_token_ids,t],e.model_input_ids=new ue("int64",[BigInt(t)],[1,1])}class fs extends a{main_input_name="input_ids";constructor(e,t){super(),this.config=e,this.session=t;const n=Xr.get(this.constructor),r=Kr.get(n);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,4===r?(this.can_generate=!0,this._runBeam=hs,this._getStartBeams=ds,this._updateBeam=ps,this._forward=cs):2===r||3===r?(this.can_generate=!0,this._runBeam=os,this._getStartBeams=is,this._updateBeam=ls,this._forward=as):this._forward=us}async dispose(){const e=[];for(let t of Object.keys(this)){const n=this[t];n instanceof Hr&&e.push(n.handler.dispose())}return await Promise.all(e)}static async from_pretrained(e,{quantized:t=!0,progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:o=null}={}){let l={quantized:t,progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i,model_file_name:o};const u=Xr.get(this),c=Kr.get(u);let d;return 4===c?d=await Promise.all([Ar.from_pretrained(e,l),Qr(e,l.model_file_name??"decoder_model_merged",l),U(e,"generation_config.json",!1,l)]):2===c||3===c?d=await Promise.all([Ar.from_pretrained(e,l),Qr(e,"encoder_model",l),Qr(e,"decoder_model_merged",l),U(e,"generation_config.json",!1,l)]):5===c?d=await Promise.all([Ar.from_pretrained(e,l),Qr(e,"vision_encoder",l),Qr(e,"prompt_encoder_mask_decoder",l)]):1===c?d=await Promise.all([Ar.from_pretrained(e,l),Qr(e,"encoder_model",l),Qr(e,"decoder_model_merged",l)]):(0!==c&&console.warn(`Model type for '${u??r?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),d=await Promise.all([Ar.from_pretrained(e,l),Qr(e,l.model_file_name??"model",l)])),new this(...d)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}_get_logits_processor(e,t,n=null){const r=new Cr;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new Lr(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new Mr(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&r.push(new Br(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&r.push(new Pr(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&r.push(new zr(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&r.push(new Or(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new Dr(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){let n=t>1||null===e.forced_bos_token_id?t:t+1;null!==e.forced_decoder_ids&&(n+=e.forced_decoder_ids[e.forced_decoder_ids.length-1][0]),r.push(new Fr(e.begin_suppress_tokens,n))}return null!==e.forced_decoder_ids&&r.push(new $r(e.forced_decoder_ids)),null!==n&&r.extend(n),r}_get_generation_config(e){let t=new Vr(this.config);return"generation_config"in this&&Object.assign(t,this.generation_config),null!==e&&Object.assign(t,e),t}async generate(e,t=null,n=null,{inputs_attention_mask:r=null}={}){if(!this.can_generate){let e=`The current model class (${Xr.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const t=this.config.model_type,n=uc.get(t)??lc.get(t)??rc.get(t)??hc.get(t);throw n&&(e+=` Please use the following class instead: '${n[0]}'`),Error(e)}if(!(e instanceof ue||(s=e,"TypedArray"===s?.prototype?.__proto__?.constructor?.name)||Array.isArray(e)))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${e.constructor.name}".`);var s;let a;if(this.config.is_encoder_decoder)a=0;else if(a=e instanceof ue?e.dims.at(-1):e.length,0===a)throw Error("Must supply a non-empty array of input token ids.");t=this._get_generation_config(t),n=n??new Cr,n=this._get_logits_processor(t,a,n);let i=t.eos_token_id;null===i||Array.isArray(i)||(i=[i]);let o=1;const l=o+(t.max_new_tokens??1/0),u=Number.isInteger(t.max_length)&&null===(t.max_new_tokens??null);let c=Ur.getSampler(t),d=this.getStartBeams(e,t,o,r);for(;d.some((e=>!e.done))&&o<l;){let e=[];for(let r of d){if(r.done){e.push(r);continue}if(u&&r.output_token_ids.length>=t.max_length){r.done=!0,e.push(r);continue}let s=await this.runBeam(r);t.output_attentions&&this.addAttentionsToBeam(r,s),t.output_scores;let a=s.logits.slice(null,-1,null);n(r.output_token_ids,a);let o=c(a);for(let[t,n]of o){let s={...r};this.updateBeam(s,t),s.score+=n,i&&i.includes(t)&&(s.done=!0),e.push(s)}}++o,e=this.groupBeams(e).map((e=>e.sort(((e,t)=>t.score-e.score)).slice(0,t.num_beams))),d=e.flat(),t.callback_function&&t.callback_function(d)}const h=this.groupBeams(d),p=e=>h.map((n=>t.num_return_sequences>1?n.slice(0,t.num_return_sequences).map((t=>t[e])):[n[0][e]])).flat(),f=p("output_token_ids");return t.return_dict_in_generate?{sequences:f,decoder_attentions:p("decoder_attentions"),cross_attentions:p("cross_attentions")}:f}addAttentionsToBeam(e,t){if(this.config.is_encoder_decoder){if(!t.cross_attentions||0===t.cross_attentions.length)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.cross_attentions||(e.cross_attentions=[]),e.cross_attentions.push(t.cross_attentions)}if(!t.decoder_attentions||0===t.decoder_attentions.length)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.decoder_attentions||(e.decoder_attentions=[]),e.decoder_attentions.push(t.decoder_attentions)}groupBeams(e){const t=Object.create(null);for(const n of e)void 0===t[n.id]?t[n.id]=[n]:t[n.id].push(n);return Object.values(t)}getPastKeyValues(e,t){const n=Object.create(null);for(const r in e)if(r.startsWith("present")){let s=r.replace("present","past_key_values");t&&r.includes("encoder")?n[s]=t[s]:n[s]=e[r]}return n}getAttentions(e){const t=Object.create(null);for(const n of["cross_attentions","decoder_attentions"]){const r=[];for(const t in e)t.startsWith(n)&&(r[t.split(".").pop()]=e[t]);t[n]=r}return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=1;if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??1)){let n=[t,this.num_encoder_heads,0,this.encoder_dim_kv],r=[t,this.num_decoder_heads,0,this.decoder_dim_kv];for(let t=0;t<this.num_decoder_layers;++t)e[`past_key_values.${t}.encoder.key`]=new ue("float32",[],n),e[`past_key_values.${t}.encoder.value`]=new ue("float32",[],n),e[`past_key_values.${t}.decoder.key`]=new ue("float32",[],r),e[`past_key_values.${t}.decoder.value`]=new ue("float32",[],r)}else if("falcon"===this.config.model_type){let n=[t*this.num_heads,0,this.dim_kv];for(let t=0;t<this.num_layers;++t)e[`past_key_values.${t}.key`]=new ue("float32",[],n),e[`past_key_values.${t}.value`]=new ue("float32",[],n)}else if(this.config.multi_query){let n=[t*this.num_heads,0,2*this.dim_kv];for(let t=0;t<this.num_layers;++t)e[`past_key_values.${t}.key_value`]=new ue("float32",[],n)}else if("bloom"===this.config.model_type){let n=[t*this.num_heads,this.dim_kv,0],r=[t*this.num_heads,0,this.dim_kv];for(let t=0;t<this.num_layers;++t)e[`past_key_values.${t}.key`]=new ue("float32",[],n),e[`past_key_values.${t}.value`]=new ue("float32",[],r)}else{let n=[t,this.num_heads,0,this.dim_kv];for(let t=0;t<this.num_layers;++t)e[`past_key_values.${t}.key`]=new ue("float32",[],n),e[`past_key_values.${t}.value`]=new ue("float32",[],n)}}}getStartBeams(e,t,n,r){return this._getStartBeams(this,e,t,n,r)}async runBeam(e){return await this._runBeam(this,e)}updateBeam(e,t){return this._updateBeam(e,t)}}class ms{}class gs extends ms{constructor({last_hidden_state:e,hidden_states:t=null,attentions:n=null}){super(),this.last_hidden_state=e,this.hidden_states=t,this.attentions=n}}class bs extends fs{}class ys extends bs{}class ws extends bs{async _call(e){return new id(await super._call(e))}}class vs extends bs{async _call(e){return new rd(await super._call(e))}}class xs extends bs{async _call(e){return new ad(await super._call(e))}}class _s extends bs{async _call(e){return new od(await super._call(e))}}class ks extends fs{}class Ss extends ks{}class Ts extends fs{}class Is extends Ts{}class Es extends Ts{async _call(e){return new id(await super._call(e))}}class As extends Ts{async _call(e){return new rd(await super._call(e))}}class Cs extends Ts{async _call(e){return new ad(await super._call(e))}}class Ns extends Ts{async _call(e){return new od(await super._call(e))}}class $s extends fs{}class Os extends $s{}class Ds extends $s{async _call(e){return new id(await super._call(e))}}class Fs extends $s{async _call(e){return new rd(await super._call(e))}}class Rs extends $s{async _call(e){return new ad(await super._call(e))}}class Ms extends $s{async _call(e){return new od(await super._call(e))}}class Ls extends fs{}class Ps extends Ls{}class zs extends Ls{async _call(e){return new id(await super._call(e))}}class Bs extends Ls{async _call(e){return new rd(await super._call(e))}}class Vs extends Ls{async _call(e){return new ad(await super._call(e))}}class Us extends Ls{async _call(e){return new od(await super._call(e))}}class js extends fs{}class Ws extends js{}class Gs extends js{async _call(e){return new id(await super._call(e))}}class Hs extends js{async _call(e){return new rd(await super._call(e))}}class qs extends js{async _call(e){return new ad(await super._call(e))}}class Zs extends js{async _call(e){return new od(await super._call(e))}}class Ks extends fs{}class Ys extends Ks{}class Xs extends Ks{async _call(e){return new id(await super._call(e))}}class Qs extends Ks{async _call(e){return new rd(await super._call(e))}}class Js extends Ks{async _call(e){return new ad(await super._call(e))}}class ea extends Ks{async _call(e){return new od(await super._call(e))}}class ta extends fs{}class na extends ta{}class ra extends ta{async _call(e){return new id(await super._call(e))}}class sa extends ta{async _call(e){return new rd(await super._call(e))}}class aa extends ta{async _call(e){return new ad(await super._call(e))}}class ia extends ta{async _call(e){return new od(await super._call(e))}}class oa extends fs{}class la extends oa{}class ua extends oa{async _call(e){return new rd(await super._call(e))}}class ca extends oa{async _call(e){return new ad(await super._call(e))}}class da extends oa{async _call(e){return new od(await super._call(e))}}class ha extends oa{async _call(e){return new id(await super._call(e))}}class pa extends fs{}class fa extends pa{}class ma extends pa{async _call(e){return new id(await super._call(e))}}class ga extends pa{async _call(e){return new rd(await super._call(e))}}class ba extends pa{async _call(e){return new ad(await super._call(e))}}class ya extends fs{}class wa extends ya{}class va extends ya{async _call(e){return new id(await super._call(e))}}class xa extends ya{async _call(e){return new rd(await super._call(e))}}class _a extends ya{async _call(e){return new od(await super._call(e))}}class ka extends fs{}class Sa extends ka{}class Ta extends ka{async _call(e){return new id(await super._call(e))}}class Ia extends ka{async _call(e){return new rd(await super._call(e))}}class Ea extends ka{async _call(e){return new ad(await super._call(e))}}class Aa extends ka{async _call(e){return new od(await super._call(e))}}class Ca extends fs{}class Na extends Ca{}class $a extends Ca{async _call(e){return new id(await super._call(e))}}class Oa extends Ca{async _call(e){return new rd(await super._call(e))}}class Da extends Ca{async _call(e){return new od(await super._call(e))}}class Fa extends fs{}class Ra extends Fa{}class Ma extends Fa{async _call(e){return new rd(await super._call(e))}}class La extends Fa{async _call(e){return new od(await super._call(e))}}class Pa extends Fa{async _call(e){return new id(await super._call(e))}}class za extends fs{}class Ba extends za{}class Va extends za{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class Ua extends fs{}class ja extends Ua{}class Wa extends Ua{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class Ga extends fs{}class Ha extends Ga{}class qa extends Ga{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class Za extends fs{}class Ka extends Za{}class Ya extends Za{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Xa extends Za{async _call(e){return new rd(await super._call(e))}}class Qa extends fs{}class Ja extends Qa{}class ei extends Qa{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class ti extends Qa{async _call(e){return new rd(await super._call(e))}}class ni extends Qa{constructor(e,t,n){super(e,t),this.generation_config=n,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class ri extends fs{}class si extends ri{}class ai extends ri{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class ii extends fs{}class oi extends ii{}class li extends ii{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class ui extends fs{}class ci extends ui{}class di extends ui{async _call(e){return new id(await super._call(e))}}class hi extends ui{async _call(e){return new rd(await super._call(e))}}class pi extends ui{async _call(e){return new ad(await super._call(e))}}class fi extends ui{async _call(e){return new od(await super._call(e))}}class mi extends fs{}class gi extends mi{}class bi extends mi{async _call(e){return new id(await super._call(e))}}class yi extends mi{async _call(e){return new rd(await super._call(e))}}class wi extends mi{async _call(e){return new ad(await super._call(e))}}class vi extends mi{async _call(e){return new od(await super._call(e))}}class xi extends fs{}class _i extends xi{}class ki extends xi{async _call(e){return new id(await super._call(e))}}class Si extends xi{async _call(e){return new rd(await super._call(e))}}class Ti extends xi{async _call(e){return new ad(await super._call(e))}}class Ii extends xi{async _call(e){return new od(await super._call(e))}}class Ei extends fs{}class Ai extends Ei{}class Ci extends Ei{}class Ni extends fs{}class $i extends Ni{}class Oi extends Ni{requires_attention_mask=!1;main_input_name="input_features";constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(e,t=null,n=null){if(t=this._get_generation_config(t),t.return_timestamps??=!1,t.return_timestamps&&(n=[new Rr(t)]),t.return_token_timestamps&&(t.output_attentions=!0,t.return_dict_in_generate=!0,"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!t.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const r=await super.generate(e,t,n);return t.return_token_timestamps&&t.alignment_heads&&(r.token_timestamps=this._extract_token_timestamps(r,t.alignment_heads,t.num_frames)),r}_extract_token_timestamps(e,t,n=null,r=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);const a=e.cross_attentions.map((e=>{let r=Array.from({length:this.config.decoder_layers},((t,n)=>be(e.map((e=>e[n])),2))),a=ye(t.map((([e,t])=>n?r[e].slice(null,t,null,[0,n]):r[e].slice(null,t))));a=a.transpose(1,0,2,3);let[i,o]=we(a,-2,0,!0),l=a.clone();for(let e=0;e<l.dims[0];++e){let t=l[e];for(let n=0;n<t.dims[0];++n){let r=t[n];const a=i[e][n][0],l=o[e][n][0];for(let e=0;e<r.dims[0];++e){let t=r[e];for(let e=0;e<t.data.length;++e)t.data[e]=(t.data[e]-l.data[e])/a.data[e];t.data.set(se(t.data,s))}}}return ve(l,1)})),i=[e.sequences.length,e.sequences[0].length],o=new ue("float32",new Float32Array(i[0]*i[1]),i);for(let e=0;e<i[0];++e){const t=a[e].neg().squeeze_(0);let[n,s]=xe(t),i=u([1],Array.from({length:n.length-1},((e,t)=>n[t+1]-n[t]))).map((e=>!!e)),l=[];for(let e=0;e<i.length;++e)i[e]&&l.push(s[e]*r);o[e].data.set(l,1)}return o}}class Di extends fs{main_input_name="pixel_values";constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r;const s=this.config.encoder,a=this.config.decoder,i=s.model_type;(ec.get(i)??tc.get(i))||console.warn(`Model type for encoder '${i}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const o=uc.get(a.model_type);if(!o)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const l=new(0,o[1])(a,n,r);this.add_encoder_pkv="num_decoder_layers"in l,this.add_encoder_pkv?(this.num_decoder_layers=l.num_decoder_layers,this.num_decoder_heads=l.num_decoder_heads,this.decoder_dim_kv=l.decoder_dim_kv,this.num_encoder_layers=l.num_encoder_layers,this.num_encoder_heads=l.num_encoder_heads,this.encoder_dim_kv=l.encoder_dim_kv):(this.num_layers=l.num_layers,this.num_heads=l.num_heads,this.dim_kv=l.dim_kv)}}class Fi extends fs{}class Ri extends Fi{}class Mi extends Fi{static async from_pretrained(e,t={}){return t.model_file_name??="text_model",super.from_pretrained(e,t)}}class Li extends Fi{static async from_pretrained(e,t={}){return t.model_file_name??="vision_model",super.from_pretrained(e,t)}}class Pi extends fs{}class zi extends Pi{}class Bi extends Pi{static async from_pretrained(e,t={}){return t.model_file_name??="text_model",super.from_pretrained(e,t)}}class Vi extends Fi{static async from_pretrained(e,t={}){return t.model_file_name??="vision_model",super.from_pretrained(e,t)}}class Ui extends fs{}class ji extends Ui{}class Wi extends fs{}class Gi extends Wi{}class Hi extends Wi{}class qi extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class Zi extends qi{}class Ki extends qi{}class Yi extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class Xi extends Yi{}class Qi extends Yi{}class Ji extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class eo extends Ji{}class to extends Ji{}class no extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class ro extends no{}class so extends no{}class ao extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class io extends ao{}class oo extends ao{}class lo extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class uo extends lo{}class co extends lo{}class ho extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class po extends ho{}class fo extends ho{}class mo extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class go extends mo{}class bo extends mo{}class yo extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class wo extends yo{}class vo extends yo{}class xo extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class _o extends xo{}class ko extends xo{}class So extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class To extends So{}class Io extends So{}class Eo extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class Ao extends Eo{}class Co extends Eo{}class No extends fs{}class $o extends No{}class Oo extends No{async _call(e){return new rd(await super._call(e))}}class Do extends fs{}class Fo extends Do{async _call(e){return new cd(await super._call(e))}}class Ro extends fs{}class Mo extends Ro{}class Lo extends Ro{async _call(e){return new rd(await super._call(e))}}class Po extends fs{}class zo extends Po{}class Bo extends Po{}class Vo extends fs{}class Uo extends Vo{}class jo extends Vo{}class Wo extends fs{}class Go extends Wo{}class Ho extends Wo{async _call(e){return new rd(await super._call(e))}}class qo extends fs{}class Zo extends qo{}class Ko extends qo{async _call(e){return new Xo(await super._call(e))}}class Yo extends qo{async _call(e){return new Qo(await super._call(e))}}class Xo extends ms{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Qo extends ms{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class Jo extends fs{}class el extends Jo{}class tl extends Jo{async _call(e){return new nl(await super._call(e))}}class nl extends Xo{}class rl extends fs{}class sl extends rl{}class al extends rl{async _call(e){return new rd(await super._call(e))}}class il extends fs{}class ol extends il{}class ll extends il{async _call(e){return new rd(await super._call(e))}}class ul extends fs{}class cl extends ul{}class dl extends ul{async _call(e){return new rd(await super._call(e))}}class hl extends fs{}class pl extends hl{}class fl extends hl{}class ml extends fs{}class gl extends ml{}class bl extends ml{}class yl extends fs{}class wl extends yl{}class vl extends fs{}class xl extends vl{}class _l extends vl{}class kl extends fs{}class Sl extends kl{}class Tl extends fs{}class Il extends Tl{}class El extends Tl{async _call(e){return new rd(await super._call(e))}}class Al extends fs{}class Cl extends Al{}class Nl extends Al{async _call(e){return new rd(await super._call(e))}}class $l extends fs{}class Ol extends $l{}class Dl extends $l{async _call(e){return new rd(await super._call(e))}}class Fl extends fs{}class Rl extends Fl{}class Ml extends Fl{async _call(e){return new Ll(await super._call(e))}}class Ll extends ms{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Pl extends fs{}class zl extends Pl{constructor(e,t,n){super(e,t),this.prompt_encoder_mask_decoder=n}async get_image_embeddings({pixel_values:e}){return await us(this,{pixel_values:e})}async forward(e){if(e.image_embeddings&&e.image_positional_embeddings||(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels){const t=e.input_points.dims.slice(0,-1),n=t.reduce(((e,t)=>e*t),1);e.input_labels=new ue("int64",new BigInt64Array(n).fill(1n),t)}return await Jr(this.prompt_encoder_mask_decoder,{input_points:e.input_points,input_labels:e.input_labels,image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings})}async _call(e){return new Bl(await super._call(e))}}class Bl extends ms{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class Vl extends fs{}class Ul extends Vl{}class jl extends Vl{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wl extends fs{}class Gl extends Wl{}class Hl extends Wl{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class ql extends fs{}class Zl extends ql{}class Kl extends ql{async _call(e){return new ld(await super._call(e))}}class Yl extends ql{async _call(e){return new rd(await super._call(e))}}class Xl extends ql{async _call(e){return new ad(await super._call(e))}}class Ql extends fs{}class Jl extends Ql{}class eu extends Ql{async _call(e){return new ld(await super._call(e))}}class tu extends Ql{async _call(e){return new rd(await super._call(e))}}class nu extends fs{}class ru extends nu{}class su extends nu{async _call(e){return new ld(await super._call(e))}}class au extends nu{async _call(e){return new rd(await super._call(e))}}class iu extends nu{async _call(e){return new ad(await super._call(e))}}class ou extends fs{}class lu extends ou{}class uu extends ou{async _call(e){return new ld(await super._call(e))}}class cu extends ou{async _call(e){return new rd(await super._call(e))}}class du extends fs{}class hu extends ql{}class pu extends ql{async _call(e){return new ld(await super._call(e))}}class fu extends ql{async _call(e){return new rd(await super._call(e))}}class mu extends fs{}class gu extends mu{}class bu extends mu{async _call(e){return new ld(await super._call(e))}}class yu extends mu{async _call(e){return new rd(await super._call(e))}}class wu extends mu{async _call(e){return new sd(await super._call(e))}}class vu extends mu{async _call(e){return new ad(await super._call(e))}}class xu extends fs{}class _u extends xu{}class ku extends xu{}class Su extends xu{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(e,t,{threshold:n=.5,minlenratio:r=0,maxlenratio:s=20,vocoder:a=null}={}){const i={input_ids:e},{encoder_outputs:o,encoder_attention_mask:l}=await us(this,i),u=o.dims[1]/this.config.reduction_factor,c=Math.floor(u*s),d=Math.floor(u*r),h=this.config.num_mel_bins;let p=[],f=null,m=null,g=0;for(;;){++g;const e=ss(!!m);let r;r=m?m.output_sequence_out:new ue("float32",new Float32Array(h),[1,1,h]);let s={use_cache_branch:e,output_sequence:r,encoder_attention_mask:l,speaker_embeddings:t,encoder_hidden_states:o};this.addPastKeyValues(s,f),m=await Jr(this.decoder_merged_session,s),f=this.getPastKeyValues(m,f);const{prob:a,spectrum:i}=m;if(p.push(i),g>=d&&(Array.from(a.data).filter((e=>e>=n)).length>0||g>=c))break}const b=be(p),{waveform:y}=await Jr(a.session,{spectrogram:b});return{spectrogram:b,waveform:y}}}class Tu extends fs{main_input_name="spectrogram"}class Iu extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class Eu extends Iu{}class Au extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Cu extends Au{}class Nu extends Au{}class $u extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Ou extends $u{}class Du extends $u{}class Fu extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Ru extends Fu{}class Mu extends Fu{}class Lu extends fs{}class Pu extends Lu{}class zu extends Lu{static async from_pretrained(e,t={}){return t.model_file_name??="text_model",super.from_pretrained(e,t)}}class Bu extends Lu{static async from_pretrained(e,t={}){return t.model_file_name??="audio_model",super.from_pretrained(e,t)}}class Vu extends fs{}class Uu extends Vu{async _call(e){return new dd(await super._call(e))}}class ju extends fs{}class Wu extends ju{}class Gu extends ju{}class Hu extends ju{}class qu extends fs{constructor(e,t,n){super(e,t),this.generation_config=n,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class Zu extends qu{}class Ku extends qu{}class Yu extends fs{}class Xu extends Yu{}class Qu extends Yu{async _call(e){return new rd(await super._call(e))}}class Ju{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{quantized:t=!0,progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:o=null}={}){let l={quantized:t,progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i,model_file_name:o};if(r=await Ar.from_pretrained(e,l),l.config||(l.config=r),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let t of this.MODEL_CLASS_MAPPINGS){const n=t.get(r.model_type);if(n)return await n[1].from_pretrained(e,l)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${r.model_type}", attempting to construct from base class.`),await fs.from_pretrained(e,l);throw Error(`Unsupported model type: ${r.model_type}`)}}const ec=new Map([["bert",["BertModel",ys]],["nomic_bert",["NomicBertModel",Ss]],["roformer",["RoFormerModel",Is]],["electra",["ElectraModel",Ps]],["esm",["EsmModel",fa]],["convbert",["ConvBertModel",Os]],["camembert",["CamembertModel",Ws]],["deberta",["DebertaModel",Ys]],["deberta-v2",["DebertaV2Model",na]],["mpnet",["MPNetModel",Sa]],["albert",["AlbertModel",Ra]],["distilbert",["DistilBertModel",la]],["roberta",["RobertaModel",ci]],["xlm",["XLMModel",gi]],["xlm-roberta",["XLMRobertaModel",_i]],["clap",["ClapModel",Pu]],["clip",["CLIPModel",Ri]],["clipseg",["CLIPSegModel",Gi]],["chinese_clip",["ChineseCLIPModel",ji]],["siglip",["SiglipModel",zi]],["mobilebert",["MobileBertModel",wa]],["squeezebert",["SqueezeBertModel",Na]],["wav2vec2",["Wav2Vec2Model",Zl]],["wav2vec2-bert",["Wav2Vec2BertModel",lu]],["unispeech",["UniSpeechModel",Jl]],["unispeech-sat",["UniSpeechSatModel",ru]],["hubert",["HubertModel",hu]],["wavlm",["WavLMModel",gu]],["audio-spectrogram-transformer",["ASTModel",Ai]],["vits",["VitsModel",Uu]],["detr",["DetrModel",Zo]],["table-transformer",["TableTransformerModel",el]],["vit",["ViTModel",$o]],["mobilevit",["MobileViTModel",Mo]],["owlvit",["OwlViTModel",zo]],["owlv2",["Owlv2Model",Uo]],["beit",["BeitModel",Go]],["deit",["DeiTModel",sl]],["convnext",["ConvNextModel",Il]],["convnextv2",["ConvNextV2Model",Cl]],["dinov2",["Dinov2Model",Ol]],["resnet",["ResNetModel",ol]],["swin",["SwinModel",cl]],["swin2sr",["Swin2SRModel",pl]],["donut-swin",["DonutSwinModel",Sl]],["yolos",["YolosModel",Rl]],["dpt",["DPTModel",gl]],["glpn",["GLPNModel",xl]],["hifigan",["SpeechT5HifiGan",Tu]],["efficientnet",["EfficientNetModel",Xu]]]),tc=new Map([["t5",["T5Model",Ba]],["longt5",["LongT5Model",ja]],["mt5",["MT5Model",Ha]],["bart",["BartModel",Ka]],["mbart",["MBartModel",Ja]],["marian",["MarianModel",Ul]],["whisper",["WhisperModel",$i]],["m2m_100",["M2M100Model",Gl]],["blenderbot",["BlenderbotModel",si]],["blenderbot-small",["BlenderbotSmallModel",oi]]]),nc=new Map([["bloom",["BloomModel",_o]],["gpt2",["GPT2Model",Zi]],["gptj",["GPTJModel",ro]],["gpt_bigcode",["GPTBigCodeModel",io]],["gpt_neo",["GPTNeoModel",Xi]],["gpt_neox",["GPTNeoXModel",eo]],["codegen",["CodeGenModel",uo]],["llama",["LlamaModel",po]],["qwen2",["Qwen2Model",go]],["phi",["PhiModel",wo]],["mpt",["MptModel",To]],["opt",["OPTModel",Ao]],["mistral",["MistralModel",Cu]],["starcoder2",["Starcoder2Model",Ou]],["falcon",["FalconModel",Ru]]]),rc=new Map([["speecht5",["SpeechT5ForSpeechToText",ku]],["whisper",["WhisperForConditionalGeneration",Oi]]]),sc=new Map([["speecht5",["SpeechT5ForTextToSpeech",Su]]]),ac=new Map([["vits",["VitsModel",Uu]]]),ic=new Map([["bert",["BertForSequenceClassification",vs]],["roformer",["RoFormerForSequenceClassification",As]],["electra",["ElectraForSequenceClassification",Bs]],["esm",["EsmForSequenceClassification",ga]],["convbert",["ConvBertForSequenceClassification",Fs]],["camembert",["CamembertForSequenceClassification",Hs]],["deberta",["DebertaForSequenceClassification",Qs]],["deberta-v2",["DebertaV2ForSequenceClassification",sa]],["mpnet",["MPNetForSequenceClassification",Ia]],["albert",["AlbertForSequenceClassification",Ma]],["distilbert",["DistilBertForSequenceClassification",ua]],["roberta",["RobertaForSequenceClassification",hi]],["xlm",["XLMForSequenceClassification",yi]],["xlm-roberta",["XLMRobertaForSequenceClassification",Si]],["bart",["BartForSequenceClassification",Xa]],["mbart",["MBartForSequenceClassification",ti]],["mobilebert",["MobileBertForSequenceClassification",xa]],["squeezebert",["SqueezeBertForSequenceClassification",Oa]]]),oc=new Map([["bert",["BertForTokenClassification",xs]],["roformer",["RoFormerForTokenClassification",Cs]],["electra",["ElectraForTokenClassification",Vs]],["esm",["EsmForTokenClassification",ba]],["convbert",["ConvBertForTokenClassification",Rs]],["camembert",["CamembertForTokenClassification",qs]],["deberta",["DebertaForTokenClassification",Js]],["deberta-v2",["DebertaV2ForTokenClassification",aa]],["mpnet",["MPNetForTokenClassification",Ea]],["distilbert",["DistilBertForTokenClassification",ca]],["roberta",["RobertaForTokenClassification",pi]],["xlm",["XLMForTokenClassification",wi]],["xlm-roberta",["XLMRobertaForTokenClassification",Ti]]]),lc=new Map([["t5",["T5ForConditionalGeneration",Va]],["longt5",["LongT5ForConditionalGeneration",Wa]],["mt5",["MT5ForConditionalGeneration",qa]],["bart",["BartForConditionalGeneration",Ya]],["mbart",["MBartForConditionalGeneration",ei]],["marian",["MarianMTModel",jl]],["m2m_100",["M2M100ForConditionalGeneration",Hl]],["blenderbot",["BlenderbotForConditionalGeneration",ai]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",li]]]),uc=new Map([["bloom",["BloomForCausalLM",ko]],["gpt2",["GPT2LMHeadModel",Ki]],["gptj",["GPTJForCausalLM",so]],["gpt_bigcode",["GPTBigCodeForCausalLM",oo]],["gpt_neo",["GPTNeoForCausalLM",Qi]],["gpt_neox",["GPTNeoXForCausalLM",to]],["codegen",["CodeGenForCausalLM",co]],["llama",["LlamaForCausalLM",fo]],["qwen2",["Qwen2ForCausalLM",bo]],["phi",["PhiForCausalLM",vo]],["mpt",["MptForCausalLM",Io]],["opt",["OPTForCausalLM",Co]],["mbart",["MBartForCausalLM",ni]],["mistral",["MistralForCausalLM",Nu]],["starcoder2",["Starcoder2ForCausalLM",Du]],["falcon",["FalconForCausalLM",Mu]],["trocr",["TrOCRForCausalLM",Eu]],["stablelm",["StableLmForCausalLM",Ku]]]),cc=new Map([["bert",["BertForMaskedLM",ws]],["roformer",["RoFormerForMaskedLM",Es]],["electra",["ElectraForMaskedLM",zs]],["esm",["EsmForMaskedLM",ma]],["convbert",["ConvBertForMaskedLM",Ds]],["camembert",["CamembertForMaskedLM",Gs]],["deberta",["DebertaForMaskedLM",Xs]],["deberta-v2",["DebertaV2ForMaskedLM",ra]],["mpnet",["MPNetForMaskedLM",Ta]],["albert",["AlbertForMaskedLM",Pa]],["distilbert",["DistilBertForMaskedLM",ha]],["roberta",["RobertaForMaskedLM",di]],["xlm",["XLMWithLMHeadModel",bi]],["xlm-roberta",["XLMRobertaForMaskedLM",ki]],["mobilebert",["MobileBertForMaskedLM",va]],["squeezebert",["SqueezeBertForMaskedLM",$a]]]),dc=new Map([["bert",["BertForQuestionAnswering",_s]],["roformer",["RoFormerForQuestionAnswering",Ns]],["electra",["ElectraForQuestionAnswering",Us]],["convbert",["ConvBertForQuestionAnswering",Ms]],["camembert",["CamembertForQuestionAnswering",Zs]],["deberta",["DebertaForQuestionAnswering",ea]],["deberta-v2",["DebertaV2ForQuestionAnswering",ia]],["mpnet",["MPNetForQuestionAnswering",Aa]],["albert",["AlbertForQuestionAnswering",La]],["distilbert",["DistilBertForQuestionAnswering",da]],["roberta",["RobertaForQuestionAnswering",fi]],["xlm",["XLMForQuestionAnswering",vi]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Ii]],["mobilebert",["MobileBertForQuestionAnswering",_a]],["squeezebert",["SqueezeBertForQuestionAnswering",Da]]]),hc=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Di]]]),pc=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Di]]]),fc=new Map([["vit",["ViTForImageClassification",Oo]],["mobilevit",["MobileViTForImageClassification",Lo]],["beit",["BeitForImageClassification",Ho]],["deit",["DeiTForImageClassification",al]],["convnext",["ConvNextForImageClassification",El]],["convnextv2",["ConvNextV2ForImageClassification",Nl]],["dinov2",["Dinov2ForImageClassification",Dl]],["resnet",["ResNetForImageClassification",ll]],["swin",["SwinForImageClassification",dl]],["segformer",["SegformerForImageClassification",Gu]],["efficientnet",["EfficientNetForImageClassification",Qu]]]),mc=new Map([["detr",["DetrForObjectDetection",Ko]],["table-transformer",["TableTransformerForObjectDetection",tl]],["yolos",["YolosForObjectDetection",Ml]]]),gc=new Map([["owlvit",["OwlViTForObjectDetection",Bo]],["owlv2",["Owlv2ForObjectDetection",jo]]]),bc=new Map([["detr",["DetrForSegmentation",Yo]],["clipseg",["CLIPSegForImageSegmentation",Hi]]]),yc=new Map([["segformer",["SegformerForSemanticSegmentation",Hu]]]),wc=new Map([["sam",["SamModel",zl]]]),vc=new Map([["wav2vec2",["Wav2Vec2ForCTC",Kl]],["wav2vec2-bert",["Wav2Vec2BertForCTC",uu]],["unispeech",["UniSpeechForCTC",eu]],["unispeech-sat",["UniSpeechSatForCTC",su]],["wavlm",["WavLMForCTC",bu]],["hubert",["HubertForCTC",pu]]]),xc=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Yl]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",cu]],["unispeech",["UniSpeechForSequenceClassification",tu]],["unispeech-sat",["UniSpeechSatForSequenceClassification",au]],["wavlm",["WavLMForSequenceClassification",yu]],["hubert",["HubertForSequenceClassification",fu]],["audio-spectrogram-transformer",["ASTForAudioClassification",Ci]]]),_c=new Map([["wavlm",["WavLMForXVector",wu]]]),kc=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",iu]],["wavlm",["WavLMForAudioFrameClassification",vu]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Xl]]]),Sc=new Map([["vitmatte",["VitMatteForImageMatting",Fo]]]),Tc=new Map([["swin2sr",["Swin2SRForImageSuperResolution",fl]]]),Ic=new Map([["dpt",["DPTForDepthEstimation",bl]],["depth_anything",["DepthAnythingForDepthEstimation",wl]],["glpn",["GLPNForDepthEstimation",_l]]]),Ec=new Map([["clip",["CLIPVisionModelWithProjection",Li]],["siglip",["SiglipVisionModel",Vi]]]),Ac=[[ec,0],[tc,1],[nc,4],[ic,0],[oc,0],[lc,2],[rc,2],[uc,4],[cc,0],[dc,0],[hc,3],[fc,0],[bc,0],[yc,0],[Sc,0],[Tc,0],[Ic,0],[mc,0],[gc,0],[wc,5],[vc,0],[xc,0],[sc,2],[ac,0],[_c,0],[kc,0],[Ec,0]];for(const[e,t]of Ac)for(const[n,r]of e.values())Kr.set(n,t),Xr.set(r,n),Yr.set(n,r);const Cc=[["CLIPTextModelWithProjection",Mi,0],["SiglipTextModel",Bi,0],["ClapTextModelWithProjection",zu,0],["ClapAudioModelWithProjection",Bu,0]];for(const[e,t,n]of Cc)Kr.set(e,n),Xr.set(t,e),Yr.set(e,t);class Nc extends Ju{static MODEL_CLASS_MAPPINGS=Ac.map((e=>e[0]));static BASE_IF_FAIL=!0}class $c extends Ju{static MODEL_CLASS_MAPPINGS=[ic]}class Oc extends Ju{static MODEL_CLASS_MAPPINGS=[oc]}class Dc extends Ju{static MODEL_CLASS_MAPPINGS=[lc]}class Fc extends Ju{static MODEL_CLASS_MAPPINGS=[rc]}class Rc extends Ju{static MODEL_CLASS_MAPPINGS=[sc]}class Mc extends Ju{static MODEL_CLASS_MAPPINGS=[ac]}class Lc extends Ju{static MODEL_CLASS_MAPPINGS=[uc]}class Pc extends Ju{static MODEL_CLASS_MAPPINGS=[cc]}class zc extends Ju{static MODEL_CLASS_MAPPINGS=[dc]}class Bc extends Ju{static MODEL_CLASS_MAPPINGS=[hc]}class Vc extends Ju{static MODEL_CLASS_MAPPINGS=[fc]}class Uc extends Ju{static MODEL_CLASS_MAPPINGS=[bc]}class jc extends Ju{static MODEL_CLASS_MAPPINGS=[yc]}class Wc extends Ju{static MODEL_CLASS_MAPPINGS=[mc]}class Gc extends Ju{static MODEL_CLASS_MAPPINGS=[gc]}class Hc extends Ju{static MODEL_CLASS_MAPPINGS=[wc]}class qc extends Ju{static MODEL_CLASS_MAPPINGS=[vc]}class Zc extends Ju{static MODEL_CLASS_MAPPINGS=[xc]}class Kc extends Ju{static MODEL_CLASS_MAPPINGS=[_c]}class Yc extends Ju{static MODEL_CLASS_MAPPINGS=[kc]}class Xc extends Ju{static MODEL_CLASS_MAPPINGS=[pc]}class Qc extends Ju{static MODEL_CLASS_MAPPINGS=[Sc]}class Jc extends Ju{static MODEL_CLASS_MAPPINGS=[Tc]}class ed extends Ju{static MODEL_CLASS_MAPPINGS=[Ic]}class td extends Ju{static MODEL_CLASS_MAPPINGS=[Ec]}class nd extends ms{constructor({logits:e,past_key_values:t,encoder_outputs:n,decoder_attentions:r=null,cross_attentions:s=null}){super(),this.logits=e,this.past_key_values=t,this.encoder_outputs=n,this.decoder_attentions=r,this.cross_attentions=s}}class rd extends ms{constructor({logits:e}){super(),this.logits=e}}class sd extends ms{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class ad extends ms{constructor({logits:e}){super(),this.logits=e}}class id extends ms{constructor({logits:e}){super(),this.logits=e}}class od extends ms{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class ld extends ms{constructor({logits:e}){super(),this.logits=e}}class ud extends ms{constructor({logits:e,past_key_values:t}){super(),this.logits=e,this.past_key_values=t}}class cd extends ms{constructor({alphas:e}){super(),this.alphas=e}}class dd extends ms{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}var hd=n(7806);const pd="undefined"!=typeof self,fd=pd&&"DedicatedWorkerGlobalScope"===self.constructor.name;let md,gd,bd;if(pd)md=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},bd=self.createImageBitmap,gd=self.ImageData;else{if(!hd)throw new Error("Unable to load image processing library.");bd=async e=>{const t=(await e.metadata()).channels;let{data:n,info:r}=await e.raw().toBuffer({resolveWithObject:!0});const s=new vd(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const yd={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},wd=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class vd{constructor(e,t,n,r){this.data=e,this.width=t,this.height=n,this.channels=r}get size(){return[this.width,this.height]}static async read(e){if(e instanceof vd)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);throw new Error("Unsupported input type: "+typeof e)}static async fromURL(e){let t=await P(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);let n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(pd){let t=await bd(e);const n=md(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{let t=hd(await e.arrayBuffer());return await bd(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new vd(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;let e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],a=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*a)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;let e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;let e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}async resize(e,t,{resample:n=2}={}){let r=yd[n]??n;if(pd){let n=this.channels,r=this.toCanvas();const s=md(e,t).getContext("2d");return s.drawImage(r,0,0,e,t),new vd(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(r){case"box":case"hamming":"box"!==r&&"hamming"!==r||(console.warn(`Resampling method ${r} is not yet supported. Using bilinear instead.`),r="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:r});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${r} is not supported.`)}return await bd(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(pd){let s=this.channels,a=this.toCanvas(),i=this.width+e+t,o=this.height+n+r;const l=md(i,o).getContext("2d");return l.drawImage(a,0,0,this.width,this.height,e,n,i,o),new vd(l.getImageData(0,0,i,o).data,i,o,4).convert(s)}{let s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await bd(s)}}async crop([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.min(n,this.width-1),r=Math.min(r,this.height-1),0===e&&0===t&&n===this.width-1&&r===this.height-1)return this;const s=n-e+1,a=r-t+1;if(pd){const n=this.channels,r=this.toCanvas(),i=md(s,a).getContext("2d");return i.drawImage(r,e,t,s,a,0,0,s,a),new vd(i.getImageData(0,0,s,a).data,s,a,4).convert(n)}{const n=this.toSharp().extract({left:e,top:t,width:s,height:a});return await bd(n)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;let n=(this.width-e)/2,r=(this.height-t)/2;if(pd){let s=this.channels,a=this.toCanvas();const i=md(e,t).getContext("2d");let o=0,l=0,u=0,c=0;return n>=0?o=n:u=-n,r>=0?l=r:c=-r,i.drawImage(a,o,l,e,t,u,c,e,t),new vd(i.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){let a=Math.floor(-r),i=Math.floor(-n);s=s.extend({top:a,left:i,right:e-this.width-i,bottom:t-this.height-a})}else{let a=[0,0],i=0;r<0?(a[0]=Math.floor(-r),a[1]=t-this.height-a[0]):i=Math.floor(r);let o=[0,0],l=0;n<0?(o[0]=Math.floor(-n),o[1]=e-this.width-o[0]):l=Math.floor(n),s=s.extend({top:a[0],bottom:a[1],left:o[0],right:o[1]}).extract({left:l,top:i,width:e,height:t})}return await bd(s)}}async toBlob(e="image/png",t=1){if(!pd)throw new Error("toBlob() is only supported in browser environments.");const n=this.toCanvas();return await n.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new ue("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!pd)throw new Error("toCanvas() is only supported in browser environments.");let e=this.clone().rgba(),t=md(e.width,e.height),n=new gd(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new vd(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!pd){if(F.useFS){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(fd)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),n=wd.get(t)??"image/png",r=await this.toBlob(n),s=URL.createObjectURL(r),a=document.createElement("a");a.href=s,a.download=e,a.click(),a.remove()}}toSharp(){if(pd)throw new Error("toSharp() is only supported in server-side environments.");return hd(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}async function xd(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const n=await(await P(e)).arrayBuffer(),r=new AudioContext({sampleRate:t});void 0===t&&console.warn(`No sampling rate provided, using default of ${r.sampleRate}Hz.`);const s=await r.decodeAudioData(n);let a;if(2===s.numberOfChannels){const e=Math.sqrt(2),t=s.getChannelData(0),n=s.getChannelData(1);a=new Float32Array(t.length);for(let r=0;r<s.length;++r)a[r]=e*(t[r]+n[r])/2}else a=s.getChannelData(0);return a}function _d(e){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const t=e-1,n=Math.PI/t,r=new Float64Array(e);for(let s=0;s<e;++s){const e=2*s-t;r[s]=.5+.5*Math.cos(n*e)}return r}const kd={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,n=15,r=27/Math.log(6.4))=>e>=t?n+Math.log(e/t)*r:3*e/200};function Sd(e,t="htk"){const n=kd[t];if(!n)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?n(e):e.map((e=>n(e)))}const Td={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,n=15,r=Math.log(6.4)/27)=>e>=n?t*Math.exp(r*(e-n)):200*e/3};function Id(e,t,n){const r=(t-e)/(n-1);return Float64Array.from({length:n},((t,n)=>e+r*n))}function Ed(e,t,n,r,s,a=null,i="htk",o=!1){if(null!==a&&"slaney"!==a)throw new Error('norm must be one of null or "slaney"');const l=Id(Sd(n,i),Sd(r,i),t+2);let u,c=function(e,t="htk"){const n=Td[t];if(!n)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?n(e):e.map((e=>n(e)))}(l,i);if(o){const t=s/(2*e);u=Sd(Float64Array.from({length:e},((e,n)=>n*t)),i),c=l}else u=Id(0,Math.floor(s/2),e);const d=function(e,t){const n=Float64Array.from({length:t.length-1},((e,n)=>t[n+1]-t[n])),r=Array.from({length:e.length},(()=>new Array(t.length)));for(let n=0;n<e.length;++n){const s=r[n];for(let r=0;r<t.length;++r)s[r]=t[r]-e[n]}const s=t.length-2,a=Array.from({length:s},(()=>new Array(e.length)));for(let t=0;t<e.length;++t){const e=r[t];for(let r=0;r<s;++r){const s=-e[r]/n[r],i=e[r+2]/n[r+1];a[r][t]=Math.max(0,Math.min(s,i))}}return a}(u,c);if(null!==a&&"slaney"===a)for(let n=0;n<t;++n){const t=d[n],r=2/(c[n+2]-c[n]);for(let n=0;n<e;++n)t[n]*=r}return d}function Ad(e,t,n,r,s){if(n<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");n=Math.max(r,n);const a=Math.log10(n);for(let n=0;n<e.length;++n)e[n]=t*Math.log10(Math.max(r,e[n])-a);if(null!==s){if(s<=0)throw new Error("db_range must be greater than zero");const t=J(e)[0]-s;for(let n=0;n<e.length;++n)e[n]=Math.max(e[n],t)}return e}function Cd(e,t,n,r,{fft_length:s=null,power:a=1,center:i=!0,pad_mode:o="reflect",onesided:l=!0,preemphasis:u=null,mel_filters:c=null,mel_floor:h=1e-10,log_mel:p=null,reference:f=1,min_value:m=1e-10,db_range:g=null,remove_dc_offset:b=null,max_num_frames:y=null,do_pad:w=!0,transpose:v=!1}={}){const x=t.length;if(null===s&&(s=n),n>s)throw Error(`frame_length (${n}) may not be larger than fft_length (${s})`);if(x!==n)throw new Error(`Length of the window (${x}) must equal frame_length (${n})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(i){if("reflect"!==o)throw new Error(`pad_mode="${o}" not implemented yet.`);const t=Math.floor((s-1)/2)+1;e=function(e,t,n){const r=new e.constructor(e.length+t+n),s=e.length-1;for(let n=0;n<e.length;++n)r[t+n]=e[n];for(let n=1;n<=t;++n)r[t-n]=e[d(n,s)];for(let a=1;a<=n;++a)r[s+t+a]=e[d(s-a,s)];return r}(e,t,t)}const _=Math.floor(1+Math.floor((e.length-n)/r)),k=l?Math.floor(s/2)+1:s;let S=_,T=_;null!==y&&(y>_?w&&(T=y):T=S=y);const I=new re(s),E=new Float64Array(s),A=new Float64Array(I.outputBufferSize),C=new Array(S);for(let s=0;s<S;++s){const a=s*r;for(let t=0;t<n;++t)E[t]=e[a+t];if(b){let e=0;for(let t=0;t<n;++t)e+=E[t];const t=e/n;for(let e=0;e<n;++e)E[e]-=t}if(null!==u){for(let e=n-1;e>=1;--e)E[e]-=u*E[e-1];E[0]*=1-u}for(let e=0;e<t.length;++e)E[e]*=t[e];I.realTransform(A,E);const i=new Array(k);for(let e=0;e<i.length;++e){const t=e<<1;i[e]=A[t]**2+A[t+1]**2}C[s]=i}if(null!==a&&2!==a){const e=2/a;for(let t=0;t<C.length;++t){const n=C[t];for(let t=0;t<n.length;++t)n[t]**=e}}const N=c.length,$=new Float32Array(N*T),O=v?[T,N]:[N,T];for(let e=0;e<N;++e){const t=c[e];for(let n=0;n<S;++n){const r=C[n];let s=0;for(let e=0;e<k;++e)s+=t[e]*r[e];$[v?n*N+e:e*S+n]=Math.max(h,s)}}if(null!==a&&null!==p){const e=Math.min($.length,S*N);switch(p){case"log":for(let t=0;t<e;++t)$[t]=Math.log($[t]);break;case"log10":for(let t=0;t<e;++t)$[t]=Math.log10($[t]);break;case"dB":if(1===a)!function(e,t=1,n=1e-5,r=null){Ad(e,20,t,n,r)}($,f,m,g);else{if(2!==a)throw new Error(`Cannot use log_mel option '${p}' with power ${a}`);!function(e,t=1,n=1e-10,r=null){Ad(e,10,t,n,r)}($,f,m,g)}break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${p}'`)}}return{data:$,dims:O}}function Nd(e,t,{periodic:n=!0,frame_length:r=null,center:s=!0}={}){const a=n?e+1:e;let i;switch(t){case"boxcar":i=new Float64Array(a).fill(1);break;case"hann":case"hann_window":i=_d(a);break;case"povey":i=_d(a).map((e=>Math.pow(e,.85)));break;default:throw new Error(`Unknown window type ${t}.`)}if(n&&(i=i.subarray(0,e)),null===r)return i;if(e>r)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${r})`);return i}function $d([e,t,n,r]){return[e-n/2,t-r/2,e+n/2,t+r/2]}function Od(e,t=.5,n=null,r=!1){const s=e.logits,a=e.pred_boxes,[i,o,l]=s.dims;if(null!==n&&n.length!==i)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let e=0;e<i;++e){let i=null!==n?n[e]:null,c={boxes:[],classes:[],scores:[]},d=s[e],h=a[e];for(let e=0;e<o;++e){let n,s=d[e],a=[];if(r){n=s.sigmoid().data;for(let e=0;e<n.length;++e)n[e]>t&&a.push(e)}else{let e=J(s.data)[1];if(e===l-1)continue;a.push(e),n=H(s.data)}for(const t of a){let r=h[e].data;r=$d(r),null!==i&&(r=r.map(((e,t)=>e*i[(t+1)%2]))),c.boxes.push(r),c.classes.push(t),c.scores.push(n[t])}}u.push(c)}return u}function Dd(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function Fd(e,t,n=0,r=null){const s=e/t;let a=ie(s)*t;return null!==r&&a>r&&(a=Math.floor(s)*t),a<n&&(a=Math.ceil(s)*t),a}function Rd([e,t],n){return[Math.max(Math.floor(e/n),1)*n,Math.max(Math.floor(t/n),1)*n]}class Md extends a{constructor(e){super(),this.config=e}}class Ld extends Md{constructor(e){super(e),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size)}async thumbnail(e,t,n=2){const r=e.height,s=e.width,a=t.height,i=t.width;let o=Math.min(r,a),l=Math.min(s,i);return o===r&&l===s?e:(r>s?l=Math.floor(s*o/r):s>r&&(o=Math.floor(r*l/s)),await e.resize(l,o,{resample:n}))}async crop_margin(e,t=200){const n=e.clone().grayscale(),r=Q(n.data)[0],s=J(n.data)[0]-r;if(0===s)return e;const a=t/255;let i=n.width,o=n.height,l=0,u=0;for(let e=0;e<n.height;++e){const t=e*n.width;for(let c=0;c<n.width;++c)(n.data[t+c]-r)/s<a&&(i=Math.min(i,c),o=Math.min(o,e),l=Math.max(l,c),u=Math.max(u,e))}return await e.crop([i,o,l,u])}pad_image(e,t,n,{mode:r="constant",center:s=!1,constant_values:a=0}={}){const[i,o,l]=t;let u,c;if("number"==typeof n?(u=n,c=n):(u=n.width,c=n.height),u!==o||c!==i){const n=new Float32Array(u*c*l);if(Array.isArray(a))for(let e=0;e<n.length;++e)n[e]=a[e%l];else 0!==a&&n.fill(a);const[h,p]=s?[Math.floor((u-o)/2),Math.floor((c-i)/2)]:[0,0];for(let t=0;t<i;++t){const r=(t+p)*u,s=t*o;for(let t=0;t<o;++t){const a=(r+t+h)*l,i=(s+t)*l;for(let t=0;t<l;++t)n[a+t]=e[i+t]}}if("symmetric"===r){if(s)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=i-1,r=o-1;for(let s=0;s<c;++s){const a=s*u,c=d(s,t)*o;for(let t=0;t<u;++t){if(s<i&&t<o)continue;const u=(a+t)*l,h=(c+d(t,r))*l;for(let t=0;t<l;++t)n[u+t]=e[h+t]}}}e=n,t=[c,u,l]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[n,r]=e.size;let s,a;if(this.do_thumbnail){const{height:e,width:n}=t;s=Math.min(e,n)}else Number.isInteger(t)?(s=t,a=this.config.max_size??s):void 0!==t&&(s=t.shortest_edge,a=t.longest_edge);if(void 0!==s||void 0!==a){const e=void 0===s?1:Math.max(s/n,s/r),t=n*e,i=r*e,o=void 0===a?1:Math.min(a/t,a/i);let l=Math.floor(Number((t*o).toFixed(2))),u=Math.floor(Number((i*o).toFixed(2)));return void 0!==this.size_divisibility&&([l,u]=Rd([l,u],this.size_divisibility)),[l,u]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,s=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=s/r,a=e/n;Math.abs(1-a)<Math.abs(1-t)?t=a:a=t,s=Fd(t*r,this.config.ensure_multiple_of),e=Fd(a*n,this.config.ensure_multiple_of)}return[e,s]}if(void 0!==this.size_divisibility)return Rd([n,r],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,n]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,n,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:n=null,do_convert_rgb:r=null,do_convert_grayscale:s=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[a,i]=e.size;if(r??this.do_convert_rgb?e=e.rgb():s&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,n;Number.isInteger(this.crop_size)?(t=this.crop_size,n=this.crop_size):(t=this.crop_size.width,n=this.crop_size.height),e=await e.center_crop(t,n)}const o=[e.height,e.width];let l=Float32Array.from(e.data),u=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(l),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let n=this.image_std;if(Array.isArray(this.image_std)||(n=new Array(e.channels).fill(t)),t.length!==e.channels||n.length!==e.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${t.length}) and \`image_std\` (${n.length}) must match the number of channels in the image (${e.channels}).`);for(let r=0;r<l.length;r+=e.channels)for(let s=0;s<e.channels;++s)l[r+s]=(l[r+s]-t[s])/n[s]}if(n??this.do_pad)if(this.pad_size){const t=this.pad_image(l,[e.height,e.width,e.channels],this.pad_size);[l,u]=t}else if(this.size_divisibility){const[e,t]=Rd([u[1],u[0]],this.size_divisibility);[l,u]=this.pad_image(l,u,{width:e,height:t})}return{original_size:[i,a],reshaped_input_size:o,pixel_values:new ue("float32",l,u).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const n=await Promise.all(e.map((e=>this.preprocess(e))));return{pixel_values:ye(n.map((e=>e.pixel_values)),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}}class Pd extends Ld{post_process_semantic_segmentation(e,t=null){const n=e.logits,r=n.dims[0];if(null!==t&&t.length!==r)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const s=[];for(let e=0;e<r;++e){const r=null!==t?t[e]:null;let a=n[e];null!==r&&(a=de(a,r,"bilinear",!1));const[i,o]=r??a.dims.slice(-2),l=new ue("int32",new Int32Array(i*o),[i,o]),u=a[0].data;for(let e=1;e<a.dims[0];++e){const t=a[e].data;for(let n=0;n<t.length;++n)t[n]>u[n]&&(u[n]=t[n],l.data[n]=e)}const c=new Array(a.dims[0]),d=l.data;for(let e=0;e<d.length;++e){const t=d[e];c[t]=t}const h=c.filter((e=>void 0!==e));s.push({segmentation:l,labels:h})}return s}}class zd extends Ld{}class Bd extends zd{}class Vd extends Ld{}class Ud extends Ld{}class jd extends Ld{}class Wd extends Ld{}class Gd extends Ld{}class Hd extends Ld{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(t<384){const n=Math.floor(t/this.crop_pct),[r,s]=this.get_resize_output_image_size(e,{shortest_edge:n});e=await e.resize(r,s,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class qd extends Hd{}class Zd extends Ld{}class Kd extends Ld{}class Yd extends Ld{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map((e=>e*e)))}}class Xd extends Ld{}class Qd extends Ld{post_process_object_detection(...e){return Od(...e)}}class Jd extends Qd{}class eh extends Ld{}class th extends Ld{}class nh extends Ld{pad_image(e,t,n,r={}){const[s,a,i]=t;let o=this.image_mean;Array.isArray(this.image_mean)||(o=new Array(i).fill(o));let l=this.image_std;Array.isArray(l)||(l=new Array(i).fill(o));const u=o.map(((e,t)=>-e/l[t]));return super.pad_image(e,t,n,{center:!0,constant_values:u,...r})}}class rh extends nh{}class sh extends Ld{async _call(e){const t=await super._call(e),n=[t.pixel_values.dims[0],64,64],r=new ue("int64",new BigInt64Array(n.reduce(((e,t)=>e*t))).fill(1n),n);return{...t,pixel_mask:r}}post_process_object_detection(...e){return Od(...e)}remove_low_and_no_objects(e,t,n,r){let s=[],a=[],i=[];for(let o=0;o<e.dims[0];++o){let l=e[o],u=t[o],c=J(l.data)[1];if(c===r)continue;let d=H(l.data)[c];d>n&&(s.push(u),a.push(d),i.push(c))}return[s,a,i]}check_segment_validity(e,t,n,r=.5,s=.8){let a=[],i=0,o=0;for(let s=0;s<e.length;++s)e[s]===n&&(a.push(s),++i),t[n].data[s]>=r&&++o;let l=i>0&&o>0;return l&&(l=i/o>s),[l,a]}compute_segments(e,t,n,r,s,a=null,i=null){let[o,l]=i??e[0].dims,u=new ue("int32",new Int32Array(o*l),[o,l]),c=[];if(null!==i)for(let t=0;t<e.length;++t)e[t]=de(e[t],i,"bilinear",!1);let d=new Int32Array(e[0].data.length),h=new Float32Array(e[0].data.length);for(let n=0;n<e.length;++n){let r=t[n];for(let t=0;t<e[n].data.length;++t)e[n].data[t]*=r,e[n].data[t]>h[t]&&(d[t]=n,h[t]=e[n].data[t])}let p=0;for(let a=0;a<n.length;++a){let i=n[a],[o,l]=this.check_segment_validity(d,e,a,r,s);if(o){++p;for(let e of l)u.data[e]=p;c.push({id:p,label_id:i,score:t[a]})}}return[u,c]}post_process_panoptic_segmentation(e,t=.5,n=.5,r=.8,s=null,a=null){null===s&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),s=new Set);const i=e.logits,o=e.pred_masks.sigmoid();let[l,u,c]=i.dims;if(c-=1,null!==a&&a.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let d=[];for(let e=0;e<l;++e){let l=null!==a?a[e]:null,u=i[e],h=o[e],[p,f,m]=this.remove_low_and_no_objects(u,h,t,c);if(0===m.length){let[e,t]=l??h.dims.slice(-2),n=new ue("int32",new Int32Array(e*t).fill(-1),[e,t]);d.push({segmentation:n,segments_info:[]});continue}let[g,b]=this.compute_segments(p,f,m,n,r,s,l);d.push({segmentation:g,segments_info:b})}return d}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class ah extends Ld{post_process_object_detection(...e){return Od(...e)}}class ih extends Ld{reshape_input_points(e,t,n){let r=o(e=structuredClone(e));if(3===r.length)r=[1,...r],e=[e];else if(4!==r.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let r=0;r<e.length;++r){let s=t[r],a=n[r],i=[a[0]/s[0],a[1]/s[1]];for(let t=0;t<e[r].length;++t)for(let n=0;n<e[r][t].length;++n)for(let s=0;s<e[r][t][n].length;++s)e[r][t][n][s]*=i[s]}return new ue("float32",Float32Array.from(e.flat(1/0)),r)}add_input_labels(e,t){let n=o(e);if(2===n.length)n=[1,...n],e=[e];else if(3!==n.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(n.some(((e,n)=>e!==t.dims[n])))throw Error(`The first ${n.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new ue("int64",e.flat(1/0).map(BigInt),n)}async _call(e,t=null,n=null){const r=await super._call(e);if(t&&(r.input_points=this.reshape_input_points(t,r.original_sizes,r.reshaped_input_sizes)),n){if(!r.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");r.input_labels=this.add_input_labels(n,r.input_points)}return r}post_process_masks(e,t,n,{mask_threshold:r=0,binarize:s=!0,pad_size:a=null}={}){const i=[],o=[(a=a??this.pad_size).height,a.width];for(let a=0;a<t.length;++a){const l=t[a],u=n[a],c=e[a],d=[];for(let e=0;e<c.dims[0];++e){let t=de(c[e],o,"bilinear",!1);if(t=t.slice(null,[0,u[0]],[0,u[1]]),t=de(t,l,"bilinear",!1),s){const e=new Uint8Array(t.data.length);for(let n=0;n<t.data.length;++n)t.data[n]>r&&(e[n]=1);t=new ue("bool",e,t.dims)}d.push(t)}i.push(ye(d))}return i}}class oh extends Ld{pad_image(e,t,n,r={}){const[s,a,i]=t;return super.pad_image(e,t,{width:a+(n-a%n)%n,height:s+(n-s%n)%n},{mode:"symmetric",center:!1,constant_values:-1,...r})}}class lh extends Ld{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=await Promise.all(e.map((e=>this.preprocess(e)))),r=await Promise.all(t.map((e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0}))));return{pixel_values:ye(n.map(((e,t)=>be([e.pixel_values,r[t].pixel_values],0))),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}}class uh extends Md{constructor(e){super(e),this.config.mel_filters??=Ed(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=Nd(this.config.n_fft,"hann")}_extract_fbank_features(e){const{data:t,dims:n}=Cd(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),r=J(t)[0];for(let e=0;e<t.length;++e)t[e]=(Math.max(t[e],r-8)+4)/4;return{data:t,dims:n}}async _call(e){let t;Dd(e,"WhisperFeatureExtractor"),e.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),t=e.slice(0,this.config.n_samples)):(t=new Float32Array(this.config.n_samples),t.set(e));const{data:n,dims:r}=this._extract_fbank_features(t);return{input_features:new ue("float32",n,[1,...r])}}}class ch extends Md{_zero_mean_unit_var_norm(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,n=e.reduce(((e,n)=>e+(n-t)**2),0)/e.length;return e.map((e=>(e-t)/Math.sqrt(n+1e-7)))}async _call(e){Dd(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const n=[1,t.length];return{input_values:new ue("float32",t,n),attention_mask:new ue("int64",new BigInt64Array(t.length).fill(1n),n)}}}class dh extends Md{constructor(e){super(e);const t=this.config.sampling_rate,n=Ed(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=Nd(400,"povey",{periodic:!1})}_extract_fbank_features(e,t){return Cd(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:n=2,do_normalize_per_mel_bins:r=!0,return_attention_mask:s=!0}={}){Dd(e,"SeamlessM4TFeatureExtractor");let a,i=this._extract_fbank_features(e,this.config.max_length);if(r){const[e,t]=i.dims;for(let n=0;n<t;++n){let r=0;for(let s=0;s<e;++s)r+=i.data[s*t+n];const s=r/e;let a=0;for(let r=0;r<e;++r)a+=(i.data[r*t+n]-s)**2;a/=e-1;const o=Math.sqrt(a+1e-7);for(let r=0;r<e;++r){const e=r*t+n;i.data[e]=(i.data[e]-s)/o}}}if(t){const[e,t]=i.dims,r=e%n;if(r>0){const n=new Float32Array(t*(e+r));n.set(i.data),n.fill(this.config.padding_value,i.data.length);const o=e+r;i={data:n,dims:[o,t]},s&&(a=new ue("int64",new BigInt64Array(o),[1,o]),a.data.fill(1n,0,e))}}const[o,l]=i.dims,u=this.config.stride;if(0!=o%u)throw new Error(`The number of frames (${o}) must be a multiple of the stride (${u}).`);const c=new ue("float32",i.data,i.dims).view(1,Math.floor(o/u),l*u),d={input_features:c};if(s){const e=c.dims[1],t=new ue("int64",new BigInt64Array(e),[1,e]);if(a)for(let e=1,n=0;e<o;e+=u,++n)t.data[n]=a.data[e];else t.data.fill(1n);d.attention_mask=t}return d}}class hh extends Md{constructor(e){super(e);const t=this.config.sampling_rate,n=Ed(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=Nd(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}_extract_fbank_features(e,t){return Cd(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){Dd(e,"ASTFeatureExtractor");const t=this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std;for(let n=0;n<t.data.length;++n)t.data[n]=(t.data[n]-this.mean)/e}return{input_values:new ue("float32",t.data,[1,...t.dims])}}}class ph extends Md{constructor(e){super(e),this.mel_filters=Ed(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=Ed(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=Nd(this.config.fft_window_size,"hann")}_get_input_mel(e,t,n,r){let s,a=!1;const i=e.length-t;if(i>0){if("rand_trunc"!==n)throw new Error(`Truncation strategy "${n}" not implemented`);{a=!0;const n=Math.floor(Math.random()*(i+1));e=e.subarray(n,n+t),s=this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples),s.dims=[1,...s.dims]}}else{if(i<0){let n=new Float64Array(t);if(n.set(e),"repeat"===r)for(let r=e.length;r<t;r+=e.length)n.set(e.subarray(0,Math.min(e.length,t-r)),r);else if("repeatpad"===r)for(let t=e.length;t<-i;t+=e.length)n.set(e,t);e=n}if("fusion"===n)throw new Error(`Truncation strategy "${n}" not implemented`);s=this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples),s.dims=[1,...s.dims]}return{...s,longer:a}}_extract_fbank_features(e,t,n=null){return Cd(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:n,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){Dd(e,"ClapFeatureExtractor");const n=this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding);return{input_features:new ue("float32",n.data,[1,...n.dims])}}}class fh extends Md{}class mh extends a{constructor(e){super(),this.feature_extractor=e}async _call(e,...t){return await this.feature_extractor(e,...t)}}class gh extends mh{async _call(...e){return await this.feature_extractor(...e)}post_process_masks(...e){return this.feature_extractor.post_process_masks(...e)}reshape_input_points(...e){return this.feature_extractor.reshape_input_points(...e)}}class bh extends mh{async _call(e){return await this.feature_extractor(e)}}class yh extends mh{async _call(e){return await this.feature_extractor(e)}}class wh extends mh{async _call(e){return await this.feature_extractor(e)}}class vh extends mh{}class xh{static FEATURE_EXTRACTOR_CLASS_MAPPING={ImageFeatureExtractor:Ld,WhisperFeatureExtractor:uh,ViTFeatureExtractor:Zd,MobileViTFeatureExtractor:Xd,OwlViTFeatureExtractor:Qd,Owlv2ImageProcessor:Jd,CLIPFeatureExtractor:jd,ChineseCLIPFeatureExtractor:Wd,SiglipImageProcessor:Gd,ConvNextFeatureExtractor:Hd,ConvNextImageProcessor:qd,SegformerFeatureExtractor:Pd,BitImageProcessor:Vd,DPTImageProcessor:Bd,DPTFeatureExtractor:zd,GLPNFeatureExtractor:Ud,BeitFeatureExtractor:th,DeiTFeatureExtractor:eh,DetrFeatureExtractor:sh,YolosFeatureExtractor:ah,DonutFeatureExtractor:nh,NougatImageProcessor:rh,EfficientNetImageProcessor:Yd,ViTImageProcessor:Kd,VitMatteImageProcessor:lh,SamImageProcessor:ih,Swin2SRImageProcessor:oh,Wav2Vec2FeatureExtractor:ch,SeamlessM4TFeatureExtractor:dh,SpeechT5FeatureExtractor:fh,ASTFeatureExtractor:hh,ClapFeatureExtractor:ph};static PROCESSOR_CLASS_MAPPING={WhisperProcessor:bh,Wav2Vec2ProcessorWithLM:yh,SamProcessor:gh,SpeechT5Processor:wh,OwlViTProcessor:vh};static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main"}={}){let i=n??await U(e,"preprocessor_config.json",!0,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a}),o=i.feature_extractor_type??i.image_processor_type,l=this.FEATURE_EXTRACTOR_CLASS_MAPPING[o];if(!l){if(void 0===i.size)throw new Error(`Unknown Feature Extractor type: ${o}`);console.warn(`Feature extractor type "${o}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),l=Ld}return new(this.PROCESSOR_CLASS_MAPPING[i.processor_class]??mh)(new l(i))}}async function _h(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>vd.read(e))))}async function kh(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>"string"==typeof e||e instanceof URL?xd(e,t):e instanceof Float64Array?new Float32Array(e):e)))}function Sh(e,t){t&&(e=e.map((e=>0|e)));const[n,r,s,a]=e;return{xmin:n,ymin:r,xmax:s,ymax:a}}class Th extends a{constructor({task:e,model:t,tokenizer:n=null,processor:r=null}){super(),this.task=e,this.model=t,this.tokenizer=n,this.processor=r}async dispose(){await this.model.dispose()}}class Ih extends Th{constructor(e){super(e)}async _call(e,{topk:t=1}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid().data:e=>H(e.data),a=this.model.config.id2label,i=[];for(const e of r.logits){const n=K(s(e),t).map((e=>({label:a[e[0]],score:e[1]})));1===t?i.push(...n):i.push(n)}return Array.isArray(e)||1===t?i:i[0]}}class Eh extends Th{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const n=Array.isArray(e),r=this.tokenizer(n?e:[e],{padding:!0,truncation:!0}),s=(await this.model(r)).logits,a=this.model.config.id2label,i=[];for(let e=0;e<s.dims[0];++e){const n=r.input_ids[e],o=s[e],l=[];for(let e=0;e<o.dims[0];++e){const r=o[e],s=J(r.data)[1],i=a?a[s]:`LABEL_${s}`;if(t.includes(i))continue;const u=this.tokenizer.decode([n[e].item()],{skip_special_tokens:!0});if(""===u)continue;const c=H(r.data);l.push({entity:i,score:c[s],index:e,word:u,start:null,end:null})}i.push(l)}return n?i:i[0]}}class Ah extends Th{constructor(e){super(e)}async _call(e,t,{topk:n=1}={}){const r=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r),a=[];for(let e=0;e<s.start_logits.dims[0];++e){const t=r.input_ids[e],i=t.indexOf(this.tokenizer.sep_token_id),o=c(Array.from(H(s.start_logits[e].data)).map(((e,t)=>[e,t])).filter((e=>e[1]>i)),Array.from(H(s.end_logits[e].data)).map(((e,t)=>[e,t])).filter((e=>e[1]>i))).filter((e=>e[0][1]<=e[1][1])).map((e=>[e[0][1],e[1][1],e[0][0]*e[1][0]])).sort(((e,t)=>t[2]-e[2]));for(let e=0;e<Math.min(o.length,n);++e){const[n,r,s]=o[e],i=[...t].slice(n,r+1),l=this.tokenizer.decode(i,{skip_special_tokens:!0});a.push({answer:l,score:s})}}return 1===n?a[0]:a}}class Ch extends Th{constructor(e){super(e)}async _call(e,{topk:t=5}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s=[];for(let e=0;e<n.input_ids.dims[0];++e){const a=n.input_ids[e],i=a.indexOf(this.tokenizer.mask_token_id);if(-1===i)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const o=K(H(r.logits[e][i].data),t);s.push(o.map((e=>{const t=[...a];return t[i]=e[0],{score:e[1],token:e[0],token_str:this.tokenizer.model.vocab[e[0]],sequence:this.tokenizer.decode(t,{skip_special_tokens:!0})}})))}return Array.isArray(e)?s:s[0]}}class Nh extends Th{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map((e=>this.model.config.prefix+e)));const n=this.model.config.task_specific_params;n&&n[this.task]&&n[this.task].prefix&&(e=e.map((e=>n[this.task].prefix+e)));const r=this.tokenizer,s={padding:!0,truncation:!0};let a;a=this instanceof Oh&&"_build_translation_inputs"in r?r._build_translation_inputs(e,s,t).input_ids:r(e,s).input_ids;const i=await this.model.generate(a,t);return r.batch_decode(i,{skip_special_tokens:!0}).map((e=>({[this._key]:e})))}}class $h extends Nh{_key="summary_text";constructor(e){super(e)}}class Oh extends Nh{_key="translation_text";constructor(e){super(e)}}function Dh(e){return Array.isArray(e)&&e.every((e=>"role"in e&&"content"in e))}class Fh extends Th{constructor(e){super(e)}async _call(e,t={}){let n,r=!1,s=!1;if("string"==typeof e)n=e=[e];else if(Array.isArray(e)&&e.every((e=>"string"==typeof e)))r=!0,n=e;else{if(Dh(e))e=[e];else{if(!Array.isArray(e)||!e.every(Dh))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");r=!0}s=!0,n=e.map((e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})))}const a=t.add_special_tokens??!1,i=!s&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const{input_ids:o,attention_mask:l}=this.tokenizer(n,{add_special_tokens:a,padding:!0,truncation:!0}),u=await this.model.generate(o,t,null,{inputs_attention_mask:l});let c,d=this.tokenizer.batch_decode(u,{skip_special_tokens:!0});!i&&o.dims.at(-1)>0&&(c=this.tokenizer.batch_decode(o,{skip_special_tokens:!0}).map((e=>e.length)));const h=Array.from({length:e.length},(e=>[]));for(let t=0;t<d.length;++t){const n=Math.floor(t/u.length*e.length);c&&(d[t]=d[t].slice(c[n])),h[n].push({generated_text:s?[...e[n],{role:"assistant",content:d[t]}]:d[t]})}return r||1!==h.length?h:h[0]}}class Rh extends Th{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map((([e,t])=>[e.toLowerCase(),t]))),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:n="This example is {}.",multi_label:r=!1}={}){const s=Array.isArray(e);s||(e=[e]),Array.isArray(t)||(t=[t]);const a=t.map((e=>n.replace("{}",e))),i=r||1===t.length,o=[];for(const n of e){const e=[];for(const t of a){const r=this.tokenizer(n,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r);i?e.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):e.push(s.logits.data[this.entailment_id])}const r=(i?e.map((e=>H(e)[1])):H(e)).map(((e,t)=>[e,t])).sort(((e,t)=>t[0]-e[0]));o.push({sequence:n,labels:r.map((e=>t[e[1]])),scores:r.map((e=>e[0]))})}return s?o:o[0]}}class Mh extends Th{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:n=!1,quantize:r=!1,precision:s="binary"}={}){const a=this.tokenizer(e,{padding:!0,truncation:!0}),i=await this.model(a);let o=i.last_hidden_state??i.logits;if("none"===t);else if("mean"===t)o=he(o,a.attention_mask);else{if("cls"!==t)throw Error(`Pooling method '${t}' not supported.`);o=o.slice(null,0)}return n&&(o=o.normalize(2,-1)),r&&(o=Se(o,s)),o}}class Lh extends Th{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const n=await _h(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r});let a;if(t){if(!("pooler_output"in s))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");a=s.pooler_output}else a=s.last_hidden_state??s.logits??s.image_embeds;return a}}class Ph extends Th{constructor(e){super(e)}async _call(e,{topk:t=null}={}){const n=!Array.isArray(e),r=this.processor.feature_extractor.config.sampling_rate,s=await kh(e,r),a=this.model.config.id2label,i=[];for(const e of s){const n=await this.processor(e),r=K(H((await this.model(n)).logits[0].data),t).map((e=>({label:a[e[0]],score:e[1]})));1===t?i.push(...r):i.push(r)}return n&&1!==t?i[0]:i}}class zh extends Th{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a sound of {}."}={}){const r=!Array.isArray(e);r&&(e=[e]);const s=t.map((e=>n.replace("{}",e))),a=this.tokenizer(s,{padding:!0,truncation:!0}),i=this.processor.feature_extractor.config.sampling_rate,o=await kh(e,i),l=[];for(const e of o){const n=await this.processor(e),r=H((await this.model({...a,...n})).logits_per_audio.data);l.push([...r].map(((e,n)=>({score:e,label:t[n]}))))}return r?l[0]:l}}class Bh extends Th{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(e,t={}){t.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),t.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await kh(e,r),a=[];for(const e of s){const t=await this.processor(e),n=(await this.model(t)).logits[0],r=[];for(const e of n)r.push(J(e.data)[1]);const s=this.tokenizer.decode(r);a.push({text:s})}return n?a[0]:a}async _call_whisper(e,t={}){const n=t.return_timestamps??!1,r=t.chunk_length_s??0,s=t.chunk_callback??null,a=t.force_full_sequences??!1;let i=t.stride_length_s??null;"word"===n&&(t.return_token_timestamps=!0);const o=l(t,"language",null),u=l(t,"task",null);if(o||u||n){if(t.forced_decoder_ids)throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");const e=this.tokenizer.get_decoder_prompt_ids({language:o,task:u,no_timestamps:!n});e.length>0&&(t.forced_decoder_ids=e)}const c=!Array.isArray(e);c&&(e=[e]);const d=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,h=this.processor.feature_extractor.config.hop_length,p=this.processor.feature_extractor.config.sampling_rate,f=await kh(e,p),m=[];for(const e of f){let o=[];if(r>0){if(null===i)i=r/6;else if(r<=i)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const t=p*r,n=p*i,s=t-2*n;let a=0;for(;a<e.length;){const r=e.subarray(a,a+t),i=await this.processor(r),l=0===a,u=a+s>=e.length;o.push({stride:[r.length,l?0:n,u?0:n],input_features:i.input_features,is_last:u}),a+=s}}else o=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of o){t.num_frames=Math.floor(e.stride[0]/h);const r=await this.model.generate(e.input_features,t);"word"===n?(e.tokens=r.sequences[0],e.token_timestamps=r.token_timestamps.tolist()[0].map((e=>ae(e,2)))):e.tokens=r[0],e.stride=e.stride.map((e=>e/p)),null!==s&&s(e)}const[l,u]=this.tokenizer._decode_asr(o,{time_precision:d,return_timestamps:n,force_full_sequences:a});m.push({text:l,...u})}return c?m[0]:m}}class Vh extends Th{constructor(e){super(e)}async _call(e,t={}){const n=Array.isArray(e),r=await _h(e),{pixel_values:s}=await this.processor(r),a=[];for(const e of s){e.dims=[1,...e.dims];const n=await this.model.generate(e,t),r=this.tokenizer.batch_decode(n,{skip_special_tokens:!0}).map((e=>({generated_text:e.trim()})));a.push(r)}return n?a:a[0]}}class Uh extends Th{constructor(e){super(e)}async _call(e,{topk:t=1}={}){const n=Array.isArray(e),r=await _h(e),{pixel_values:s}=await this.processor(r),a=await this.model({pixel_values:s}),i=this.model.config.id2label,o=[];for(const e of a.logits){const n=K(H(e.data),t).map((e=>({label:i[e[0]],score:e[1]})));1===t?o.push(...n):o.push(n)}return n||1===t?o:o[0]}}class jh extends Th{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:n=.5,overlap_mask_area_threshold:r=.8,label_ids_to_fuse:s=null,target_sizes:a=null,subtask:i=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const o=await _h(e),l=o.map((e=>[e.height,e.width])),{pixel_values:u,pixel_mask:c}=await this.processor(o),d=await this.model({pixel_values:u,pixel_mask:c});let h=null;if(null!==i)h=this.subtasks_mapping[i];else for(let[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.feature_extractor){h=this.processor.feature_extractor[t].bind(this.processor.feature_extractor),i=e;break}const p=this.model.config.id2label,f=[];if("panoptic"===i||"instance"===i){const e=h(d,t,n,r,s,a??l)[0],i=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(i.data.length);for(let n=0;n<i.data.length;++n)i.data[n]===t.id&&(e[n]=255);const n=new vd(e,i.dims[1],i.dims[0],1);f.push({score:t.score,label:p[t.label_id],mask:n})}}else{if("semantic"!==i)throw Error(`Subtask ${i} not supported.`);{const{segmentation:e,labels:t}=h(d,a??l)[0];for(const n of t){const t=new Uint8ClampedArray(e.data.length);for(let r=0;r<e.data.length;++r)e.data[r]===n&&(t[r]=255);const r=new vd(t,e.dims[1],e.dims[0],1);f.push({score:null,label:p[n],mask:r})}}}return f}}class Wh extends Th{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a photo of {}"}={}){const r=Array.isArray(e),s=await _h(e),a=t.map((e=>n.replace("{}",e))),i=this.tokenizer(a,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:o}=await this.processor(s),l=await this.model({...i,pixel_values:o}),u="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>H(e.data),c=[];for(const e of l.logits_per_image){const n=[...u(e)].map(((e,n)=>({score:e,label:t[n]})));n.sort(((e,t)=>t.score-e.score)),c.push(n)}return r?c:c[0]}}class Gh extends Th{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:n=!1}={}){const r=Array.isArray(e);if(r&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const s=await _h(e),a=n?null:s.map((e=>[e.height,e.width])),{pixel_values:i,pixel_mask:o}=await this.processor(s),l=await this.model({pixel_values:i,pixel_mask:o}),u=this.processor.feature_extractor.post_process_object_detection(l,t,a),c=this.model.config.id2label,d=u.map((e=>e.boxes.map(((t,r)=>({score:e.scores[r],label:c[e.classes[r]],box:Sh(t,!n)})))));return r?d:d[0]}}class Hh extends Th{constructor(e){super(e)}async _call(e,t,{threshold:n=.1,topk:r=null,percentage:s=!1}={}){const a=Array.isArray(e),i=await _h(e),o=this.tokenizer(t,{padding:!0,truncation:!0}),l=await this.processor(i),u=[];for(let e=0;e<i.length;++e){const a=i[e],c=s?null:[[a.height,a.width]],d=l.pixel_values[e].unsqueeze_(0),h=await this.model({...o,pixel_values:d}),p=this.processor.feature_extractor.post_process_object_detection(h,n,c,!0)[0];let f=p.boxes.map(((e,n)=>({score:p.scores[n],label:t[p.classes[n]],box:Sh(e,!s)}))).sort(((e,t)=>t.score-e.score));null!==r&&(f=f.slice(0,r)),u.push(f)}return a?u:u[0]}}class qh extends Th{constructor(e){super(e)}async _call(e,t,n={}){const r=(await _h(e))[0],{pixel_values:s}=await this.processor(r),a=`<s_docvqa><s_question>${t}</s_question><s_answer>`,i=this.tokenizer(a,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,o=await this.model.generate(s,{...n,decoder_input_ids:i,max_length:this.model.config.decoder.max_position_embeddings}),l=this.tokenizer.batch_decode(o)[0].match(/<s_answer>(.*?)<\/s_answer>/);let u=null;return l&&l.length>=2&&(u=l[1].trim()),[{answer:u}]}}class Zh extends Th{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model(t),r=this.model.config.sampling_rate;return{audio:n.data,sampling_rate:r}}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await Nc.from_pretrained(this.DEFAULT_VOCODER_ID,{quantized:!1})),("string"==typeof t||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new ue("float32",t,[1,t.length]);else if(!(t instanceof ue))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:n}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:r}=await this.model.generate_speech(n,t,{vocoder:this.vocoder}),s=this.processor.feature_extractor.config.sampling_rate;return{audio:r.data,sampling_rate:s}}}class Kh extends Th{constructor(e){super(e)}async _call(e){const t=await _h(e),n=await this.processor(t),r=await this.model(n),s=[];for(const e of r.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");s.push(vd.fromTensor(t))}return s.length>1?s:s[0]}}class Yh extends Th{constructor(e){super(e)}async _call(e){const t=await _h(e),n=await this.processor(t),{predicted_depth:r}=await this.model(n),s=[];for(let e=0;e<t.length;++e){const n=de(r[e],t[e].size.reverse(),"bilinear",!1),a=n.mul_(255/J(n.data)[0]).to("uint8");s.push({predicted_depth:r[e],depth:vd.fromTensor(a)})}return s.length>1?s:s[0]}}const Xh=Object.freeze({"text-classification":{tokenizer:Ir,pipeline:Ih,model:$c,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:Ir,pipeline:Eh,model:Oc,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:Ir,pipeline:Ah,model:zc,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:Ir,pipeline:Ch,model:Pc,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:Ir,pipeline:$h,model:Dc,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:Ir,pipeline:Oh,model:Dc,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:Ir,pipeline:Nh,model:Dc,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:Ir,pipeline:Fh,model:Lc,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:Ir,pipeline:Rh,model:$c,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:Ph,model:Zc,processor:xh,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:Ir,pipeline:zh,model:Nc,processor:xh,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:Ir,pipeline:Bh,model:[Fc,qc],processor:xh,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:Ir,pipeline:Zh,model:[Mc,Rc],processor:[xh,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:Ir,pipeline:Vh,model:Bc,processor:xh,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:Uh,model:Vc,processor:xh,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:jh,model:[Uc,jc],processor:xh,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:Ir,pipeline:Wh,model:Nc,processor:xh,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:Gh,model:Wc,processor:xh,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:Ir,pipeline:Hh,model:Gc,processor:xh,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:Ir,pipeline:qh,model:Xc,processor:xh,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:Kh,model:Jc,processor:xh,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Yh,model:ed,processor:xh,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:Ir,pipeline:Mh,model:Nc,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:xh,pipeline:Lh,model:[td,Nc],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Qh=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Jh(e,t=null,{quantized:n=!0,progress_callback:s=null,config:a=null,cache_dir:i=null,local_files_only:o=!1,revision:l="main"}={}){e=Qh[e]??e;const u=Xh[e.split("_",1)[0]];if(!u)throw Error(`Unsupported pipeline: ${e}. Must be one of [${Object.keys(Xh)}]`);t||(t=u.default.model,console.log(`No model specified. Using default model: "${t}".`));const c={quantized:n,progress_callback:s,config:a,cache_dir:i,local_files_only:o,revision:l},d=new Map([["tokenizer",u.tokenizer],["model",u.model],["processor",u.processor]]),h=await async function(e,t,n){const r=Object.create(null),s=[];for(let[a,i]of e.entries()){if(!i)continue;let e;e=Array.isArray(i)?new Promise((async(e,r)=>{let s;for(let r of i){if(null===r)return void e(null);try{return void e(await r.from_pretrained(t,n))}catch(e){s=e}}r(s)})):i.from_pretrained(t,n),r[a]=e,s.push(e)}await Promise.all(s);for(let[e,t]of Object.entries(r))r[e]=await t;return r}(d,t,c);return h.task=e,r(s,{status:"ready",task:e,model:t}),new(0,u.pipeline)(h)}}}]);